
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model GroupMember
 * 
 */
export type GroupMember = $Result.DefaultSelection<Prisma.$GroupMemberPayload>
/**
 * Model Invitation
 * 
 */
export type Invitation = $Result.DefaultSelection<Prisma.$InvitationPayload>
/**
 * Model Exercise
 * 
 */
export type Exercise = $Result.DefaultSelection<Prisma.$ExercisePayload>
/**
 * Model ExerciseRating
 * 
 */
export type ExerciseRating = $Result.DefaultSelection<Prisma.$ExerciseRatingPayload>
/**
 * Model ExerciseHistory
 * 
 */
export type ExerciseHistory = $Result.DefaultSelection<Prisma.$ExerciseHistoryPayload>
/**
 * Model FavoriteExercise
 * 
 */
export type FavoriteExercise = $Result.DefaultSelection<Prisma.$FavoriteExercisePayload>
/**
 * Model WorkoutSession
 * 
 */
export type WorkoutSession = $Result.DefaultSelection<Prisma.$WorkoutSessionPayload>
/**
 * Model ExerciseLog
 * 
 */
export type ExerciseLog = $Result.DefaultSelection<Prisma.$ExerciseLogPayload>
/**
 * Model Program
 * 
 */
export type Program = $Result.DefaultSelection<Prisma.$ProgramPayload>
/**
 * Model ProgramBlock
 * 
 */
export type ProgramBlock = $Result.DefaultSelection<Prisma.$ProgramBlockPayload>
/**
 * Model Week
 * 
 */
export type Week = $Result.DefaultSelection<Prisma.$WeekPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model SessionExercise
 * 
 */
export type SessionExercise = $Result.DefaultSelection<Prisma.$SessionExercisePayload>
/**
 * Model SessionProgress
 * 
 */
export type SessionProgress = $Result.DefaultSelection<Prisma.$SessionProgressPayload>
/**
 * Model ProgramAssignment
 * 
 */
export type ProgramAssignment = $Result.DefaultSelection<Prisma.$ProgramAssignmentPayload>
/**
 * Model ProgramAudit
 * 
 */
export type ProgramAudit = $Result.DefaultSelection<Prisma.$ProgramAuditPayload>
/**
 * Model Badge
 * 
 */
export type Badge = $Result.DefaultSelection<Prisma.$BadgePayload>
/**
 * Model UserBadge
 * 
 */
export type UserBadge = $Result.DefaultSelection<Prisma.$UserBadgePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  admin: 'admin',
  coach: 'coach',
  student: 'student'
};

export type Role = (typeof Role)[keyof typeof Role]


export const InvitationStatus: {
  pending: 'pending',
  accepted: 'accepted',
  rejected: 'rejected'
};

export type InvitationStatus = (typeof InvitationStatus)[keyof typeof InvitationStatus]


export const ExerciseType: {
  standard: 'standard',
  EMOM: 'EMOM',
  AMRAP: 'AMRAP',
  custom: 'custom'
};

export type ExerciseType = (typeof ExerciseType)[keyof typeof ExerciseType]


export const Scope: {
  global: 'global',
  coach: 'coach'
};

export type Scope = (typeof Scope)[keyof typeof Scope]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type InvitationStatus = $Enums.InvitationStatus

export const InvitationStatus: typeof $Enums.InvitationStatus

export type ExerciseType = $Enums.ExerciseType

export const ExerciseType: typeof $Enums.ExerciseType

export type Scope = $Enums.Scope

export const Scope: typeof $Enums.Scope

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs>;

  /**
   * `prisma.groupMember`: Exposes CRUD operations for the **GroupMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupMembers
    * const groupMembers = await prisma.groupMember.findMany()
    * ```
    */
  get groupMember(): Prisma.GroupMemberDelegate<ExtArgs>;

  /**
   * `prisma.invitation`: Exposes CRUD operations for the **Invitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitation.findMany()
    * ```
    */
  get invitation(): Prisma.InvitationDelegate<ExtArgs>;

  /**
   * `prisma.exercise`: Exposes CRUD operations for the **Exercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exercises
    * const exercises = await prisma.exercise.findMany()
    * ```
    */
  get exercise(): Prisma.ExerciseDelegate<ExtArgs>;

  /**
   * `prisma.exerciseRating`: Exposes CRUD operations for the **ExerciseRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExerciseRatings
    * const exerciseRatings = await prisma.exerciseRating.findMany()
    * ```
    */
  get exerciseRating(): Prisma.ExerciseRatingDelegate<ExtArgs>;

  /**
   * `prisma.exerciseHistory`: Exposes CRUD operations for the **ExerciseHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExerciseHistories
    * const exerciseHistories = await prisma.exerciseHistory.findMany()
    * ```
    */
  get exerciseHistory(): Prisma.ExerciseHistoryDelegate<ExtArgs>;

  /**
   * `prisma.favoriteExercise`: Exposes CRUD operations for the **FavoriteExercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FavoriteExercises
    * const favoriteExercises = await prisma.favoriteExercise.findMany()
    * ```
    */
  get favoriteExercise(): Prisma.FavoriteExerciseDelegate<ExtArgs>;

  /**
   * `prisma.workoutSession`: Exposes CRUD operations for the **WorkoutSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkoutSessions
    * const workoutSessions = await prisma.workoutSession.findMany()
    * ```
    */
  get workoutSession(): Prisma.WorkoutSessionDelegate<ExtArgs>;

  /**
   * `prisma.exerciseLog`: Exposes CRUD operations for the **ExerciseLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExerciseLogs
    * const exerciseLogs = await prisma.exerciseLog.findMany()
    * ```
    */
  get exerciseLog(): Prisma.ExerciseLogDelegate<ExtArgs>;

  /**
   * `prisma.program`: Exposes CRUD operations for the **Program** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programs
    * const programs = await prisma.program.findMany()
    * ```
    */
  get program(): Prisma.ProgramDelegate<ExtArgs>;

  /**
   * `prisma.programBlock`: Exposes CRUD operations for the **ProgramBlock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramBlocks
    * const programBlocks = await prisma.programBlock.findMany()
    * ```
    */
  get programBlock(): Prisma.ProgramBlockDelegate<ExtArgs>;

  /**
   * `prisma.week`: Exposes CRUD operations for the **Week** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weeks
    * const weeks = await prisma.week.findMany()
    * ```
    */
  get week(): Prisma.WeekDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.sessionExercise`: Exposes CRUD operations for the **SessionExercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionExercises
    * const sessionExercises = await prisma.sessionExercise.findMany()
    * ```
    */
  get sessionExercise(): Prisma.SessionExerciseDelegate<ExtArgs>;

  /**
   * `prisma.sessionProgress`: Exposes CRUD operations for the **SessionProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionProgresses
    * const sessionProgresses = await prisma.sessionProgress.findMany()
    * ```
    */
  get sessionProgress(): Prisma.SessionProgressDelegate<ExtArgs>;

  /**
   * `prisma.programAssignment`: Exposes CRUD operations for the **ProgramAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramAssignments
    * const programAssignments = await prisma.programAssignment.findMany()
    * ```
    */
  get programAssignment(): Prisma.ProgramAssignmentDelegate<ExtArgs>;

  /**
   * `prisma.programAudit`: Exposes CRUD operations for the **ProgramAudit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramAudits
    * const programAudits = await prisma.programAudit.findMany()
    * ```
    */
  get programAudit(): Prisma.ProgramAuditDelegate<ExtArgs>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **Badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.BadgeDelegate<ExtArgs>;

  /**
   * `prisma.userBadge`: Exposes CRUD operations for the **UserBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBadges
    * const userBadges = await prisma.userBadge.findMany()
    * ```
    */
  get userBadge(): Prisma.UserBadgeDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Group: 'Group',
    GroupMember: 'GroupMember',
    Invitation: 'Invitation',
    Exercise: 'Exercise',
    ExerciseRating: 'ExerciseRating',
    ExerciseHistory: 'ExerciseHistory',
    FavoriteExercise: 'FavoriteExercise',
    WorkoutSession: 'WorkoutSession',
    ExerciseLog: 'ExerciseLog',
    Program: 'Program',
    ProgramBlock: 'ProgramBlock',
    Week: 'Week',
    Session: 'Session',
    SessionExercise: 'SessionExercise',
    SessionProgress: 'SessionProgress',
    ProgramAssignment: 'ProgramAssignment',
    ProgramAudit: 'ProgramAudit',
    Badge: 'Badge',
    UserBadge: 'UserBadge',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "group" | "groupMember" | "invitation" | "exercise" | "exerciseRating" | "exerciseHistory" | "favoriteExercise" | "workoutSession" | "exerciseLog" | "program" | "programBlock" | "week" | "session" | "sessionExercise" | "sessionProgress" | "programAssignment" | "programAudit" | "badge" | "userBadge" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      GroupMember: {
        payload: Prisma.$GroupMemberPayload<ExtArgs>
        fields: Prisma.GroupMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          findFirst: {
            args: Prisma.GroupMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          findMany: {
            args: Prisma.GroupMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          create: {
            args: Prisma.GroupMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          createMany: {
            args: Prisma.GroupMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          delete: {
            args: Prisma.GroupMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          update: {
            args: Prisma.GroupMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          deleteMany: {
            args: Prisma.GroupMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GroupMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          aggregate: {
            args: Prisma.GroupMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupMember>
          }
          groupBy: {
            args: Prisma.GroupMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupMemberCountArgs<ExtArgs>
            result: $Utils.Optional<GroupMemberCountAggregateOutputType> | number
          }
        }
      }
      Invitation: {
        payload: Prisma.$InvitationPayload<ExtArgs>
        fields: Prisma.InvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findFirst: {
            args: Prisma.InvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findMany: {
            args: Prisma.InvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          create: {
            args: Prisma.InvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          createMany: {
            args: Prisma.InvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          delete: {
            args: Prisma.InvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          update: {
            args: Prisma.InvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          deleteMany: {
            args: Prisma.InvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          aggregate: {
            args: Prisma.InvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitation>
          }
          groupBy: {
            args: Prisma.InvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationCountAggregateOutputType> | number
          }
        }
      }
      Exercise: {
        payload: Prisma.$ExercisePayload<ExtArgs>
        fields: Prisma.ExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findFirst: {
            args: Prisma.ExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findMany: {
            args: Prisma.ExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          create: {
            args: Prisma.ExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          createMany: {
            args: Prisma.ExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          delete: {
            args: Prisma.ExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          update: {
            args: Prisma.ExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          deleteMany: {
            args: Prisma.ExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          aggregate: {
            args: Prisma.ExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExercise>
          }
          groupBy: {
            args: Prisma.ExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseCountAggregateOutputType> | number
          }
        }
      }
      ExerciseRating: {
        payload: Prisma.$ExerciseRatingPayload<ExtArgs>
        fields: Prisma.ExerciseRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseRatingPayload>
          }
          findFirst: {
            args: Prisma.ExerciseRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseRatingPayload>
          }
          findMany: {
            args: Prisma.ExerciseRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseRatingPayload>[]
          }
          create: {
            args: Prisma.ExerciseRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseRatingPayload>
          }
          createMany: {
            args: Prisma.ExerciseRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseRatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseRatingPayload>[]
          }
          delete: {
            args: Prisma.ExerciseRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseRatingPayload>
          }
          update: {
            args: Prisma.ExerciseRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseRatingPayload>
          }
          deleteMany: {
            args: Prisma.ExerciseRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExerciseRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseRatingPayload>
          }
          aggregate: {
            args: Prisma.ExerciseRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExerciseRating>
          }
          groupBy: {
            args: Prisma.ExerciseRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseRatingCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseRatingCountAggregateOutputType> | number
          }
        }
      }
      ExerciseHistory: {
        payload: Prisma.$ExerciseHistoryPayload<ExtArgs>
        fields: Prisma.ExerciseHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseHistoryPayload>
          }
          findFirst: {
            args: Prisma.ExerciseHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseHistoryPayload>
          }
          findMany: {
            args: Prisma.ExerciseHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseHistoryPayload>[]
          }
          create: {
            args: Prisma.ExerciseHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseHistoryPayload>
          }
          createMany: {
            args: Prisma.ExerciseHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseHistoryPayload>[]
          }
          delete: {
            args: Prisma.ExerciseHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseHistoryPayload>
          }
          update: {
            args: Prisma.ExerciseHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ExerciseHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExerciseHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseHistoryPayload>
          }
          aggregate: {
            args: Prisma.ExerciseHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExerciseHistory>
          }
          groupBy: {
            args: Prisma.ExerciseHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseHistoryCountAggregateOutputType> | number
          }
        }
      }
      FavoriteExercise: {
        payload: Prisma.$FavoriteExercisePayload<ExtArgs>
        fields: Prisma.FavoriteExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoriteExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoriteExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteExercisePayload>
          }
          findFirst: {
            args: Prisma.FavoriteExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoriteExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteExercisePayload>
          }
          findMany: {
            args: Prisma.FavoriteExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteExercisePayload>[]
          }
          create: {
            args: Prisma.FavoriteExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteExercisePayload>
          }
          createMany: {
            args: Prisma.FavoriteExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavoriteExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteExercisePayload>[]
          }
          delete: {
            args: Prisma.FavoriteExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteExercisePayload>
          }
          update: {
            args: Prisma.FavoriteExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteExercisePayload>
          }
          deleteMany: {
            args: Prisma.FavoriteExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavoriteExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FavoriteExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteExercisePayload>
          }
          aggregate: {
            args: Prisma.FavoriteExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavoriteExercise>
          }
          groupBy: {
            args: Prisma.FavoriteExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavoriteExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoriteExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<FavoriteExerciseCountAggregateOutputType> | number
          }
        }
      }
      WorkoutSession: {
        payload: Prisma.$WorkoutSessionPayload<ExtArgs>
        fields: Prisma.WorkoutSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkoutSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkoutSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSessionPayload>
          }
          findFirst: {
            args: Prisma.WorkoutSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkoutSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSessionPayload>
          }
          findMany: {
            args: Prisma.WorkoutSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSessionPayload>[]
          }
          create: {
            args: Prisma.WorkoutSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSessionPayload>
          }
          createMany: {
            args: Prisma.WorkoutSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkoutSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSessionPayload>[]
          }
          delete: {
            args: Prisma.WorkoutSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSessionPayload>
          }
          update: {
            args: Prisma.WorkoutSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSessionPayload>
          }
          deleteMany: {
            args: Prisma.WorkoutSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkoutSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkoutSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSessionPayload>
          }
          aggregate: {
            args: Prisma.WorkoutSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkoutSession>
          }
          groupBy: {
            args: Prisma.WorkoutSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkoutSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkoutSessionCountArgs<ExtArgs>
            result: $Utils.Optional<WorkoutSessionCountAggregateOutputType> | number
          }
        }
      }
      ExerciseLog: {
        payload: Prisma.$ExerciseLogPayload<ExtArgs>
        fields: Prisma.ExerciseLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload>
          }
          findFirst: {
            args: Prisma.ExerciseLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload>
          }
          findMany: {
            args: Prisma.ExerciseLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload>[]
          }
          create: {
            args: Prisma.ExerciseLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload>
          }
          createMany: {
            args: Prisma.ExerciseLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload>[]
          }
          delete: {
            args: Prisma.ExerciseLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload>
          }
          update: {
            args: Prisma.ExerciseLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload>
          }
          deleteMany: {
            args: Prisma.ExerciseLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExerciseLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload>
          }
          aggregate: {
            args: Prisma.ExerciseLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExerciseLog>
          }
          groupBy: {
            args: Prisma.ExerciseLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseLogCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseLogCountAggregateOutputType> | number
          }
        }
      }
      Program: {
        payload: Prisma.$ProgramPayload<ExtArgs>
        fields: Prisma.ProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findFirst: {
            args: Prisma.ProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findMany: {
            args: Prisma.ProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          create: {
            args: Prisma.ProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          createMany: {
            args: Prisma.ProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          delete: {
            args: Prisma.ProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          update: {
            args: Prisma.ProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          deleteMany: {
            args: Prisma.ProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          aggregate: {
            args: Prisma.ProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgram>
          }
          groupBy: {
            args: Prisma.ProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramCountAggregateOutputType> | number
          }
        }
      }
      ProgramBlock: {
        payload: Prisma.$ProgramBlockPayload<ExtArgs>
        fields: Prisma.ProgramBlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramBlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramBlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramBlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramBlockPayload>
          }
          findFirst: {
            args: Prisma.ProgramBlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramBlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramBlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramBlockPayload>
          }
          findMany: {
            args: Prisma.ProgramBlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramBlockPayload>[]
          }
          create: {
            args: Prisma.ProgramBlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramBlockPayload>
          }
          createMany: {
            args: Prisma.ProgramBlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramBlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramBlockPayload>[]
          }
          delete: {
            args: Prisma.ProgramBlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramBlockPayload>
          }
          update: {
            args: Prisma.ProgramBlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramBlockPayload>
          }
          deleteMany: {
            args: Prisma.ProgramBlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramBlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgramBlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramBlockPayload>
          }
          aggregate: {
            args: Prisma.ProgramBlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgramBlock>
          }
          groupBy: {
            args: Prisma.ProgramBlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramBlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramBlockCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramBlockCountAggregateOutputType> | number
          }
        }
      }
      Week: {
        payload: Prisma.$WeekPayload<ExtArgs>
        fields: Prisma.WeekFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeekFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeekFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPayload>
          }
          findFirst: {
            args: Prisma.WeekFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeekFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPayload>
          }
          findMany: {
            args: Prisma.WeekFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPayload>[]
          }
          create: {
            args: Prisma.WeekCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPayload>
          }
          createMany: {
            args: Prisma.WeekCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeekCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPayload>[]
          }
          delete: {
            args: Prisma.WeekDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPayload>
          }
          update: {
            args: Prisma.WeekUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPayload>
          }
          deleteMany: {
            args: Prisma.WeekDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeekUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WeekUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPayload>
          }
          aggregate: {
            args: Prisma.WeekAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeek>
          }
          groupBy: {
            args: Prisma.WeekGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeekGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeekCountArgs<ExtArgs>
            result: $Utils.Optional<WeekCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      SessionExercise: {
        payload: Prisma.$SessionExercisePayload<ExtArgs>
        fields: Prisma.SessionExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionExercisePayload>
          }
          findFirst: {
            args: Prisma.SessionExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionExercisePayload>
          }
          findMany: {
            args: Prisma.SessionExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionExercisePayload>[]
          }
          create: {
            args: Prisma.SessionExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionExercisePayload>
          }
          createMany: {
            args: Prisma.SessionExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionExercisePayload>[]
          }
          delete: {
            args: Prisma.SessionExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionExercisePayload>
          }
          update: {
            args: Prisma.SessionExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionExercisePayload>
          }
          deleteMany: {
            args: Prisma.SessionExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionExercisePayload>
          }
          aggregate: {
            args: Prisma.SessionExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionExercise>
          }
          groupBy: {
            args: Prisma.SessionExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<SessionExerciseCountAggregateOutputType> | number
          }
        }
      }
      SessionProgress: {
        payload: Prisma.$SessionProgressPayload<ExtArgs>
        fields: Prisma.SessionProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionProgressPayload>
          }
          findFirst: {
            args: Prisma.SessionProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionProgressPayload>
          }
          findMany: {
            args: Prisma.SessionProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionProgressPayload>[]
          }
          create: {
            args: Prisma.SessionProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionProgressPayload>
          }
          createMany: {
            args: Prisma.SessionProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionProgressPayload>[]
          }
          delete: {
            args: Prisma.SessionProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionProgressPayload>
          }
          update: {
            args: Prisma.SessionProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionProgressPayload>
          }
          deleteMany: {
            args: Prisma.SessionProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionProgressPayload>
          }
          aggregate: {
            args: Prisma.SessionProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionProgress>
          }
          groupBy: {
            args: Prisma.SessionProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionProgressCountArgs<ExtArgs>
            result: $Utils.Optional<SessionProgressCountAggregateOutputType> | number
          }
        }
      }
      ProgramAssignment: {
        payload: Prisma.$ProgramAssignmentPayload<ExtArgs>
        fields: Prisma.ProgramAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramAssignmentPayload>
          }
          findFirst: {
            args: Prisma.ProgramAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramAssignmentPayload>
          }
          findMany: {
            args: Prisma.ProgramAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramAssignmentPayload>[]
          }
          create: {
            args: Prisma.ProgramAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramAssignmentPayload>
          }
          createMany: {
            args: Prisma.ProgramAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramAssignmentPayload>[]
          }
          delete: {
            args: Prisma.ProgramAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramAssignmentPayload>
          }
          update: {
            args: Prisma.ProgramAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.ProgramAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgramAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramAssignmentPayload>
          }
          aggregate: {
            args: Prisma.ProgramAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgramAssignment>
          }
          groupBy: {
            args: Prisma.ProgramAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramAssignmentCountAggregateOutputType> | number
          }
        }
      }
      ProgramAudit: {
        payload: Prisma.$ProgramAuditPayload<ExtArgs>
        fields: Prisma.ProgramAuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramAuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramAuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramAuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramAuditPayload>
          }
          findFirst: {
            args: Prisma.ProgramAuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramAuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramAuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramAuditPayload>
          }
          findMany: {
            args: Prisma.ProgramAuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramAuditPayload>[]
          }
          create: {
            args: Prisma.ProgramAuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramAuditPayload>
          }
          createMany: {
            args: Prisma.ProgramAuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramAuditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramAuditPayload>[]
          }
          delete: {
            args: Prisma.ProgramAuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramAuditPayload>
          }
          update: {
            args: Prisma.ProgramAuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramAuditPayload>
          }
          deleteMany: {
            args: Prisma.ProgramAuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramAuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgramAuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramAuditPayload>
          }
          aggregate: {
            args: Prisma.ProgramAuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgramAudit>
          }
          groupBy: {
            args: Prisma.ProgramAuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramAuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramAuditCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramAuditCountAggregateOutputType> | number
          }
        }
      }
      Badge: {
        payload: Prisma.$BadgePayload<ExtArgs>
        fields: Prisma.BadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findFirst: {
            args: Prisma.BadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findMany: {
            args: Prisma.BadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          create: {
            args: Prisma.BadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          createMany: {
            args: Prisma.BadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          delete: {
            args: Prisma.BadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          update: {
            args: Prisma.BadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          deleteMany: {
            args: Prisma.BadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadge>
          }
          groupBy: {
            args: Prisma.BadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number
          }
        }
      }
      UserBadge: {
        payload: Prisma.$UserBadgePayload<ExtArgs>
        fields: Prisma.UserBadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findFirst: {
            args: Prisma.UserBadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findMany: {
            args: Prisma.UserBadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          create: {
            args: Prisma.UserBadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          createMany: {
            args: Prisma.UserBadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          delete: {
            args: Prisma.UserBadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          update: {
            args: Prisma.UserBadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          deleteMany: {
            args: Prisma.UserBadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserBadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          aggregate: {
            args: Prisma.UserBadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBadge>
          }
          groupBy: {
            args: Prisma.UserBadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBadgeCountArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdExercises: number
    groupMemberships: number
    ownedGroups: number
    sentInvitations: number
    receivedInvitations: number
    notifications: number
    assignedBy: number
    assignedPrograms: number
    auditLogs: number
    createdPrograms: number
    sessionProgress: number
    badges: number
    exerciseRatings: number
    exerciseHistory: number
    favoriteExercises: number
    workoutSessions: number
    students: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdExercises?: boolean | UserCountOutputTypeCountCreatedExercisesArgs
    groupMemberships?: boolean | UserCountOutputTypeCountGroupMembershipsArgs
    ownedGroups?: boolean | UserCountOutputTypeCountOwnedGroupsArgs
    sentInvitations?: boolean | UserCountOutputTypeCountSentInvitationsArgs
    receivedInvitations?: boolean | UserCountOutputTypeCountReceivedInvitationsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    assignedBy?: boolean | UserCountOutputTypeCountAssignedByArgs
    assignedPrograms?: boolean | UserCountOutputTypeCountAssignedProgramsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    createdPrograms?: boolean | UserCountOutputTypeCountCreatedProgramsArgs
    sessionProgress?: boolean | UserCountOutputTypeCountSessionProgressArgs
    badges?: boolean | UserCountOutputTypeCountBadgesArgs
    exerciseRatings?: boolean | UserCountOutputTypeCountExerciseRatingsArgs
    exerciseHistory?: boolean | UserCountOutputTypeCountExerciseHistoryArgs
    favoriteExercises?: boolean | UserCountOutputTypeCountFavoriteExercisesArgs
    workoutSessions?: boolean | UserCountOutputTypeCountWorkoutSessionsArgs
    students?: boolean | UserCountOutputTypeCountStudentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramAuditWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExerciseRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseRatingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExerciseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoriteExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteExerciseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkoutSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    members: number
    invitations: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | GroupCountOutputTypeCountMembersArgs
    invitations?: boolean | GroupCountOutputTypeCountInvitationsArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }


  /**
   * Count Type ExerciseCountOutputType
   */

  export type ExerciseCountOutputType = {
    sessionExercises: number
    ratings: number
    history: number
    favorites: number
    logs: number
  }

  export type ExerciseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessionExercises?: boolean | ExerciseCountOutputTypeCountSessionExercisesArgs
    ratings?: boolean | ExerciseCountOutputTypeCountRatingsArgs
    history?: boolean | ExerciseCountOutputTypeCountHistoryArgs
    favorites?: boolean | ExerciseCountOutputTypeCountFavoritesArgs
    logs?: boolean | ExerciseCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseCountOutputType
     */
    select?: ExerciseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeCountSessionExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionExerciseWhereInput
  }

  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseRatingWhereInput
  }

  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseHistoryWhereInput
  }

  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteExerciseWhereInput
  }

  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseLogWhereInput
  }


  /**
   * Count Type WorkoutSessionCountOutputType
   */

  export type WorkoutSessionCountOutputType = {
    logs: number
  }

  export type WorkoutSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | WorkoutSessionCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * WorkoutSessionCountOutputType without action
   */
  export type WorkoutSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSessionCountOutputType
     */
    select?: WorkoutSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkoutSessionCountOutputType without action
   */
  export type WorkoutSessionCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseLogWhereInput
  }


  /**
   * Count Type ProgramCountOutputType
   */

  export type ProgramCountOutputType = {
    assignments: number
    auditLogs: number
    blocks: number
  }

  export type ProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | ProgramCountOutputTypeCountAssignmentsArgs
    auditLogs?: boolean | ProgramCountOutputTypeCountAuditLogsArgs
    blocks?: boolean | ProgramCountOutputTypeCountBlocksArgs
  }

  // Custom InputTypes
  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCountOutputType
     */
    select?: ProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramAssignmentWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramAuditWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramBlockWhereInput
  }


  /**
   * Count Type ProgramBlockCountOutputType
   */

  export type ProgramBlockCountOutputType = {
    weeks: number
  }

  export type ProgramBlockCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weeks?: boolean | ProgramBlockCountOutputTypeCountWeeksArgs
  }

  // Custom InputTypes
  /**
   * ProgramBlockCountOutputType without action
   */
  export type ProgramBlockCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBlockCountOutputType
     */
    select?: ProgramBlockCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgramBlockCountOutputType without action
   */
  export type ProgramBlockCountOutputTypeCountWeeksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeekWhereInput
  }


  /**
   * Count Type WeekCountOutputType
   */

  export type WeekCountOutputType = {
    sessions: number
  }

  export type WeekCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | WeekCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * WeekCountOutputType without action
   */
  export type WeekCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekCountOutputType
     */
    select?: WeekCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WeekCountOutputType without action
   */
  export type WeekCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * Count Type SessionCountOutputType
   */

  export type SessionCountOutputType = {
    exercises: number
    progress: number
  }

  export type SessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercises?: boolean | SessionCountOutputTypeCountExercisesArgs
    progress?: boolean | SessionCountOutputTypeCountProgressArgs
  }

  // Custom InputTypes
  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionCountOutputType
     */
    select?: SessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionExerciseWhereInput
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionProgressWhereInput
  }


  /**
   * Count Type SessionExerciseCountOutputType
   */

  export type SessionExerciseCountOutputType = {
    progressInstances: number
  }

  export type SessionExerciseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progressInstances?: boolean | SessionExerciseCountOutputTypeCountProgressInstancesArgs
  }

  // Custom InputTypes
  /**
   * SessionExerciseCountOutputType without action
   */
  export type SessionExerciseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExerciseCountOutputType
     */
    select?: SessionExerciseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessionExerciseCountOutputType without action
   */
  export type SessionExerciseCountOutputTypeCountProgressInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionProgressWhereInput
  }


  /**
   * Count Type BadgeCountOutputType
   */

  export type BadgeCountOutputType = {
    userBadges: number
  }

  export type BadgeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userBadges?: boolean | BadgeCountOutputTypeCountUserBadgesArgs
  }

  // Custom InputTypes
  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeCountOutputType
     */
    select?: BadgeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountUserBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    pseudo: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.Role | null
    profileUrl: string | null
    coachId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    pseudo: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.Role | null
    profileUrl: string | null
    coachId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    pseudo: number
    password: number
    firstName: number
    lastName: number
    role: number
    profileUrl: number
    coachId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    pseudo?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    profileUrl?: true
    coachId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    pseudo?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    profileUrl?: true
    coachId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    pseudo?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    profileUrl?: true
    coachId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    pseudo: string
    password: string
    firstName: string | null
    lastName: string | null
    role: $Enums.Role
    profileUrl: string | null
    coachId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    pseudo?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    profileUrl?: boolean
    coachId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdExercises?: boolean | User$createdExercisesArgs<ExtArgs>
    groupMemberships?: boolean | User$groupMembershipsArgs<ExtArgs>
    ownedGroups?: boolean | User$ownedGroupsArgs<ExtArgs>
    sentInvitations?: boolean | User$sentInvitationsArgs<ExtArgs>
    receivedInvitations?: boolean | User$receivedInvitationsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    assignedBy?: boolean | User$assignedByArgs<ExtArgs>
    assignedPrograms?: boolean | User$assignedProgramsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    createdPrograms?: boolean | User$createdProgramsArgs<ExtArgs>
    sessionProgress?: boolean | User$sessionProgressArgs<ExtArgs>
    badges?: boolean | User$badgesArgs<ExtArgs>
    exerciseRatings?: boolean | User$exerciseRatingsArgs<ExtArgs>
    exerciseHistory?: boolean | User$exerciseHistoryArgs<ExtArgs>
    favoriteExercises?: boolean | User$favoriteExercisesArgs<ExtArgs>
    workoutSessions?: boolean | User$workoutSessionsArgs<ExtArgs>
    coach?: boolean | User$coachArgs<ExtArgs>
    students?: boolean | User$studentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    pseudo?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    profileUrl?: boolean
    coachId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | User$coachArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    pseudo?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    profileUrl?: boolean
    coachId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdExercises?: boolean | User$createdExercisesArgs<ExtArgs>
    groupMemberships?: boolean | User$groupMembershipsArgs<ExtArgs>
    ownedGroups?: boolean | User$ownedGroupsArgs<ExtArgs>
    sentInvitations?: boolean | User$sentInvitationsArgs<ExtArgs>
    receivedInvitations?: boolean | User$receivedInvitationsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    assignedBy?: boolean | User$assignedByArgs<ExtArgs>
    assignedPrograms?: boolean | User$assignedProgramsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    createdPrograms?: boolean | User$createdProgramsArgs<ExtArgs>
    sessionProgress?: boolean | User$sessionProgressArgs<ExtArgs>
    badges?: boolean | User$badgesArgs<ExtArgs>
    exerciseRatings?: boolean | User$exerciseRatingsArgs<ExtArgs>
    exerciseHistory?: boolean | User$exerciseHistoryArgs<ExtArgs>
    favoriteExercises?: boolean | User$favoriteExercisesArgs<ExtArgs>
    workoutSessions?: boolean | User$workoutSessionsArgs<ExtArgs>
    coach?: boolean | User$coachArgs<ExtArgs>
    students?: boolean | User$studentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | User$coachArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      createdExercises: Prisma.$ExercisePayload<ExtArgs>[]
      groupMemberships: Prisma.$GroupMemberPayload<ExtArgs>[]
      ownedGroups: Prisma.$GroupPayload<ExtArgs>[]
      sentInvitations: Prisma.$InvitationPayload<ExtArgs>[]
      receivedInvitations: Prisma.$InvitationPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      assignedBy: Prisma.$ProgramAssignmentPayload<ExtArgs>[]
      assignedPrograms: Prisma.$ProgramAssignmentPayload<ExtArgs>[]
      auditLogs: Prisma.$ProgramAuditPayload<ExtArgs>[]
      createdPrograms: Prisma.$ProgramPayload<ExtArgs>[]
      sessionProgress: Prisma.$SessionProgressPayload<ExtArgs>[]
      badges: Prisma.$UserBadgePayload<ExtArgs>[]
      exerciseRatings: Prisma.$ExerciseRatingPayload<ExtArgs>[]
      exerciseHistory: Prisma.$ExerciseHistoryPayload<ExtArgs>[]
      favoriteExercises: Prisma.$FavoriteExercisePayload<ExtArgs>[]
      workoutSessions: Prisma.$WorkoutSessionPayload<ExtArgs>[]
      coach: Prisma.$UserPayload<ExtArgs> | null
      students: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      pseudo: string
      password: string
      firstName: string | null
      lastName: string | null
      role: $Enums.Role
      profileUrl: string | null
      coachId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdExercises<T extends User$createdExercisesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdExercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany"> | Null>
    groupMemberships<T extends User$groupMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$groupMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany"> | Null>
    ownedGroups<T extends User$ownedGroupsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany"> | Null>
    sentInvitations<T extends User$sentInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany"> | Null>
    receivedInvitations<T extends User$receivedInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    assignedBy<T extends User$assignedByArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    assignedPrograms<T extends User$assignedProgramsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedProgramsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramAuditPayload<ExtArgs>, T, "findMany"> | Null>
    createdPrograms<T extends User$createdProgramsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdProgramsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany"> | Null>
    sessionProgress<T extends User$sessionProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionProgressPayload<ExtArgs>, T, "findMany"> | Null>
    badges<T extends User$badgesArgs<ExtArgs> = {}>(args?: Subset<T, User$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany"> | Null>
    exerciseRatings<T extends User$exerciseRatingsArgs<ExtArgs> = {}>(args?: Subset<T, User$exerciseRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseRatingPayload<ExtArgs>, T, "findMany"> | Null>
    exerciseHistory<T extends User$exerciseHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$exerciseHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    favoriteExercises<T extends User$favoriteExercisesArgs<ExtArgs> = {}>(args?: Subset<T, User$favoriteExercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteExercisePayload<ExtArgs>, T, "findMany"> | Null>
    workoutSessions<T extends User$workoutSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$workoutSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutSessionPayload<ExtArgs>, T, "findMany"> | Null>
    coach<T extends User$coachArgs<ExtArgs> = {}>(args?: Subset<T, User$coachArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    students<T extends User$studentsArgs<ExtArgs> = {}>(args?: Subset<T, User$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly pseudo: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly profileUrl: FieldRef<"User", 'String'>
    readonly coachId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.createdExercises
   */
  export type User$createdExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    cursor?: ExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * User.groupMemberships
   */
  export type User$groupMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    cursor?: GroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * User.ownedGroups
   */
  export type User$ownedGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * User.sentInvitations
   */
  export type User$sentInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * User.receivedInvitations
   */
  export type User$receivedInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.assignedBy
   */
  export type User$assignedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAssignment
     */
    select?: ProgramAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAssignmentInclude<ExtArgs> | null
    where?: ProgramAssignmentWhereInput
    orderBy?: ProgramAssignmentOrderByWithRelationInput | ProgramAssignmentOrderByWithRelationInput[]
    cursor?: ProgramAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramAssignmentScalarFieldEnum | ProgramAssignmentScalarFieldEnum[]
  }

  /**
   * User.assignedPrograms
   */
  export type User$assignedProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAssignment
     */
    select?: ProgramAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAssignmentInclude<ExtArgs> | null
    where?: ProgramAssignmentWhereInput
    orderBy?: ProgramAssignmentOrderByWithRelationInput | ProgramAssignmentOrderByWithRelationInput[]
    cursor?: ProgramAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramAssignmentScalarFieldEnum | ProgramAssignmentScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAudit
     */
    select?: ProgramAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAuditInclude<ExtArgs> | null
    where?: ProgramAuditWhereInput
    orderBy?: ProgramAuditOrderByWithRelationInput | ProgramAuditOrderByWithRelationInput[]
    cursor?: ProgramAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramAuditScalarFieldEnum | ProgramAuditScalarFieldEnum[]
  }

  /**
   * User.createdPrograms
   */
  export type User$createdProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    cursor?: ProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * User.sessionProgress
   */
  export type User$sessionProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionProgress
     */
    select?: SessionProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionProgressInclude<ExtArgs> | null
    where?: SessionProgressWhereInput
    orderBy?: SessionProgressOrderByWithRelationInput | SessionProgressOrderByWithRelationInput[]
    cursor?: SessionProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionProgressScalarFieldEnum | SessionProgressScalarFieldEnum[]
  }

  /**
   * User.badges
   */
  export type User$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    cursor?: UserBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * User.exerciseRatings
   */
  export type User$exerciseRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseRating
     */
    select?: ExerciseRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseRatingInclude<ExtArgs> | null
    where?: ExerciseRatingWhereInput
    orderBy?: ExerciseRatingOrderByWithRelationInput | ExerciseRatingOrderByWithRelationInput[]
    cursor?: ExerciseRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseRatingScalarFieldEnum | ExerciseRatingScalarFieldEnum[]
  }

  /**
   * User.exerciseHistory
   */
  export type User$exerciseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseHistory
     */
    select?: ExerciseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseHistoryInclude<ExtArgs> | null
    where?: ExerciseHistoryWhereInput
    orderBy?: ExerciseHistoryOrderByWithRelationInput | ExerciseHistoryOrderByWithRelationInput[]
    cursor?: ExerciseHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseHistoryScalarFieldEnum | ExerciseHistoryScalarFieldEnum[]
  }

  /**
   * User.favoriteExercises
   */
  export type User$favoriteExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteExercise
     */
    select?: FavoriteExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteExerciseInclude<ExtArgs> | null
    where?: FavoriteExerciseWhereInput
    orderBy?: FavoriteExerciseOrderByWithRelationInput | FavoriteExerciseOrderByWithRelationInput[]
    cursor?: FavoriteExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteExerciseScalarFieldEnum | FavoriteExerciseScalarFieldEnum[]
  }

  /**
   * User.workoutSessions
   */
  export type User$workoutSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSession
     */
    select?: WorkoutSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSessionInclude<ExtArgs> | null
    where?: WorkoutSessionWhereInput
    orderBy?: WorkoutSessionOrderByWithRelationInput | WorkoutSessionOrderByWithRelationInput[]
    cursor?: WorkoutSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkoutSessionScalarFieldEnum | WorkoutSessionScalarFieldEnum[]
  }

  /**
   * User.coach
   */
  export type User$coachArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.students
   */
  export type User$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    ownerId: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupMinAggregateInputType = {
    id?: true
    ownerId?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    ownerId?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    ownerId?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: string
    ownerId: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Group$membersArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    invitations?: boolean | Group$invitationsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectScalar = {
    id?: boolean
    ownerId?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Group$membersArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    invitations?: boolean | Group$invitationsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      members: Prisma.$GroupMemberPayload<ExtArgs>[]
      owner: Prisma.$UserPayload<ExtArgs>
      invitations: Prisma.$InvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupFindUniqueArgs>(args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupFindFirstArgs>(args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupFindManyArgs>(args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends GroupCreateArgs>(args: SelectSubset<T, GroupCreateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Groups.
     * @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupCreateManyArgs>(args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {GroupCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends GroupDeleteArgs>(args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupUpdateArgs>(args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupDeleteManyArgs>(args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupUpdateManyArgs>(args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends GroupUpsertArgs>(args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Group$membersArgs<ExtArgs> = {}>(args?: Subset<T, Group$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany"> | Null>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invitations<T extends Group$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Group$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Group model
   */ 
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'String'>
    readonly ownerId: FieldRef<"Group", 'String'>
    readonly name: FieldRef<"Group", 'String'>
    readonly description: FieldRef<"Group", 'String'>
    readonly createdAt: FieldRef<"Group", 'DateTime'>
    readonly updatedAt: FieldRef<"Group", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }

  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group createManyAndReturn
   */
  export type GroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
  }

  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }

  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
  }

  /**
   * Group.members
   */
  export type Group$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    cursor?: GroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * Group.invitations
   */
  export type Group$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
  }


  /**
   * Model GroupMember
   */

  export type AggregateGroupMember = {
    _count: GroupMemberCountAggregateOutputType | null
    _min: GroupMemberMinAggregateOutputType | null
    _max: GroupMemberMaxAggregateOutputType | null
  }

  export type GroupMemberMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    roleInGroup: string | null
    joinedAt: Date | null
  }

  export type GroupMemberMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    roleInGroup: string | null
    joinedAt: Date | null
  }

  export type GroupMemberCountAggregateOutputType = {
    id: number
    groupId: number
    userId: number
    roleInGroup: number
    joinedAt: number
    _all: number
  }


  export type GroupMemberMinAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    roleInGroup?: true
    joinedAt?: true
  }

  export type GroupMemberMaxAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    roleInGroup?: true
    joinedAt?: true
  }

  export type GroupMemberCountAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    roleInGroup?: true
    joinedAt?: true
    _all?: true
  }

  export type GroupMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMember to aggregate.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupMembers
    **/
    _count?: true | GroupMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMemberMaxAggregateInputType
  }

  export type GetGroupMemberAggregateType<T extends GroupMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupMember[P]>
      : GetScalarType<T[P], AggregateGroupMember[P]>
  }




  export type GroupMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithAggregationInput | GroupMemberOrderByWithAggregationInput[]
    by: GroupMemberScalarFieldEnum[] | GroupMemberScalarFieldEnum
    having?: GroupMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupMemberCountAggregateInputType | true
    _min?: GroupMemberMinAggregateInputType
    _max?: GroupMemberMaxAggregateInputType
  }

  export type GroupMemberGroupByOutputType = {
    id: string
    groupId: string
    userId: string
    roleInGroup: string
    joinedAt: Date
    _count: GroupMemberCountAggregateOutputType | null
    _min: GroupMemberMinAggregateOutputType | null
    _max: GroupMemberMaxAggregateOutputType | null
  }

  type GetGroupMemberGroupByPayload<T extends GroupMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupMemberGroupByOutputType[P]>
            : GetScalarType<T[P], GroupMemberGroupByOutputType[P]>
        }
      >
    >


  export type GroupMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    roleInGroup?: boolean
    joinedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    roleInGroup?: boolean
    joinedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectScalar = {
    id?: boolean
    groupId?: boolean
    userId?: boolean
    roleInGroup?: boolean
    joinedAt?: boolean
  }

  export type GroupMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GroupMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GroupMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupMember"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      userId: string
      roleInGroup: string
      joinedAt: Date
    }, ExtArgs["result"]["groupMember"]>
    composites: {}
  }

  type GroupMemberGetPayload<S extends boolean | null | undefined | GroupMemberDefaultArgs> = $Result.GetResult<Prisma.$GroupMemberPayload, S>

  type GroupMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GroupMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupMemberCountAggregateInputType | true
    }

  export interface GroupMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupMember'], meta: { name: 'GroupMember' } }
    /**
     * Find zero or one GroupMember that matches the filter.
     * @param {GroupMemberFindUniqueArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupMemberFindUniqueArgs>(args: SelectSubset<T, GroupMemberFindUniqueArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GroupMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GroupMemberFindUniqueOrThrowArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GroupMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindFirstArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupMemberFindFirstArgs>(args?: SelectSubset<T, GroupMemberFindFirstArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GroupMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindFirstOrThrowArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GroupMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupMembers
     * const groupMembers = await prisma.groupMember.findMany()
     * 
     * // Get first 10 GroupMembers
     * const groupMembers = await prisma.groupMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupMemberFindManyArgs>(args?: SelectSubset<T, GroupMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GroupMember.
     * @param {GroupMemberCreateArgs} args - Arguments to create a GroupMember.
     * @example
     * // Create one GroupMember
     * const GroupMember = await prisma.groupMember.create({
     *   data: {
     *     // ... data to create a GroupMember
     *   }
     * })
     * 
     */
    create<T extends GroupMemberCreateArgs>(args: SelectSubset<T, GroupMemberCreateArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GroupMembers.
     * @param {GroupMemberCreateManyArgs} args - Arguments to create many GroupMembers.
     * @example
     * // Create many GroupMembers
     * const groupMember = await prisma.groupMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupMemberCreateManyArgs>(args?: SelectSubset<T, GroupMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupMembers and returns the data saved in the database.
     * @param {GroupMemberCreateManyAndReturnArgs} args - Arguments to create many GroupMembers.
     * @example
     * // Create many GroupMembers
     * const groupMember = await prisma.groupMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupMembers and only return the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GroupMember.
     * @param {GroupMemberDeleteArgs} args - Arguments to delete one GroupMember.
     * @example
     * // Delete one GroupMember
     * const GroupMember = await prisma.groupMember.delete({
     *   where: {
     *     // ... filter to delete one GroupMember
     *   }
     * })
     * 
     */
    delete<T extends GroupMemberDeleteArgs>(args: SelectSubset<T, GroupMemberDeleteArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GroupMember.
     * @param {GroupMemberUpdateArgs} args - Arguments to update one GroupMember.
     * @example
     * // Update one GroupMember
     * const groupMember = await prisma.groupMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupMemberUpdateArgs>(args: SelectSubset<T, GroupMemberUpdateArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GroupMembers.
     * @param {GroupMemberDeleteManyArgs} args - Arguments to filter GroupMembers to delete.
     * @example
     * // Delete a few GroupMembers
     * const { count } = await prisma.groupMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupMemberDeleteManyArgs>(args?: SelectSubset<T, GroupMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupMembers
     * const groupMember = await prisma.groupMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupMemberUpdateManyArgs>(args: SelectSubset<T, GroupMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupMember.
     * @param {GroupMemberUpsertArgs} args - Arguments to update or create a GroupMember.
     * @example
     * // Update or create a GroupMember
     * const groupMember = await prisma.groupMember.upsert({
     *   create: {
     *     // ... data to create a GroupMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupMember we want to update
     *   }
     * })
     */
    upsert<T extends GroupMemberUpsertArgs>(args: SelectSubset<T, GroupMemberUpsertArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberCountArgs} args - Arguments to filter GroupMembers to count.
     * @example
     * // Count the number of GroupMembers
     * const count = await prisma.groupMember.count({
     *   where: {
     *     // ... the filter for the GroupMembers we want to count
     *   }
     * })
    **/
    count<T extends GroupMemberCountArgs>(
      args?: Subset<T, GroupMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupMemberAggregateArgs>(args: Subset<T, GroupMemberAggregateArgs>): Prisma.PrismaPromise<GetGroupMemberAggregateType<T>>

    /**
     * Group by GroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupMemberGroupByArgs['orderBy'] }
        : { orderBy?: GroupMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupMember model
   */
  readonly fields: GroupMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupMember model
   */ 
  interface GroupMemberFieldRefs {
    readonly id: FieldRef<"GroupMember", 'String'>
    readonly groupId: FieldRef<"GroupMember", 'String'>
    readonly userId: FieldRef<"GroupMember", 'String'>
    readonly roleInGroup: FieldRef<"GroupMember", 'String'>
    readonly joinedAt: FieldRef<"GroupMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GroupMember findUnique
   */
  export type GroupMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember findUniqueOrThrow
   */
  export type GroupMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember findFirst
   */
  export type GroupMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMembers.
     */
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember findFirstOrThrow
   */
  export type GroupMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMembers.
     */
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember findMany
   */
  export type GroupMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMembers to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember create
   */
  export type GroupMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupMember.
     */
    data: XOR<GroupMemberCreateInput, GroupMemberUncheckedCreateInput>
  }

  /**
   * GroupMember createMany
   */
  export type GroupMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupMembers.
     */
    data: GroupMemberCreateManyInput | GroupMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupMember createManyAndReturn
   */
  export type GroupMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GroupMembers.
     */
    data: GroupMemberCreateManyInput | GroupMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMember update
   */
  export type GroupMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupMember.
     */
    data: XOR<GroupMemberUpdateInput, GroupMemberUncheckedUpdateInput>
    /**
     * Choose, which GroupMember to update.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember updateMany
   */
  export type GroupMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupMembers.
     */
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which GroupMembers to update
     */
    where?: GroupMemberWhereInput
  }

  /**
   * GroupMember upsert
   */
  export type GroupMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupMember to update in case it exists.
     */
    where: GroupMemberWhereUniqueInput
    /**
     * In case the GroupMember found by the `where` argument doesn't exist, create a new GroupMember with this data.
     */
    create: XOR<GroupMemberCreateInput, GroupMemberUncheckedCreateInput>
    /**
     * In case the GroupMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupMemberUpdateInput, GroupMemberUncheckedUpdateInput>
  }

  /**
   * GroupMember delete
   */
  export type GroupMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter which GroupMember to delete.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember deleteMany
   */
  export type GroupMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMembers to delete
     */
    where?: GroupMemberWhereInput
  }

  /**
   * GroupMember without action
   */
  export type GroupMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
  }


  /**
   * Model Invitation
   */

  export type AggregateInvitation = {
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  export type InvitationMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    fromCoachId: string | null
    toUserId: string | null
    status: $Enums.InvitationStatus | null
    createdAt: Date | null
    respondedAt: Date | null
  }

  export type InvitationMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    fromCoachId: string | null
    toUserId: string | null
    status: $Enums.InvitationStatus | null
    createdAt: Date | null
    respondedAt: Date | null
  }

  export type InvitationCountAggregateOutputType = {
    id: number
    groupId: number
    fromCoachId: number
    toUserId: number
    status: number
    createdAt: number
    respondedAt: number
    _all: number
  }


  export type InvitationMinAggregateInputType = {
    id?: true
    groupId?: true
    fromCoachId?: true
    toUserId?: true
    status?: true
    createdAt?: true
    respondedAt?: true
  }

  export type InvitationMaxAggregateInputType = {
    id?: true
    groupId?: true
    fromCoachId?: true
    toUserId?: true
    status?: true
    createdAt?: true
    respondedAt?: true
  }

  export type InvitationCountAggregateInputType = {
    id?: true
    groupId?: true
    fromCoachId?: true
    toUserId?: true
    status?: true
    createdAt?: true
    respondedAt?: true
    _all?: true
  }

  export type InvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitation to aggregate.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invitations
    **/
    _count?: true | InvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationMaxAggregateInputType
  }

  export type GetInvitationAggregateType<T extends InvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitation[P]>
      : GetScalarType<T[P], AggregateInvitation[P]>
  }




  export type InvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithAggregationInput | InvitationOrderByWithAggregationInput[]
    by: InvitationScalarFieldEnum[] | InvitationScalarFieldEnum
    having?: InvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationCountAggregateInputType | true
    _min?: InvitationMinAggregateInputType
    _max?: InvitationMaxAggregateInputType
  }

  export type InvitationGroupByOutputType = {
    id: string
    groupId: string
    fromCoachId: string
    toUserId: string
    status: $Enums.InvitationStatus
    createdAt: Date
    respondedAt: Date | null
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  type GetInvitationGroupByPayload<T extends InvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationGroupByOutputType[P]>
        }
      >
    >


  export type InvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    fromCoachId?: boolean
    toUserId?: boolean
    status?: boolean
    createdAt?: boolean
    respondedAt?: boolean
    fromCoach?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    fromCoachId?: boolean
    toUserId?: boolean
    status?: boolean
    createdAt?: boolean
    respondedAt?: boolean
    fromCoach?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectScalar = {
    id?: boolean
    groupId?: boolean
    fromCoachId?: boolean
    toUserId?: boolean
    status?: boolean
    createdAt?: boolean
    respondedAt?: boolean
  }

  export type InvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromCoach?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromCoach?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invitation"
    objects: {
      fromCoach: Prisma.$UserPayload<ExtArgs>
      group: Prisma.$GroupPayload<ExtArgs>
      toUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      fromCoachId: string
      toUserId: string
      status: $Enums.InvitationStatus
      createdAt: Date
      respondedAt: Date | null
    }, ExtArgs["result"]["invitation"]>
    composites: {}
  }

  type InvitationGetPayload<S extends boolean | null | undefined | InvitationDefaultArgs> = $Result.GetResult<Prisma.$InvitationPayload, S>

  type InvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvitationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvitationCountAggregateInputType | true
    }

  export interface InvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invitation'], meta: { name: 'Invitation' } }
    /**
     * Find zero or one Invitation that matches the filter.
     * @param {InvitationFindUniqueArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationFindUniqueArgs>(args: SelectSubset<T, InvitationFindUniqueArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invitation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvitationFindUniqueOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, InvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationFindFirstArgs>(args?: SelectSubset<T, InvitationFindFirstArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, InvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitation.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationWithIdOnly = await prisma.invitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvitationFindManyArgs>(args?: SelectSubset<T, InvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invitation.
     * @param {InvitationCreateArgs} args - Arguments to create a Invitation.
     * @example
     * // Create one Invitation
     * const Invitation = await prisma.invitation.create({
     *   data: {
     *     // ... data to create a Invitation
     *   }
     * })
     * 
     */
    create<T extends InvitationCreateArgs>(args: SelectSubset<T, InvitationCreateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invitations.
     * @param {InvitationCreateManyArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvitationCreateManyArgs>(args?: SelectSubset<T, InvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invitations and returns the data saved in the database.
     * @param {InvitationCreateManyAndReturnArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, InvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invitation.
     * @param {InvitationDeleteArgs} args - Arguments to delete one Invitation.
     * @example
     * // Delete one Invitation
     * const Invitation = await prisma.invitation.delete({
     *   where: {
     *     // ... filter to delete one Invitation
     *   }
     * })
     * 
     */
    delete<T extends InvitationDeleteArgs>(args: SelectSubset<T, InvitationDeleteArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invitation.
     * @param {InvitationUpdateArgs} args - Arguments to update one Invitation.
     * @example
     * // Update one Invitation
     * const invitation = await prisma.invitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvitationUpdateArgs>(args: SelectSubset<T, InvitationUpdateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invitations.
     * @param {InvitationDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvitationDeleteManyArgs>(args?: SelectSubset<T, InvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvitationUpdateManyArgs>(args: SelectSubset<T, InvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invitation.
     * @param {InvitationUpsertArgs} args - Arguments to update or create a Invitation.
     * @example
     * // Update or create a Invitation
     * const invitation = await prisma.invitation.upsert({
     *   create: {
     *     // ... data to create a Invitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitation we want to update
     *   }
     * })
     */
    upsert<T extends InvitationUpsertArgs>(args: SelectSubset<T, InvitationUpsertArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitation.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends InvitationCountArgs>(
      args?: Subset<T, InvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationAggregateArgs>(args: Subset<T, InvitationAggregateArgs>): Prisma.PrismaPromise<GetInvitationAggregateType<T>>

    /**
     * Group by Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationGroupByArgs['orderBy'] }
        : { orderBy?: InvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invitation model
   */
  readonly fields: InvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromCoach<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    toUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invitation model
   */ 
  interface InvitationFieldRefs {
    readonly id: FieldRef<"Invitation", 'String'>
    readonly groupId: FieldRef<"Invitation", 'String'>
    readonly fromCoachId: FieldRef<"Invitation", 'String'>
    readonly toUserId: FieldRef<"Invitation", 'String'>
    readonly status: FieldRef<"Invitation", 'InvitationStatus'>
    readonly createdAt: FieldRef<"Invitation", 'DateTime'>
    readonly respondedAt: FieldRef<"Invitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invitation findUnique
   */
  export type InvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findUniqueOrThrow
   */
  export type InvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findFirst
   */
  export type InvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findFirstOrThrow
   */
  export type InvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findMany
   */
  export type InvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitations to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation create
   */
  export type InvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a Invitation.
     */
    data: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
  }

  /**
   * Invitation createMany
   */
  export type InvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invitation createManyAndReturn
   */
  export type InvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitation update
   */
  export type InvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a Invitation.
     */
    data: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
    /**
     * Choose, which Invitation to update.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation updateMany
   */
  export type InvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
  }

  /**
   * Invitation upsert
   */
  export type InvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the Invitation to update in case it exists.
     */
    where: InvitationWhereUniqueInput
    /**
     * In case the Invitation found by the `where` argument doesn't exist, create a new Invitation with this data.
     */
    create: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
    /**
     * In case the Invitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
  }

  /**
   * Invitation delete
   */
  export type InvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter which Invitation to delete.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation deleteMany
   */
  export type InvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitations to delete
     */
    where?: InvitationWhereInput
  }

  /**
   * Invitation without action
   */
  export type InvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
  }


  /**
   * Model Exercise
   */

  export type AggregateExercise = {
    _count: ExerciseCountAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  export type ExerciseMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.ExerciseType | null
    scope: $Enums.Scope | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExerciseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.ExerciseType | null
    scope: $Enums.Scope | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExerciseCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    meta: number
    scope: number
    ownerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExerciseMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    scope?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExerciseMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    scope?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExerciseCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    meta?: true
    scope?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercise to aggregate.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exercises
    **/
    _count?: true | ExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseMaxAggregateInputType
  }

  export type GetExerciseAggregateType<T extends ExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExercise[P]>
      : GetScalarType<T[P], AggregateExercise[P]>
  }




  export type ExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithAggregationInput | ExerciseOrderByWithAggregationInput[]
    by: ExerciseScalarFieldEnum[] | ExerciseScalarFieldEnum
    having?: ExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseCountAggregateInputType | true
    _min?: ExerciseMinAggregateInputType
    _max?: ExerciseMaxAggregateInputType
  }

  export type ExerciseGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: $Enums.ExerciseType
    meta: JsonValue | null
    scope: $Enums.Scope
    ownerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ExerciseCountAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  type GetExerciseGroupByPayload<T extends ExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    meta?: boolean
    scope?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | Exercise$ownerArgs<ExtArgs>
    sessionExercises?: boolean | Exercise$sessionExercisesArgs<ExtArgs>
    ratings?: boolean | Exercise$ratingsArgs<ExtArgs>
    history?: boolean | Exercise$historyArgs<ExtArgs>
    favorites?: boolean | Exercise$favoritesArgs<ExtArgs>
    logs?: boolean | Exercise$logsArgs<ExtArgs>
    _count?: boolean | ExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    meta?: boolean
    scope?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | Exercise$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    meta?: boolean
    scope?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | Exercise$ownerArgs<ExtArgs>
    sessionExercises?: boolean | Exercise$sessionExercisesArgs<ExtArgs>
    ratings?: boolean | Exercise$ratingsArgs<ExtArgs>
    history?: boolean | Exercise$historyArgs<ExtArgs>
    favorites?: boolean | Exercise$favoritesArgs<ExtArgs>
    logs?: boolean | Exercise$logsArgs<ExtArgs>
    _count?: boolean | ExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | Exercise$ownerArgs<ExtArgs>
  }

  export type $ExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exercise"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs> | null
      sessionExercises: Prisma.$SessionExercisePayload<ExtArgs>[]
      ratings: Prisma.$ExerciseRatingPayload<ExtArgs>[]
      history: Prisma.$ExerciseHistoryPayload<ExtArgs>[]
      favorites: Prisma.$FavoriteExercisePayload<ExtArgs>[]
      logs: Prisma.$ExerciseLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: $Enums.ExerciseType
      meta: Prisma.JsonValue | null
      scope: $Enums.Scope
      ownerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exercise"]>
    composites: {}
  }

  type ExerciseGetPayload<S extends boolean | null | undefined | ExerciseDefaultArgs> = $Result.GetResult<Prisma.$ExercisePayload, S>

  type ExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExerciseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExerciseCountAggregateInputType | true
    }

  export interface ExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exercise'], meta: { name: 'Exercise' } }
    /**
     * Find zero or one Exercise that matches the filter.
     * @param {ExerciseFindUniqueArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseFindUniqueArgs>(args: SelectSubset<T, ExerciseFindUniqueArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Exercise that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExerciseFindUniqueOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Exercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseFindFirstArgs>(args?: SelectSubset<T, ExerciseFindFirstArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Exercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Exercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exercises
     * const exercises = await prisma.exercise.findMany()
     * 
     * // Get first 10 Exercises
     * const exercises = await prisma.exercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseWithIdOnly = await prisma.exercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseFindManyArgs>(args?: SelectSubset<T, ExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Exercise.
     * @param {ExerciseCreateArgs} args - Arguments to create a Exercise.
     * @example
     * // Create one Exercise
     * const Exercise = await prisma.exercise.create({
     *   data: {
     *     // ... data to create a Exercise
     *   }
     * })
     * 
     */
    create<T extends ExerciseCreateArgs>(args: SelectSubset<T, ExerciseCreateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Exercises.
     * @param {ExerciseCreateManyArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseCreateManyArgs>(args?: SelectSubset<T, ExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exercises and returns the data saved in the database.
     * @param {ExerciseCreateManyAndReturnArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exercises and only return the `id`
     * const exerciseWithIdOnly = await prisma.exercise.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Exercise.
     * @param {ExerciseDeleteArgs} args - Arguments to delete one Exercise.
     * @example
     * // Delete one Exercise
     * const Exercise = await prisma.exercise.delete({
     *   where: {
     *     // ... filter to delete one Exercise
     *   }
     * })
     * 
     */
    delete<T extends ExerciseDeleteArgs>(args: SelectSubset<T, ExerciseDeleteArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Exercise.
     * @param {ExerciseUpdateArgs} args - Arguments to update one Exercise.
     * @example
     * // Update one Exercise
     * const exercise = await prisma.exercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseUpdateArgs>(args: SelectSubset<T, ExerciseUpdateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Exercises.
     * @param {ExerciseDeleteManyArgs} args - Arguments to filter Exercises to delete.
     * @example
     * // Delete a few Exercises
     * const { count } = await prisma.exercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseDeleteManyArgs>(args?: SelectSubset<T, ExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseUpdateManyArgs>(args: SelectSubset<T, ExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exercise.
     * @param {ExerciseUpsertArgs} args - Arguments to update or create a Exercise.
     * @example
     * // Update or create a Exercise
     * const exercise = await prisma.exercise.upsert({
     *   create: {
     *     // ... data to create a Exercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exercise we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseUpsertArgs>(args: SelectSubset<T, ExerciseUpsertArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseCountArgs} args - Arguments to filter Exercises to count.
     * @example
     * // Count the number of Exercises
     * const count = await prisma.exercise.count({
     *   where: {
     *     // ... the filter for the Exercises we want to count
     *   }
     * })
    **/
    count<T extends ExerciseCountArgs>(
      args?: Subset<T, ExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseAggregateArgs>(args: Subset<T, ExerciseAggregateArgs>): Prisma.PrismaPromise<GetExerciseAggregateType<T>>

    /**
     * Group by Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exercise model
   */
  readonly fields: ExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends Exercise$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sessionExercises<T extends Exercise$sessionExercisesArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$sessionExercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionExercisePayload<ExtArgs>, T, "findMany"> | Null>
    ratings<T extends Exercise$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseRatingPayload<ExtArgs>, T, "findMany"> | Null>
    history<T extends Exercise$historyArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    favorites<T extends Exercise$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteExercisePayload<ExtArgs>, T, "findMany"> | Null>
    logs<T extends Exercise$logsArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exercise model
   */ 
  interface ExerciseFieldRefs {
    readonly id: FieldRef<"Exercise", 'String'>
    readonly name: FieldRef<"Exercise", 'String'>
    readonly description: FieldRef<"Exercise", 'String'>
    readonly type: FieldRef<"Exercise", 'ExerciseType'>
    readonly meta: FieldRef<"Exercise", 'Json'>
    readonly scope: FieldRef<"Exercise", 'Scope'>
    readonly ownerId: FieldRef<"Exercise", 'String'>
    readonly createdAt: FieldRef<"Exercise", 'DateTime'>
    readonly updatedAt: FieldRef<"Exercise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Exercise findUnique
   */
  export type ExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findUniqueOrThrow
   */
  export type ExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findFirst
   */
  export type ExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findFirstOrThrow
   */
  export type ExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findMany
   */
  export type ExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercises to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise create
   */
  export type ExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a Exercise.
     */
    data: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
  }

  /**
   * Exercise createMany
   */
  export type ExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exercise createManyAndReturn
   */
  export type ExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exercise update
   */
  export type ExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a Exercise.
     */
    data: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
    /**
     * Choose, which Exercise to update.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise updateMany
   */
  export type ExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exercises.
     */
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    /**
     * Filter which Exercises to update
     */
    where?: ExerciseWhereInput
  }

  /**
   * Exercise upsert
   */
  export type ExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the Exercise to update in case it exists.
     */
    where: ExerciseWhereUniqueInput
    /**
     * In case the Exercise found by the `where` argument doesn't exist, create a new Exercise with this data.
     */
    create: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
    /**
     * In case the Exercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
  }

  /**
   * Exercise delete
   */
  export type ExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter which Exercise to delete.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise deleteMany
   */
  export type ExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercises to delete
     */
    where?: ExerciseWhereInput
  }

  /**
   * Exercise.owner
   */
  export type Exercise$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Exercise.sessionExercises
   */
  export type Exercise$sessionExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExercise
     */
    select?: SessionExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExerciseInclude<ExtArgs> | null
    where?: SessionExerciseWhereInput
    orderBy?: SessionExerciseOrderByWithRelationInput | SessionExerciseOrderByWithRelationInput[]
    cursor?: SessionExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionExerciseScalarFieldEnum | SessionExerciseScalarFieldEnum[]
  }

  /**
   * Exercise.ratings
   */
  export type Exercise$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseRating
     */
    select?: ExerciseRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseRatingInclude<ExtArgs> | null
    where?: ExerciseRatingWhereInput
    orderBy?: ExerciseRatingOrderByWithRelationInput | ExerciseRatingOrderByWithRelationInput[]
    cursor?: ExerciseRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseRatingScalarFieldEnum | ExerciseRatingScalarFieldEnum[]
  }

  /**
   * Exercise.history
   */
  export type Exercise$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseHistory
     */
    select?: ExerciseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseHistoryInclude<ExtArgs> | null
    where?: ExerciseHistoryWhereInput
    orderBy?: ExerciseHistoryOrderByWithRelationInput | ExerciseHistoryOrderByWithRelationInput[]
    cursor?: ExerciseHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseHistoryScalarFieldEnum | ExerciseHistoryScalarFieldEnum[]
  }

  /**
   * Exercise.favorites
   */
  export type Exercise$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteExercise
     */
    select?: FavoriteExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteExerciseInclude<ExtArgs> | null
    where?: FavoriteExerciseWhereInput
    orderBy?: FavoriteExerciseOrderByWithRelationInput | FavoriteExerciseOrderByWithRelationInput[]
    cursor?: FavoriteExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteExerciseScalarFieldEnum | FavoriteExerciseScalarFieldEnum[]
  }

  /**
   * Exercise.logs
   */
  export type Exercise$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    where?: ExerciseLogWhereInput
    orderBy?: ExerciseLogOrderByWithRelationInput | ExerciseLogOrderByWithRelationInput[]
    cursor?: ExerciseLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseLogScalarFieldEnum | ExerciseLogScalarFieldEnum[]
  }

  /**
   * Exercise without action
   */
  export type ExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
  }


  /**
   * Model ExerciseRating
   */

  export type AggregateExerciseRating = {
    _count: ExerciseRatingCountAggregateOutputType | null
    _avg: ExerciseRatingAvgAggregateOutputType | null
    _sum: ExerciseRatingSumAggregateOutputType | null
    _min: ExerciseRatingMinAggregateOutputType | null
    _max: ExerciseRatingMaxAggregateOutputType | null
  }

  export type ExerciseRatingAvgAggregateOutputType = {
    rating: number | null
  }

  export type ExerciseRatingSumAggregateOutputType = {
    rating: number | null
  }

  export type ExerciseRatingMinAggregateOutputType = {
    id: string | null
    exerciseId: string | null
    userId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExerciseRatingMaxAggregateOutputType = {
    id: string | null
    exerciseId: string | null
    userId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExerciseRatingCountAggregateOutputType = {
    id: number
    exerciseId: number
    userId: number
    rating: number
    comment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExerciseRatingAvgAggregateInputType = {
    rating?: true
  }

  export type ExerciseRatingSumAggregateInputType = {
    rating?: true
  }

  export type ExerciseRatingMinAggregateInputType = {
    id?: true
    exerciseId?: true
    userId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExerciseRatingMaxAggregateInputType = {
    id?: true
    exerciseId?: true
    userId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExerciseRatingCountAggregateInputType = {
    id?: true
    exerciseId?: true
    userId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExerciseRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciseRating to aggregate.
     */
    where?: ExerciseRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseRatings to fetch.
     */
    orderBy?: ExerciseRatingOrderByWithRelationInput | ExerciseRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExerciseRatings
    **/
    _count?: true | ExerciseRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseRatingMaxAggregateInputType
  }

  export type GetExerciseRatingAggregateType<T extends ExerciseRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateExerciseRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExerciseRating[P]>
      : GetScalarType<T[P], AggregateExerciseRating[P]>
  }




  export type ExerciseRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseRatingWhereInput
    orderBy?: ExerciseRatingOrderByWithAggregationInput | ExerciseRatingOrderByWithAggregationInput[]
    by: ExerciseRatingScalarFieldEnum[] | ExerciseRatingScalarFieldEnum
    having?: ExerciseRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseRatingCountAggregateInputType | true
    _avg?: ExerciseRatingAvgAggregateInputType
    _sum?: ExerciseRatingSumAggregateInputType
    _min?: ExerciseRatingMinAggregateInputType
    _max?: ExerciseRatingMaxAggregateInputType
  }

  export type ExerciseRatingGroupByOutputType = {
    id: string
    exerciseId: string
    userId: string
    rating: number
    comment: string | null
    createdAt: Date
    updatedAt: Date
    _count: ExerciseRatingCountAggregateOutputType | null
    _avg: ExerciseRatingAvgAggregateOutputType | null
    _sum: ExerciseRatingSumAggregateOutputType | null
    _min: ExerciseRatingMinAggregateOutputType | null
    _max: ExerciseRatingMaxAggregateOutputType | null
  }

  type GetExerciseRatingGroupByPayload<T extends ExerciseRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseRatingGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseRatingGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciseId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseRating"]>

  export type ExerciseRatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciseId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseRating"]>

  export type ExerciseRatingSelectScalar = {
    id?: boolean
    exerciseId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExerciseRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExerciseRatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExerciseRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExerciseRating"
    objects: {
      exercise: Prisma.$ExercisePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      exerciseId: string
      userId: string
      rating: number
      comment: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exerciseRating"]>
    composites: {}
  }

  type ExerciseRatingGetPayload<S extends boolean | null | undefined | ExerciseRatingDefaultArgs> = $Result.GetResult<Prisma.$ExerciseRatingPayload, S>

  type ExerciseRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExerciseRatingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExerciseRatingCountAggregateInputType | true
    }

  export interface ExerciseRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExerciseRating'], meta: { name: 'ExerciseRating' } }
    /**
     * Find zero or one ExerciseRating that matches the filter.
     * @param {ExerciseRatingFindUniqueArgs} args - Arguments to find a ExerciseRating
     * @example
     * // Get one ExerciseRating
     * const exerciseRating = await prisma.exerciseRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseRatingFindUniqueArgs>(args: SelectSubset<T, ExerciseRatingFindUniqueArgs<ExtArgs>>): Prisma__ExerciseRatingClient<$Result.GetResult<Prisma.$ExerciseRatingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExerciseRating that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExerciseRatingFindUniqueOrThrowArgs} args - Arguments to find a ExerciseRating
     * @example
     * // Get one ExerciseRating
     * const exerciseRating = await prisma.exerciseRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseRatingClient<$Result.GetResult<Prisma.$ExerciseRatingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExerciseRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseRatingFindFirstArgs} args - Arguments to find a ExerciseRating
     * @example
     * // Get one ExerciseRating
     * const exerciseRating = await prisma.exerciseRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseRatingFindFirstArgs>(args?: SelectSubset<T, ExerciseRatingFindFirstArgs<ExtArgs>>): Prisma__ExerciseRatingClient<$Result.GetResult<Prisma.$ExerciseRatingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExerciseRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseRatingFindFirstOrThrowArgs} args - Arguments to find a ExerciseRating
     * @example
     * // Get one ExerciseRating
     * const exerciseRating = await prisma.exerciseRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseRatingClient<$Result.GetResult<Prisma.$ExerciseRatingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExerciseRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExerciseRatings
     * const exerciseRatings = await prisma.exerciseRating.findMany()
     * 
     * // Get first 10 ExerciseRatings
     * const exerciseRatings = await prisma.exerciseRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseRatingWithIdOnly = await prisma.exerciseRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseRatingFindManyArgs>(args?: SelectSubset<T, ExerciseRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseRatingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExerciseRating.
     * @param {ExerciseRatingCreateArgs} args - Arguments to create a ExerciseRating.
     * @example
     * // Create one ExerciseRating
     * const ExerciseRating = await prisma.exerciseRating.create({
     *   data: {
     *     // ... data to create a ExerciseRating
     *   }
     * })
     * 
     */
    create<T extends ExerciseRatingCreateArgs>(args: SelectSubset<T, ExerciseRatingCreateArgs<ExtArgs>>): Prisma__ExerciseRatingClient<$Result.GetResult<Prisma.$ExerciseRatingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExerciseRatings.
     * @param {ExerciseRatingCreateManyArgs} args - Arguments to create many ExerciseRatings.
     * @example
     * // Create many ExerciseRatings
     * const exerciseRating = await prisma.exerciseRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseRatingCreateManyArgs>(args?: SelectSubset<T, ExerciseRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExerciseRatings and returns the data saved in the database.
     * @param {ExerciseRatingCreateManyAndReturnArgs} args - Arguments to create many ExerciseRatings.
     * @example
     * // Create many ExerciseRatings
     * const exerciseRating = await prisma.exerciseRating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExerciseRatings and only return the `id`
     * const exerciseRatingWithIdOnly = await prisma.exerciseRating.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseRatingCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseRatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseRatingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExerciseRating.
     * @param {ExerciseRatingDeleteArgs} args - Arguments to delete one ExerciseRating.
     * @example
     * // Delete one ExerciseRating
     * const ExerciseRating = await prisma.exerciseRating.delete({
     *   where: {
     *     // ... filter to delete one ExerciseRating
     *   }
     * })
     * 
     */
    delete<T extends ExerciseRatingDeleteArgs>(args: SelectSubset<T, ExerciseRatingDeleteArgs<ExtArgs>>): Prisma__ExerciseRatingClient<$Result.GetResult<Prisma.$ExerciseRatingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExerciseRating.
     * @param {ExerciseRatingUpdateArgs} args - Arguments to update one ExerciseRating.
     * @example
     * // Update one ExerciseRating
     * const exerciseRating = await prisma.exerciseRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseRatingUpdateArgs>(args: SelectSubset<T, ExerciseRatingUpdateArgs<ExtArgs>>): Prisma__ExerciseRatingClient<$Result.GetResult<Prisma.$ExerciseRatingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExerciseRatings.
     * @param {ExerciseRatingDeleteManyArgs} args - Arguments to filter ExerciseRatings to delete.
     * @example
     * // Delete a few ExerciseRatings
     * const { count } = await prisma.exerciseRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseRatingDeleteManyArgs>(args?: SelectSubset<T, ExerciseRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExerciseRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExerciseRatings
     * const exerciseRating = await prisma.exerciseRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseRatingUpdateManyArgs>(args: SelectSubset<T, ExerciseRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExerciseRating.
     * @param {ExerciseRatingUpsertArgs} args - Arguments to update or create a ExerciseRating.
     * @example
     * // Update or create a ExerciseRating
     * const exerciseRating = await prisma.exerciseRating.upsert({
     *   create: {
     *     // ... data to create a ExerciseRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExerciseRating we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseRatingUpsertArgs>(args: SelectSubset<T, ExerciseRatingUpsertArgs<ExtArgs>>): Prisma__ExerciseRatingClient<$Result.GetResult<Prisma.$ExerciseRatingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExerciseRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseRatingCountArgs} args - Arguments to filter ExerciseRatings to count.
     * @example
     * // Count the number of ExerciseRatings
     * const count = await prisma.exerciseRating.count({
     *   where: {
     *     // ... the filter for the ExerciseRatings we want to count
     *   }
     * })
    **/
    count<T extends ExerciseRatingCountArgs>(
      args?: Subset<T, ExerciseRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExerciseRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseRatingAggregateArgs>(args: Subset<T, ExerciseRatingAggregateArgs>): Prisma.PrismaPromise<GetExerciseRatingAggregateType<T>>

    /**
     * Group by ExerciseRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseRatingGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExerciseRating model
   */
  readonly fields: ExerciseRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExerciseRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exercise<T extends ExerciseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseDefaultArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExerciseRating model
   */ 
  interface ExerciseRatingFieldRefs {
    readonly id: FieldRef<"ExerciseRating", 'String'>
    readonly exerciseId: FieldRef<"ExerciseRating", 'String'>
    readonly userId: FieldRef<"ExerciseRating", 'String'>
    readonly rating: FieldRef<"ExerciseRating", 'Int'>
    readonly comment: FieldRef<"ExerciseRating", 'String'>
    readonly createdAt: FieldRef<"ExerciseRating", 'DateTime'>
    readonly updatedAt: FieldRef<"ExerciseRating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExerciseRating findUnique
   */
  export type ExerciseRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseRating
     */
    select?: ExerciseRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseRatingInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseRating to fetch.
     */
    where: ExerciseRatingWhereUniqueInput
  }

  /**
   * ExerciseRating findUniqueOrThrow
   */
  export type ExerciseRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseRating
     */
    select?: ExerciseRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseRatingInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseRating to fetch.
     */
    where: ExerciseRatingWhereUniqueInput
  }

  /**
   * ExerciseRating findFirst
   */
  export type ExerciseRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseRating
     */
    select?: ExerciseRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseRatingInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseRating to fetch.
     */
    where?: ExerciseRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseRatings to fetch.
     */
    orderBy?: ExerciseRatingOrderByWithRelationInput | ExerciseRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseRatings.
     */
    cursor?: ExerciseRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseRatings.
     */
    distinct?: ExerciseRatingScalarFieldEnum | ExerciseRatingScalarFieldEnum[]
  }

  /**
   * ExerciseRating findFirstOrThrow
   */
  export type ExerciseRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseRating
     */
    select?: ExerciseRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseRatingInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseRating to fetch.
     */
    where?: ExerciseRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseRatings to fetch.
     */
    orderBy?: ExerciseRatingOrderByWithRelationInput | ExerciseRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseRatings.
     */
    cursor?: ExerciseRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseRatings.
     */
    distinct?: ExerciseRatingScalarFieldEnum | ExerciseRatingScalarFieldEnum[]
  }

  /**
   * ExerciseRating findMany
   */
  export type ExerciseRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseRating
     */
    select?: ExerciseRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseRatingInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseRatings to fetch.
     */
    where?: ExerciseRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseRatings to fetch.
     */
    orderBy?: ExerciseRatingOrderByWithRelationInput | ExerciseRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExerciseRatings.
     */
    cursor?: ExerciseRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseRatings.
     */
    skip?: number
    distinct?: ExerciseRatingScalarFieldEnum | ExerciseRatingScalarFieldEnum[]
  }

  /**
   * ExerciseRating create
   */
  export type ExerciseRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseRating
     */
    select?: ExerciseRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a ExerciseRating.
     */
    data: XOR<ExerciseRatingCreateInput, ExerciseRatingUncheckedCreateInput>
  }

  /**
   * ExerciseRating createMany
   */
  export type ExerciseRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExerciseRatings.
     */
    data: ExerciseRatingCreateManyInput | ExerciseRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExerciseRating createManyAndReturn
   */
  export type ExerciseRatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseRating
     */
    select?: ExerciseRatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExerciseRatings.
     */
    data: ExerciseRatingCreateManyInput | ExerciseRatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseRatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExerciseRating update
   */
  export type ExerciseRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseRating
     */
    select?: ExerciseRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a ExerciseRating.
     */
    data: XOR<ExerciseRatingUpdateInput, ExerciseRatingUncheckedUpdateInput>
    /**
     * Choose, which ExerciseRating to update.
     */
    where: ExerciseRatingWhereUniqueInput
  }

  /**
   * ExerciseRating updateMany
   */
  export type ExerciseRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExerciseRatings.
     */
    data: XOR<ExerciseRatingUpdateManyMutationInput, ExerciseRatingUncheckedUpdateManyInput>
    /**
     * Filter which ExerciseRatings to update
     */
    where?: ExerciseRatingWhereInput
  }

  /**
   * ExerciseRating upsert
   */
  export type ExerciseRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseRating
     */
    select?: ExerciseRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the ExerciseRating to update in case it exists.
     */
    where: ExerciseRatingWhereUniqueInput
    /**
     * In case the ExerciseRating found by the `where` argument doesn't exist, create a new ExerciseRating with this data.
     */
    create: XOR<ExerciseRatingCreateInput, ExerciseRatingUncheckedCreateInput>
    /**
     * In case the ExerciseRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseRatingUpdateInput, ExerciseRatingUncheckedUpdateInput>
  }

  /**
   * ExerciseRating delete
   */
  export type ExerciseRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseRating
     */
    select?: ExerciseRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseRatingInclude<ExtArgs> | null
    /**
     * Filter which ExerciseRating to delete.
     */
    where: ExerciseRatingWhereUniqueInput
  }

  /**
   * ExerciseRating deleteMany
   */
  export type ExerciseRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciseRatings to delete
     */
    where?: ExerciseRatingWhereInput
  }

  /**
   * ExerciseRating without action
   */
  export type ExerciseRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseRating
     */
    select?: ExerciseRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseRatingInclude<ExtArgs> | null
  }


  /**
   * Model ExerciseHistory
   */

  export type AggregateExerciseHistory = {
    _count: ExerciseHistoryCountAggregateOutputType | null
    _min: ExerciseHistoryMinAggregateOutputType | null
    _max: ExerciseHistoryMaxAggregateOutputType | null
  }

  export type ExerciseHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    exerciseId: string | null
    viewedAt: Date | null
  }

  export type ExerciseHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    exerciseId: string | null
    viewedAt: Date | null
  }

  export type ExerciseHistoryCountAggregateOutputType = {
    id: number
    userId: number
    exerciseId: number
    viewedAt: number
    _all: number
  }


  export type ExerciseHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    exerciseId?: true
    viewedAt?: true
  }

  export type ExerciseHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    exerciseId?: true
    viewedAt?: true
  }

  export type ExerciseHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    exerciseId?: true
    viewedAt?: true
    _all?: true
  }

  export type ExerciseHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciseHistory to aggregate.
     */
    where?: ExerciseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseHistories to fetch.
     */
    orderBy?: ExerciseHistoryOrderByWithRelationInput | ExerciseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExerciseHistories
    **/
    _count?: true | ExerciseHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseHistoryMaxAggregateInputType
  }

  export type GetExerciseHistoryAggregateType<T extends ExerciseHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateExerciseHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExerciseHistory[P]>
      : GetScalarType<T[P], AggregateExerciseHistory[P]>
  }




  export type ExerciseHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseHistoryWhereInput
    orderBy?: ExerciseHistoryOrderByWithAggregationInput | ExerciseHistoryOrderByWithAggregationInput[]
    by: ExerciseHistoryScalarFieldEnum[] | ExerciseHistoryScalarFieldEnum
    having?: ExerciseHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseHistoryCountAggregateInputType | true
    _min?: ExerciseHistoryMinAggregateInputType
    _max?: ExerciseHistoryMaxAggregateInputType
  }

  export type ExerciseHistoryGroupByOutputType = {
    id: string
    userId: string
    exerciseId: string
    viewedAt: Date
    _count: ExerciseHistoryCountAggregateOutputType | null
    _min: ExerciseHistoryMinAggregateOutputType | null
    _max: ExerciseHistoryMaxAggregateOutputType | null
  }

  type GetExerciseHistoryGroupByPayload<T extends ExerciseHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    exerciseId?: boolean
    viewedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseHistory"]>

  export type ExerciseHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    exerciseId?: boolean
    viewedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseHistory"]>

  export type ExerciseHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    exerciseId?: boolean
    viewedAt?: boolean
  }

  export type ExerciseHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }
  export type ExerciseHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }

  export type $ExerciseHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExerciseHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      exercise: Prisma.$ExercisePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      exerciseId: string
      viewedAt: Date
    }, ExtArgs["result"]["exerciseHistory"]>
    composites: {}
  }

  type ExerciseHistoryGetPayload<S extends boolean | null | undefined | ExerciseHistoryDefaultArgs> = $Result.GetResult<Prisma.$ExerciseHistoryPayload, S>

  type ExerciseHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExerciseHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExerciseHistoryCountAggregateInputType | true
    }

  export interface ExerciseHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExerciseHistory'], meta: { name: 'ExerciseHistory' } }
    /**
     * Find zero or one ExerciseHistory that matches the filter.
     * @param {ExerciseHistoryFindUniqueArgs} args - Arguments to find a ExerciseHistory
     * @example
     * // Get one ExerciseHistory
     * const exerciseHistory = await prisma.exerciseHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseHistoryFindUniqueArgs>(args: SelectSubset<T, ExerciseHistoryFindUniqueArgs<ExtArgs>>): Prisma__ExerciseHistoryClient<$Result.GetResult<Prisma.$ExerciseHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExerciseHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExerciseHistoryFindUniqueOrThrowArgs} args - Arguments to find a ExerciseHistory
     * @example
     * // Get one ExerciseHistory
     * const exerciseHistory = await prisma.exerciseHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseHistoryClient<$Result.GetResult<Prisma.$ExerciseHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExerciseHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseHistoryFindFirstArgs} args - Arguments to find a ExerciseHistory
     * @example
     * // Get one ExerciseHistory
     * const exerciseHistory = await prisma.exerciseHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseHistoryFindFirstArgs>(args?: SelectSubset<T, ExerciseHistoryFindFirstArgs<ExtArgs>>): Prisma__ExerciseHistoryClient<$Result.GetResult<Prisma.$ExerciseHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExerciseHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseHistoryFindFirstOrThrowArgs} args - Arguments to find a ExerciseHistory
     * @example
     * // Get one ExerciseHistory
     * const exerciseHistory = await prisma.exerciseHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseHistoryClient<$Result.GetResult<Prisma.$ExerciseHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExerciseHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExerciseHistories
     * const exerciseHistories = await prisma.exerciseHistory.findMany()
     * 
     * // Get first 10 ExerciseHistories
     * const exerciseHistories = await prisma.exerciseHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseHistoryWithIdOnly = await prisma.exerciseHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseHistoryFindManyArgs>(args?: SelectSubset<T, ExerciseHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExerciseHistory.
     * @param {ExerciseHistoryCreateArgs} args - Arguments to create a ExerciseHistory.
     * @example
     * // Create one ExerciseHistory
     * const ExerciseHistory = await prisma.exerciseHistory.create({
     *   data: {
     *     // ... data to create a ExerciseHistory
     *   }
     * })
     * 
     */
    create<T extends ExerciseHistoryCreateArgs>(args: SelectSubset<T, ExerciseHistoryCreateArgs<ExtArgs>>): Prisma__ExerciseHistoryClient<$Result.GetResult<Prisma.$ExerciseHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExerciseHistories.
     * @param {ExerciseHistoryCreateManyArgs} args - Arguments to create many ExerciseHistories.
     * @example
     * // Create many ExerciseHistories
     * const exerciseHistory = await prisma.exerciseHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseHistoryCreateManyArgs>(args?: SelectSubset<T, ExerciseHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExerciseHistories and returns the data saved in the database.
     * @param {ExerciseHistoryCreateManyAndReturnArgs} args - Arguments to create many ExerciseHistories.
     * @example
     * // Create many ExerciseHistories
     * const exerciseHistory = await prisma.exerciseHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExerciseHistories and only return the `id`
     * const exerciseHistoryWithIdOnly = await prisma.exerciseHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExerciseHistory.
     * @param {ExerciseHistoryDeleteArgs} args - Arguments to delete one ExerciseHistory.
     * @example
     * // Delete one ExerciseHistory
     * const ExerciseHistory = await prisma.exerciseHistory.delete({
     *   where: {
     *     // ... filter to delete one ExerciseHistory
     *   }
     * })
     * 
     */
    delete<T extends ExerciseHistoryDeleteArgs>(args: SelectSubset<T, ExerciseHistoryDeleteArgs<ExtArgs>>): Prisma__ExerciseHistoryClient<$Result.GetResult<Prisma.$ExerciseHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExerciseHistory.
     * @param {ExerciseHistoryUpdateArgs} args - Arguments to update one ExerciseHistory.
     * @example
     * // Update one ExerciseHistory
     * const exerciseHistory = await prisma.exerciseHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseHistoryUpdateArgs>(args: SelectSubset<T, ExerciseHistoryUpdateArgs<ExtArgs>>): Prisma__ExerciseHistoryClient<$Result.GetResult<Prisma.$ExerciseHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExerciseHistories.
     * @param {ExerciseHistoryDeleteManyArgs} args - Arguments to filter ExerciseHistories to delete.
     * @example
     * // Delete a few ExerciseHistories
     * const { count } = await prisma.exerciseHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseHistoryDeleteManyArgs>(args?: SelectSubset<T, ExerciseHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExerciseHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExerciseHistories
     * const exerciseHistory = await prisma.exerciseHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseHistoryUpdateManyArgs>(args: SelectSubset<T, ExerciseHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExerciseHistory.
     * @param {ExerciseHistoryUpsertArgs} args - Arguments to update or create a ExerciseHistory.
     * @example
     * // Update or create a ExerciseHistory
     * const exerciseHistory = await prisma.exerciseHistory.upsert({
     *   create: {
     *     // ... data to create a ExerciseHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExerciseHistory we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseHistoryUpsertArgs>(args: SelectSubset<T, ExerciseHistoryUpsertArgs<ExtArgs>>): Prisma__ExerciseHistoryClient<$Result.GetResult<Prisma.$ExerciseHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExerciseHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseHistoryCountArgs} args - Arguments to filter ExerciseHistories to count.
     * @example
     * // Count the number of ExerciseHistories
     * const count = await prisma.exerciseHistory.count({
     *   where: {
     *     // ... the filter for the ExerciseHistories we want to count
     *   }
     * })
    **/
    count<T extends ExerciseHistoryCountArgs>(
      args?: Subset<T, ExerciseHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExerciseHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseHistoryAggregateArgs>(args: Subset<T, ExerciseHistoryAggregateArgs>): Prisma.PrismaPromise<GetExerciseHistoryAggregateType<T>>

    /**
     * Group by ExerciseHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExerciseHistory model
   */
  readonly fields: ExerciseHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExerciseHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    exercise<T extends ExerciseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseDefaultArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExerciseHistory model
   */ 
  interface ExerciseHistoryFieldRefs {
    readonly id: FieldRef<"ExerciseHistory", 'String'>
    readonly userId: FieldRef<"ExerciseHistory", 'String'>
    readonly exerciseId: FieldRef<"ExerciseHistory", 'String'>
    readonly viewedAt: FieldRef<"ExerciseHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExerciseHistory findUnique
   */
  export type ExerciseHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseHistory
     */
    select?: ExerciseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseHistory to fetch.
     */
    where: ExerciseHistoryWhereUniqueInput
  }

  /**
   * ExerciseHistory findUniqueOrThrow
   */
  export type ExerciseHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseHistory
     */
    select?: ExerciseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseHistory to fetch.
     */
    where: ExerciseHistoryWhereUniqueInput
  }

  /**
   * ExerciseHistory findFirst
   */
  export type ExerciseHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseHistory
     */
    select?: ExerciseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseHistory to fetch.
     */
    where?: ExerciseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseHistories to fetch.
     */
    orderBy?: ExerciseHistoryOrderByWithRelationInput | ExerciseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseHistories.
     */
    cursor?: ExerciseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseHistories.
     */
    distinct?: ExerciseHistoryScalarFieldEnum | ExerciseHistoryScalarFieldEnum[]
  }

  /**
   * ExerciseHistory findFirstOrThrow
   */
  export type ExerciseHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseHistory
     */
    select?: ExerciseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseHistory to fetch.
     */
    where?: ExerciseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseHistories to fetch.
     */
    orderBy?: ExerciseHistoryOrderByWithRelationInput | ExerciseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseHistories.
     */
    cursor?: ExerciseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseHistories.
     */
    distinct?: ExerciseHistoryScalarFieldEnum | ExerciseHistoryScalarFieldEnum[]
  }

  /**
   * ExerciseHistory findMany
   */
  export type ExerciseHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseHistory
     */
    select?: ExerciseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseHistories to fetch.
     */
    where?: ExerciseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseHistories to fetch.
     */
    orderBy?: ExerciseHistoryOrderByWithRelationInput | ExerciseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExerciseHistories.
     */
    cursor?: ExerciseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseHistories.
     */
    skip?: number
    distinct?: ExerciseHistoryScalarFieldEnum | ExerciseHistoryScalarFieldEnum[]
  }

  /**
   * ExerciseHistory create
   */
  export type ExerciseHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseHistory
     */
    select?: ExerciseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ExerciseHistory.
     */
    data: XOR<ExerciseHistoryCreateInput, ExerciseHistoryUncheckedCreateInput>
  }

  /**
   * ExerciseHistory createMany
   */
  export type ExerciseHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExerciseHistories.
     */
    data: ExerciseHistoryCreateManyInput | ExerciseHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExerciseHistory createManyAndReturn
   */
  export type ExerciseHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseHistory
     */
    select?: ExerciseHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExerciseHistories.
     */
    data: ExerciseHistoryCreateManyInput | ExerciseHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExerciseHistory update
   */
  export type ExerciseHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseHistory
     */
    select?: ExerciseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ExerciseHistory.
     */
    data: XOR<ExerciseHistoryUpdateInput, ExerciseHistoryUncheckedUpdateInput>
    /**
     * Choose, which ExerciseHistory to update.
     */
    where: ExerciseHistoryWhereUniqueInput
  }

  /**
   * ExerciseHistory updateMany
   */
  export type ExerciseHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExerciseHistories.
     */
    data: XOR<ExerciseHistoryUpdateManyMutationInput, ExerciseHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ExerciseHistories to update
     */
    where?: ExerciseHistoryWhereInput
  }

  /**
   * ExerciseHistory upsert
   */
  export type ExerciseHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseHistory
     */
    select?: ExerciseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ExerciseHistory to update in case it exists.
     */
    where: ExerciseHistoryWhereUniqueInput
    /**
     * In case the ExerciseHistory found by the `where` argument doesn't exist, create a new ExerciseHistory with this data.
     */
    create: XOR<ExerciseHistoryCreateInput, ExerciseHistoryUncheckedCreateInput>
    /**
     * In case the ExerciseHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseHistoryUpdateInput, ExerciseHistoryUncheckedUpdateInput>
  }

  /**
   * ExerciseHistory delete
   */
  export type ExerciseHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseHistory
     */
    select?: ExerciseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseHistoryInclude<ExtArgs> | null
    /**
     * Filter which ExerciseHistory to delete.
     */
    where: ExerciseHistoryWhereUniqueInput
  }

  /**
   * ExerciseHistory deleteMany
   */
  export type ExerciseHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciseHistories to delete
     */
    where?: ExerciseHistoryWhereInput
  }

  /**
   * ExerciseHistory without action
   */
  export type ExerciseHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseHistory
     */
    select?: ExerciseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseHistoryInclude<ExtArgs> | null
  }


  /**
   * Model FavoriteExercise
   */

  export type AggregateFavoriteExercise = {
    _count: FavoriteExerciseCountAggregateOutputType | null
    _min: FavoriteExerciseMinAggregateOutputType | null
    _max: FavoriteExerciseMaxAggregateOutputType | null
  }

  export type FavoriteExerciseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    exerciseId: string | null
    addedAt: Date | null
  }

  export type FavoriteExerciseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    exerciseId: string | null
    addedAt: Date | null
  }

  export type FavoriteExerciseCountAggregateOutputType = {
    id: number
    userId: number
    exerciseId: number
    addedAt: number
    _all: number
  }


  export type FavoriteExerciseMinAggregateInputType = {
    id?: true
    userId?: true
    exerciseId?: true
    addedAt?: true
  }

  export type FavoriteExerciseMaxAggregateInputType = {
    id?: true
    userId?: true
    exerciseId?: true
    addedAt?: true
  }

  export type FavoriteExerciseCountAggregateInputType = {
    id?: true
    userId?: true
    exerciseId?: true
    addedAt?: true
    _all?: true
  }

  export type FavoriteExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FavoriteExercise to aggregate.
     */
    where?: FavoriteExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteExercises to fetch.
     */
    orderBy?: FavoriteExerciseOrderByWithRelationInput | FavoriteExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoriteExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FavoriteExercises
    **/
    _count?: true | FavoriteExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoriteExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoriteExerciseMaxAggregateInputType
  }

  export type GetFavoriteExerciseAggregateType<T extends FavoriteExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateFavoriteExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavoriteExercise[P]>
      : GetScalarType<T[P], AggregateFavoriteExercise[P]>
  }




  export type FavoriteExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteExerciseWhereInput
    orderBy?: FavoriteExerciseOrderByWithAggregationInput | FavoriteExerciseOrderByWithAggregationInput[]
    by: FavoriteExerciseScalarFieldEnum[] | FavoriteExerciseScalarFieldEnum
    having?: FavoriteExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoriteExerciseCountAggregateInputType | true
    _min?: FavoriteExerciseMinAggregateInputType
    _max?: FavoriteExerciseMaxAggregateInputType
  }

  export type FavoriteExerciseGroupByOutputType = {
    id: string
    userId: string
    exerciseId: string
    addedAt: Date
    _count: FavoriteExerciseCountAggregateOutputType | null
    _min: FavoriteExerciseMinAggregateOutputType | null
    _max: FavoriteExerciseMaxAggregateOutputType | null
  }

  type GetFavoriteExerciseGroupByPayload<T extends FavoriteExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoriteExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoriteExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoriteExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], FavoriteExerciseGroupByOutputType[P]>
        }
      >
    >


  export type FavoriteExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    exerciseId?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favoriteExercise"]>

  export type FavoriteExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    exerciseId?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favoriteExercise"]>

  export type FavoriteExerciseSelectScalar = {
    id?: boolean
    userId?: boolean
    exerciseId?: boolean
    addedAt?: boolean
  }

  export type FavoriteExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }
  export type FavoriteExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }

  export type $FavoriteExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FavoriteExercise"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      exercise: Prisma.$ExercisePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      exerciseId: string
      addedAt: Date
    }, ExtArgs["result"]["favoriteExercise"]>
    composites: {}
  }

  type FavoriteExerciseGetPayload<S extends boolean | null | undefined | FavoriteExerciseDefaultArgs> = $Result.GetResult<Prisma.$FavoriteExercisePayload, S>

  type FavoriteExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FavoriteExerciseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FavoriteExerciseCountAggregateInputType | true
    }

  export interface FavoriteExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FavoriteExercise'], meta: { name: 'FavoriteExercise' } }
    /**
     * Find zero or one FavoriteExercise that matches the filter.
     * @param {FavoriteExerciseFindUniqueArgs} args - Arguments to find a FavoriteExercise
     * @example
     * // Get one FavoriteExercise
     * const favoriteExercise = await prisma.favoriteExercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoriteExerciseFindUniqueArgs>(args: SelectSubset<T, FavoriteExerciseFindUniqueArgs<ExtArgs>>): Prisma__FavoriteExerciseClient<$Result.GetResult<Prisma.$FavoriteExercisePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FavoriteExercise that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FavoriteExerciseFindUniqueOrThrowArgs} args - Arguments to find a FavoriteExercise
     * @example
     * // Get one FavoriteExercise
     * const favoriteExercise = await prisma.favoriteExercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoriteExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, FavoriteExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavoriteExerciseClient<$Result.GetResult<Prisma.$FavoriteExercisePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FavoriteExercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteExerciseFindFirstArgs} args - Arguments to find a FavoriteExercise
     * @example
     * // Get one FavoriteExercise
     * const favoriteExercise = await prisma.favoriteExercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoriteExerciseFindFirstArgs>(args?: SelectSubset<T, FavoriteExerciseFindFirstArgs<ExtArgs>>): Prisma__FavoriteExerciseClient<$Result.GetResult<Prisma.$FavoriteExercisePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FavoriteExercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteExerciseFindFirstOrThrowArgs} args - Arguments to find a FavoriteExercise
     * @example
     * // Get one FavoriteExercise
     * const favoriteExercise = await prisma.favoriteExercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoriteExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, FavoriteExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavoriteExerciseClient<$Result.GetResult<Prisma.$FavoriteExercisePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FavoriteExercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FavoriteExercises
     * const favoriteExercises = await prisma.favoriteExercise.findMany()
     * 
     * // Get first 10 FavoriteExercises
     * const favoriteExercises = await prisma.favoriteExercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favoriteExerciseWithIdOnly = await prisma.favoriteExercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FavoriteExerciseFindManyArgs>(args?: SelectSubset<T, FavoriteExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteExercisePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FavoriteExercise.
     * @param {FavoriteExerciseCreateArgs} args - Arguments to create a FavoriteExercise.
     * @example
     * // Create one FavoriteExercise
     * const FavoriteExercise = await prisma.favoriteExercise.create({
     *   data: {
     *     // ... data to create a FavoriteExercise
     *   }
     * })
     * 
     */
    create<T extends FavoriteExerciseCreateArgs>(args: SelectSubset<T, FavoriteExerciseCreateArgs<ExtArgs>>): Prisma__FavoriteExerciseClient<$Result.GetResult<Prisma.$FavoriteExercisePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FavoriteExercises.
     * @param {FavoriteExerciseCreateManyArgs} args - Arguments to create many FavoriteExercises.
     * @example
     * // Create many FavoriteExercises
     * const favoriteExercise = await prisma.favoriteExercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavoriteExerciseCreateManyArgs>(args?: SelectSubset<T, FavoriteExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FavoriteExercises and returns the data saved in the database.
     * @param {FavoriteExerciseCreateManyAndReturnArgs} args - Arguments to create many FavoriteExercises.
     * @example
     * // Create many FavoriteExercises
     * const favoriteExercise = await prisma.favoriteExercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FavoriteExercises and only return the `id`
     * const favoriteExerciseWithIdOnly = await prisma.favoriteExercise.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FavoriteExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, FavoriteExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteExercisePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FavoriteExercise.
     * @param {FavoriteExerciseDeleteArgs} args - Arguments to delete one FavoriteExercise.
     * @example
     * // Delete one FavoriteExercise
     * const FavoriteExercise = await prisma.favoriteExercise.delete({
     *   where: {
     *     // ... filter to delete one FavoriteExercise
     *   }
     * })
     * 
     */
    delete<T extends FavoriteExerciseDeleteArgs>(args: SelectSubset<T, FavoriteExerciseDeleteArgs<ExtArgs>>): Prisma__FavoriteExerciseClient<$Result.GetResult<Prisma.$FavoriteExercisePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FavoriteExercise.
     * @param {FavoriteExerciseUpdateArgs} args - Arguments to update one FavoriteExercise.
     * @example
     * // Update one FavoriteExercise
     * const favoriteExercise = await prisma.favoriteExercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavoriteExerciseUpdateArgs>(args: SelectSubset<T, FavoriteExerciseUpdateArgs<ExtArgs>>): Prisma__FavoriteExerciseClient<$Result.GetResult<Prisma.$FavoriteExercisePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FavoriteExercises.
     * @param {FavoriteExerciseDeleteManyArgs} args - Arguments to filter FavoriteExercises to delete.
     * @example
     * // Delete a few FavoriteExercises
     * const { count } = await prisma.favoriteExercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavoriteExerciseDeleteManyArgs>(args?: SelectSubset<T, FavoriteExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FavoriteExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FavoriteExercises
     * const favoriteExercise = await prisma.favoriteExercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavoriteExerciseUpdateManyArgs>(args: SelectSubset<T, FavoriteExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FavoriteExercise.
     * @param {FavoriteExerciseUpsertArgs} args - Arguments to update or create a FavoriteExercise.
     * @example
     * // Update or create a FavoriteExercise
     * const favoriteExercise = await prisma.favoriteExercise.upsert({
     *   create: {
     *     // ... data to create a FavoriteExercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FavoriteExercise we want to update
     *   }
     * })
     */
    upsert<T extends FavoriteExerciseUpsertArgs>(args: SelectSubset<T, FavoriteExerciseUpsertArgs<ExtArgs>>): Prisma__FavoriteExerciseClient<$Result.GetResult<Prisma.$FavoriteExercisePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FavoriteExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteExerciseCountArgs} args - Arguments to filter FavoriteExercises to count.
     * @example
     * // Count the number of FavoriteExercises
     * const count = await prisma.favoriteExercise.count({
     *   where: {
     *     // ... the filter for the FavoriteExercises we want to count
     *   }
     * })
    **/
    count<T extends FavoriteExerciseCountArgs>(
      args?: Subset<T, FavoriteExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoriteExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FavoriteExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoriteExerciseAggregateArgs>(args: Subset<T, FavoriteExerciseAggregateArgs>): Prisma.PrismaPromise<GetFavoriteExerciseAggregateType<T>>

    /**
     * Group by FavoriteExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoriteExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoriteExerciseGroupByArgs['orderBy'] }
        : { orderBy?: FavoriteExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoriteExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoriteExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FavoriteExercise model
   */
  readonly fields: FavoriteExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FavoriteExercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoriteExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    exercise<T extends ExerciseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseDefaultArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FavoriteExercise model
   */ 
  interface FavoriteExerciseFieldRefs {
    readonly id: FieldRef<"FavoriteExercise", 'String'>
    readonly userId: FieldRef<"FavoriteExercise", 'String'>
    readonly exerciseId: FieldRef<"FavoriteExercise", 'String'>
    readonly addedAt: FieldRef<"FavoriteExercise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FavoriteExercise findUnique
   */
  export type FavoriteExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteExercise
     */
    select?: FavoriteExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteExerciseInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteExercise to fetch.
     */
    where: FavoriteExerciseWhereUniqueInput
  }

  /**
   * FavoriteExercise findUniqueOrThrow
   */
  export type FavoriteExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteExercise
     */
    select?: FavoriteExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteExerciseInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteExercise to fetch.
     */
    where: FavoriteExerciseWhereUniqueInput
  }

  /**
   * FavoriteExercise findFirst
   */
  export type FavoriteExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteExercise
     */
    select?: FavoriteExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteExerciseInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteExercise to fetch.
     */
    where?: FavoriteExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteExercises to fetch.
     */
    orderBy?: FavoriteExerciseOrderByWithRelationInput | FavoriteExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FavoriteExercises.
     */
    cursor?: FavoriteExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FavoriteExercises.
     */
    distinct?: FavoriteExerciseScalarFieldEnum | FavoriteExerciseScalarFieldEnum[]
  }

  /**
   * FavoriteExercise findFirstOrThrow
   */
  export type FavoriteExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteExercise
     */
    select?: FavoriteExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteExerciseInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteExercise to fetch.
     */
    where?: FavoriteExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteExercises to fetch.
     */
    orderBy?: FavoriteExerciseOrderByWithRelationInput | FavoriteExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FavoriteExercises.
     */
    cursor?: FavoriteExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FavoriteExercises.
     */
    distinct?: FavoriteExerciseScalarFieldEnum | FavoriteExerciseScalarFieldEnum[]
  }

  /**
   * FavoriteExercise findMany
   */
  export type FavoriteExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteExercise
     */
    select?: FavoriteExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteExerciseInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteExercises to fetch.
     */
    where?: FavoriteExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteExercises to fetch.
     */
    orderBy?: FavoriteExerciseOrderByWithRelationInput | FavoriteExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FavoriteExercises.
     */
    cursor?: FavoriteExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteExercises.
     */
    skip?: number
    distinct?: FavoriteExerciseScalarFieldEnum | FavoriteExerciseScalarFieldEnum[]
  }

  /**
   * FavoriteExercise create
   */
  export type FavoriteExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteExercise
     */
    select?: FavoriteExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a FavoriteExercise.
     */
    data: XOR<FavoriteExerciseCreateInput, FavoriteExerciseUncheckedCreateInput>
  }

  /**
   * FavoriteExercise createMany
   */
  export type FavoriteExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FavoriteExercises.
     */
    data: FavoriteExerciseCreateManyInput | FavoriteExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FavoriteExercise createManyAndReturn
   */
  export type FavoriteExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteExercise
     */
    select?: FavoriteExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FavoriteExercises.
     */
    data: FavoriteExerciseCreateManyInput | FavoriteExerciseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteExerciseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FavoriteExercise update
   */
  export type FavoriteExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteExercise
     */
    select?: FavoriteExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a FavoriteExercise.
     */
    data: XOR<FavoriteExerciseUpdateInput, FavoriteExerciseUncheckedUpdateInput>
    /**
     * Choose, which FavoriteExercise to update.
     */
    where: FavoriteExerciseWhereUniqueInput
  }

  /**
   * FavoriteExercise updateMany
   */
  export type FavoriteExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FavoriteExercises.
     */
    data: XOR<FavoriteExerciseUpdateManyMutationInput, FavoriteExerciseUncheckedUpdateManyInput>
    /**
     * Filter which FavoriteExercises to update
     */
    where?: FavoriteExerciseWhereInput
  }

  /**
   * FavoriteExercise upsert
   */
  export type FavoriteExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteExercise
     */
    select?: FavoriteExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the FavoriteExercise to update in case it exists.
     */
    where: FavoriteExerciseWhereUniqueInput
    /**
     * In case the FavoriteExercise found by the `where` argument doesn't exist, create a new FavoriteExercise with this data.
     */
    create: XOR<FavoriteExerciseCreateInput, FavoriteExerciseUncheckedCreateInput>
    /**
     * In case the FavoriteExercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoriteExerciseUpdateInput, FavoriteExerciseUncheckedUpdateInput>
  }

  /**
   * FavoriteExercise delete
   */
  export type FavoriteExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteExercise
     */
    select?: FavoriteExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteExerciseInclude<ExtArgs> | null
    /**
     * Filter which FavoriteExercise to delete.
     */
    where: FavoriteExerciseWhereUniqueInput
  }

  /**
   * FavoriteExercise deleteMany
   */
  export type FavoriteExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FavoriteExercises to delete
     */
    where?: FavoriteExerciseWhereInput
  }

  /**
   * FavoriteExercise without action
   */
  export type FavoriteExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteExercise
     */
    select?: FavoriteExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteExerciseInclude<ExtArgs> | null
  }


  /**
   * Model WorkoutSession
   */

  export type AggregateWorkoutSession = {
    _count: WorkoutSessionCountAggregateOutputType | null
    _avg: WorkoutSessionAvgAggregateOutputType | null
    _sum: WorkoutSessionSumAggregateOutputType | null
    _min: WorkoutSessionMinAggregateOutputType | null
    _max: WorkoutSessionMaxAggregateOutputType | null
  }

  export type WorkoutSessionAvgAggregateOutputType = {
    duration: number | null
    restPeriodSeconds: number | null
    exercisesCompleted: number | null
    totalExercises: number | null
  }

  export type WorkoutSessionSumAggregateOutputType = {
    duration: number | null
    restPeriodSeconds: number | null
    exercisesCompleted: number | null
    totalExercises: number | null
  }

  export type WorkoutSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    startedAt: Date | null
    startTime: Date | null
    endedAt: Date | null
    endTime: Date | null
    duration: number | null
    notes: string | null
    restPeriodSeconds: number | null
    formGuidanceEnabled: boolean | null
    exercisesCompleted: number | null
    totalExercises: number | null
  }

  export type WorkoutSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    startedAt: Date | null
    startTime: Date | null
    endedAt: Date | null
    endTime: Date | null
    duration: number | null
    notes: string | null
    restPeriodSeconds: number | null
    formGuidanceEnabled: boolean | null
    exercisesCompleted: number | null
    totalExercises: number | null
  }

  export type WorkoutSessionCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    startedAt: number
    startTime: number
    endedAt: number
    endTime: number
    duration: number
    notes: number
    restPeriodSeconds: number
    formGuidanceEnabled: number
    exercisesCompleted: number
    totalExercises: number
    _all: number
  }


  export type WorkoutSessionAvgAggregateInputType = {
    duration?: true
    restPeriodSeconds?: true
    exercisesCompleted?: true
    totalExercises?: true
  }

  export type WorkoutSessionSumAggregateInputType = {
    duration?: true
    restPeriodSeconds?: true
    exercisesCompleted?: true
    totalExercises?: true
  }

  export type WorkoutSessionMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    startedAt?: true
    startTime?: true
    endedAt?: true
    endTime?: true
    duration?: true
    notes?: true
    restPeriodSeconds?: true
    formGuidanceEnabled?: true
    exercisesCompleted?: true
    totalExercises?: true
  }

  export type WorkoutSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    startedAt?: true
    startTime?: true
    endedAt?: true
    endTime?: true
    duration?: true
    notes?: true
    restPeriodSeconds?: true
    formGuidanceEnabled?: true
    exercisesCompleted?: true
    totalExercises?: true
  }

  export type WorkoutSessionCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    startedAt?: true
    startTime?: true
    endedAt?: true
    endTime?: true
    duration?: true
    notes?: true
    restPeriodSeconds?: true
    formGuidanceEnabled?: true
    exercisesCompleted?: true
    totalExercises?: true
    _all?: true
  }

  export type WorkoutSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutSession to aggregate.
     */
    where?: WorkoutSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSessions to fetch.
     */
    orderBy?: WorkoutSessionOrderByWithRelationInput | WorkoutSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkoutSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkoutSessions
    **/
    _count?: true | WorkoutSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutSessionMaxAggregateInputType
  }

  export type GetWorkoutSessionAggregateType<T extends WorkoutSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkoutSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkoutSession[P]>
      : GetScalarType<T[P], AggregateWorkoutSession[P]>
  }




  export type WorkoutSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutSessionWhereInput
    orderBy?: WorkoutSessionOrderByWithAggregationInput | WorkoutSessionOrderByWithAggregationInput[]
    by: WorkoutSessionScalarFieldEnum[] | WorkoutSessionScalarFieldEnum
    having?: WorkoutSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutSessionCountAggregateInputType | true
    _avg?: WorkoutSessionAvgAggregateInputType
    _sum?: WorkoutSessionSumAggregateInputType
    _min?: WorkoutSessionMinAggregateInputType
    _max?: WorkoutSessionMaxAggregateInputType
  }

  export type WorkoutSessionGroupByOutputType = {
    id: string
    userId: string
    title: string | null
    startedAt: Date
    startTime: Date | null
    endedAt: Date | null
    endTime: Date | null
    duration: number | null
    notes: string | null
    restPeriodSeconds: number | null
    formGuidanceEnabled: boolean | null
    exercisesCompleted: number | null
    totalExercises: number | null
    _count: WorkoutSessionCountAggregateOutputType | null
    _avg: WorkoutSessionAvgAggregateOutputType | null
    _sum: WorkoutSessionSumAggregateOutputType | null
    _min: WorkoutSessionMinAggregateOutputType | null
    _max: WorkoutSessionMaxAggregateOutputType | null
  }

  type GetWorkoutSessionGroupByPayload<T extends WorkoutSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkoutSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutSessionGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutSessionGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    startedAt?: boolean
    startTime?: boolean
    endedAt?: boolean
    endTime?: boolean
    duration?: boolean
    notes?: boolean
    restPeriodSeconds?: boolean
    formGuidanceEnabled?: boolean
    exercisesCompleted?: boolean
    totalExercises?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    logs?: boolean | WorkoutSession$logsArgs<ExtArgs>
    _count?: boolean | WorkoutSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutSession"]>

  export type WorkoutSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    startedAt?: boolean
    startTime?: boolean
    endedAt?: boolean
    endTime?: boolean
    duration?: boolean
    notes?: boolean
    restPeriodSeconds?: boolean
    formGuidanceEnabled?: boolean
    exercisesCompleted?: boolean
    totalExercises?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutSession"]>

  export type WorkoutSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    startedAt?: boolean
    startTime?: boolean
    endedAt?: boolean
    endTime?: boolean
    duration?: boolean
    notes?: boolean
    restPeriodSeconds?: boolean
    formGuidanceEnabled?: boolean
    exercisesCompleted?: boolean
    totalExercises?: boolean
  }

  export type WorkoutSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    logs?: boolean | WorkoutSession$logsArgs<ExtArgs>
    _count?: boolean | WorkoutSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkoutSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkoutSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkoutSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      logs: Prisma.$ExerciseLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string | null
      startedAt: Date
      startTime: Date | null
      endedAt: Date | null
      endTime: Date | null
      duration: number | null
      notes: string | null
      restPeriodSeconds: number | null
      formGuidanceEnabled: boolean | null
      exercisesCompleted: number | null
      totalExercises: number | null
    }, ExtArgs["result"]["workoutSession"]>
    composites: {}
  }

  type WorkoutSessionGetPayload<S extends boolean | null | undefined | WorkoutSessionDefaultArgs> = $Result.GetResult<Prisma.$WorkoutSessionPayload, S>

  type WorkoutSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkoutSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkoutSessionCountAggregateInputType | true
    }

  export interface WorkoutSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkoutSession'], meta: { name: 'WorkoutSession' } }
    /**
     * Find zero or one WorkoutSession that matches the filter.
     * @param {WorkoutSessionFindUniqueArgs} args - Arguments to find a WorkoutSession
     * @example
     * // Get one WorkoutSession
     * const workoutSession = await prisma.workoutSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkoutSessionFindUniqueArgs>(args: SelectSubset<T, WorkoutSessionFindUniqueArgs<ExtArgs>>): Prisma__WorkoutSessionClient<$Result.GetResult<Prisma.$WorkoutSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkoutSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkoutSessionFindUniqueOrThrowArgs} args - Arguments to find a WorkoutSession
     * @example
     * // Get one WorkoutSession
     * const workoutSession = await prisma.workoutSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkoutSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkoutSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkoutSessionClient<$Result.GetResult<Prisma.$WorkoutSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkoutSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionFindFirstArgs} args - Arguments to find a WorkoutSession
     * @example
     * // Get one WorkoutSession
     * const workoutSession = await prisma.workoutSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkoutSessionFindFirstArgs>(args?: SelectSubset<T, WorkoutSessionFindFirstArgs<ExtArgs>>): Prisma__WorkoutSessionClient<$Result.GetResult<Prisma.$WorkoutSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkoutSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionFindFirstOrThrowArgs} args - Arguments to find a WorkoutSession
     * @example
     * // Get one WorkoutSession
     * const workoutSession = await prisma.workoutSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkoutSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkoutSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkoutSessionClient<$Result.GetResult<Prisma.$WorkoutSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkoutSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkoutSessions
     * const workoutSessions = await prisma.workoutSession.findMany()
     * 
     * // Get first 10 WorkoutSessions
     * const workoutSessions = await prisma.workoutSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutSessionWithIdOnly = await prisma.workoutSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkoutSessionFindManyArgs>(args?: SelectSubset<T, WorkoutSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkoutSession.
     * @param {WorkoutSessionCreateArgs} args - Arguments to create a WorkoutSession.
     * @example
     * // Create one WorkoutSession
     * const WorkoutSession = await prisma.workoutSession.create({
     *   data: {
     *     // ... data to create a WorkoutSession
     *   }
     * })
     * 
     */
    create<T extends WorkoutSessionCreateArgs>(args: SelectSubset<T, WorkoutSessionCreateArgs<ExtArgs>>): Prisma__WorkoutSessionClient<$Result.GetResult<Prisma.$WorkoutSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkoutSessions.
     * @param {WorkoutSessionCreateManyArgs} args - Arguments to create many WorkoutSessions.
     * @example
     * // Create many WorkoutSessions
     * const workoutSession = await prisma.workoutSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkoutSessionCreateManyArgs>(args?: SelectSubset<T, WorkoutSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkoutSessions and returns the data saved in the database.
     * @param {WorkoutSessionCreateManyAndReturnArgs} args - Arguments to create many WorkoutSessions.
     * @example
     * // Create many WorkoutSessions
     * const workoutSession = await prisma.workoutSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkoutSessions and only return the `id`
     * const workoutSessionWithIdOnly = await prisma.workoutSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkoutSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkoutSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkoutSession.
     * @param {WorkoutSessionDeleteArgs} args - Arguments to delete one WorkoutSession.
     * @example
     * // Delete one WorkoutSession
     * const WorkoutSession = await prisma.workoutSession.delete({
     *   where: {
     *     // ... filter to delete one WorkoutSession
     *   }
     * })
     * 
     */
    delete<T extends WorkoutSessionDeleteArgs>(args: SelectSubset<T, WorkoutSessionDeleteArgs<ExtArgs>>): Prisma__WorkoutSessionClient<$Result.GetResult<Prisma.$WorkoutSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkoutSession.
     * @param {WorkoutSessionUpdateArgs} args - Arguments to update one WorkoutSession.
     * @example
     * // Update one WorkoutSession
     * const workoutSession = await prisma.workoutSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkoutSessionUpdateArgs>(args: SelectSubset<T, WorkoutSessionUpdateArgs<ExtArgs>>): Prisma__WorkoutSessionClient<$Result.GetResult<Prisma.$WorkoutSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkoutSessions.
     * @param {WorkoutSessionDeleteManyArgs} args - Arguments to filter WorkoutSessions to delete.
     * @example
     * // Delete a few WorkoutSessions
     * const { count } = await prisma.workoutSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkoutSessionDeleteManyArgs>(args?: SelectSubset<T, WorkoutSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkoutSessions
     * const workoutSession = await prisma.workoutSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkoutSessionUpdateManyArgs>(args: SelectSubset<T, WorkoutSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkoutSession.
     * @param {WorkoutSessionUpsertArgs} args - Arguments to update or create a WorkoutSession.
     * @example
     * // Update or create a WorkoutSession
     * const workoutSession = await prisma.workoutSession.upsert({
     *   create: {
     *     // ... data to create a WorkoutSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkoutSession we want to update
     *   }
     * })
     */
    upsert<T extends WorkoutSessionUpsertArgs>(args: SelectSubset<T, WorkoutSessionUpsertArgs<ExtArgs>>): Prisma__WorkoutSessionClient<$Result.GetResult<Prisma.$WorkoutSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkoutSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionCountArgs} args - Arguments to filter WorkoutSessions to count.
     * @example
     * // Count the number of WorkoutSessions
     * const count = await prisma.workoutSession.count({
     *   where: {
     *     // ... the filter for the WorkoutSessions we want to count
     *   }
     * })
    **/
    count<T extends WorkoutSessionCountArgs>(
      args?: Subset<T, WorkoutSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkoutSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutSessionAggregateArgs>(args: Subset<T, WorkoutSessionAggregateArgs>): Prisma.PrismaPromise<GetWorkoutSessionAggregateType<T>>

    /**
     * Group by WorkoutSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutSessionGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkoutSession model
   */
  readonly fields: WorkoutSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkoutSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkoutSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    logs<T extends WorkoutSession$logsArgs<ExtArgs> = {}>(args?: Subset<T, WorkoutSession$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkoutSession model
   */ 
  interface WorkoutSessionFieldRefs {
    readonly id: FieldRef<"WorkoutSession", 'String'>
    readonly userId: FieldRef<"WorkoutSession", 'String'>
    readonly title: FieldRef<"WorkoutSession", 'String'>
    readonly startedAt: FieldRef<"WorkoutSession", 'DateTime'>
    readonly startTime: FieldRef<"WorkoutSession", 'DateTime'>
    readonly endedAt: FieldRef<"WorkoutSession", 'DateTime'>
    readonly endTime: FieldRef<"WorkoutSession", 'DateTime'>
    readonly duration: FieldRef<"WorkoutSession", 'Int'>
    readonly notes: FieldRef<"WorkoutSession", 'String'>
    readonly restPeriodSeconds: FieldRef<"WorkoutSession", 'Int'>
    readonly formGuidanceEnabled: FieldRef<"WorkoutSession", 'Boolean'>
    readonly exercisesCompleted: FieldRef<"WorkoutSession", 'Int'>
    readonly totalExercises: FieldRef<"WorkoutSession", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * WorkoutSession findUnique
   */
  export type WorkoutSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSession
     */
    select?: WorkoutSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSessionInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutSession to fetch.
     */
    where: WorkoutSessionWhereUniqueInput
  }

  /**
   * WorkoutSession findUniqueOrThrow
   */
  export type WorkoutSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSession
     */
    select?: WorkoutSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSessionInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutSession to fetch.
     */
    where: WorkoutSessionWhereUniqueInput
  }

  /**
   * WorkoutSession findFirst
   */
  export type WorkoutSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSession
     */
    select?: WorkoutSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSessionInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutSession to fetch.
     */
    where?: WorkoutSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSessions to fetch.
     */
    orderBy?: WorkoutSessionOrderByWithRelationInput | WorkoutSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutSessions.
     */
    cursor?: WorkoutSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutSessions.
     */
    distinct?: WorkoutSessionScalarFieldEnum | WorkoutSessionScalarFieldEnum[]
  }

  /**
   * WorkoutSession findFirstOrThrow
   */
  export type WorkoutSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSession
     */
    select?: WorkoutSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSessionInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutSession to fetch.
     */
    where?: WorkoutSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSessions to fetch.
     */
    orderBy?: WorkoutSessionOrderByWithRelationInput | WorkoutSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutSessions.
     */
    cursor?: WorkoutSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutSessions.
     */
    distinct?: WorkoutSessionScalarFieldEnum | WorkoutSessionScalarFieldEnum[]
  }

  /**
   * WorkoutSession findMany
   */
  export type WorkoutSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSession
     */
    select?: WorkoutSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSessionInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutSessions to fetch.
     */
    where?: WorkoutSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSessions to fetch.
     */
    orderBy?: WorkoutSessionOrderByWithRelationInput | WorkoutSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkoutSessions.
     */
    cursor?: WorkoutSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSessions.
     */
    skip?: number
    distinct?: WorkoutSessionScalarFieldEnum | WorkoutSessionScalarFieldEnum[]
  }

  /**
   * WorkoutSession create
   */
  export type WorkoutSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSession
     */
    select?: WorkoutSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkoutSession.
     */
    data: XOR<WorkoutSessionCreateInput, WorkoutSessionUncheckedCreateInput>
  }

  /**
   * WorkoutSession createMany
   */
  export type WorkoutSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkoutSessions.
     */
    data: WorkoutSessionCreateManyInput | WorkoutSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkoutSession createManyAndReturn
   */
  export type WorkoutSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSession
     */
    select?: WorkoutSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkoutSessions.
     */
    data: WorkoutSessionCreateManyInput | WorkoutSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkoutSession update
   */
  export type WorkoutSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSession
     */
    select?: WorkoutSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkoutSession.
     */
    data: XOR<WorkoutSessionUpdateInput, WorkoutSessionUncheckedUpdateInput>
    /**
     * Choose, which WorkoutSession to update.
     */
    where: WorkoutSessionWhereUniqueInput
  }

  /**
   * WorkoutSession updateMany
   */
  export type WorkoutSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkoutSessions.
     */
    data: XOR<WorkoutSessionUpdateManyMutationInput, WorkoutSessionUncheckedUpdateManyInput>
    /**
     * Filter which WorkoutSessions to update
     */
    where?: WorkoutSessionWhereInput
  }

  /**
   * WorkoutSession upsert
   */
  export type WorkoutSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSession
     */
    select?: WorkoutSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkoutSession to update in case it exists.
     */
    where: WorkoutSessionWhereUniqueInput
    /**
     * In case the WorkoutSession found by the `where` argument doesn't exist, create a new WorkoutSession with this data.
     */
    create: XOR<WorkoutSessionCreateInput, WorkoutSessionUncheckedCreateInput>
    /**
     * In case the WorkoutSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkoutSessionUpdateInput, WorkoutSessionUncheckedUpdateInput>
  }

  /**
   * WorkoutSession delete
   */
  export type WorkoutSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSession
     */
    select?: WorkoutSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSessionInclude<ExtArgs> | null
    /**
     * Filter which WorkoutSession to delete.
     */
    where: WorkoutSessionWhereUniqueInput
  }

  /**
   * WorkoutSession deleteMany
   */
  export type WorkoutSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutSessions to delete
     */
    where?: WorkoutSessionWhereInput
  }

  /**
   * WorkoutSession.logs
   */
  export type WorkoutSession$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    where?: ExerciseLogWhereInput
    orderBy?: ExerciseLogOrderByWithRelationInput | ExerciseLogOrderByWithRelationInput[]
    cursor?: ExerciseLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseLogScalarFieldEnum | ExerciseLogScalarFieldEnum[]
  }

  /**
   * WorkoutSession without action
   */
  export type WorkoutSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSession
     */
    select?: WorkoutSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSessionInclude<ExtArgs> | null
  }


  /**
   * Model ExerciseLog
   */

  export type AggregateExerciseLog = {
    _count: ExerciseLogCountAggregateOutputType | null
    _avg: ExerciseLogAvgAggregateOutputType | null
    _sum: ExerciseLogSumAggregateOutputType | null
    _min: ExerciseLogMinAggregateOutputType | null
    _max: ExerciseLogMaxAggregateOutputType | null
  }

  export type ExerciseLogAvgAggregateOutputType = {
    reps: number | null
    sets: number | null
    setsCompleted: number | null
    weight: number | null
    duration: number | null
    formRating: number | null
  }

  export type ExerciseLogSumAggregateOutputType = {
    reps: number | null
    sets: number | null
    setsCompleted: number | null
    weight: number | null
    duration: number | null
    formRating: number | null
  }

  export type ExerciseLogMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    exerciseId: string | null
    userId: string | null
    reps: number | null
    sets: number | null
    setsCompleted: number | null
    weight: number | null
    duration: number | null
    formRating: number | null
    skipped: boolean | null
    notes: string | null
    loggedAt: Date | null
    completedAt: Date | null
  }

  export type ExerciseLogMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    exerciseId: string | null
    userId: string | null
    reps: number | null
    sets: number | null
    setsCompleted: number | null
    weight: number | null
    duration: number | null
    formRating: number | null
    skipped: boolean | null
    notes: string | null
    loggedAt: Date | null
    completedAt: Date | null
  }

  export type ExerciseLogCountAggregateOutputType = {
    id: number
    sessionId: number
    exerciseId: number
    userId: number
    reps: number
    sets: number
    setsCompleted: number
    weight: number
    duration: number
    formRating: number
    skipped: number
    notes: number
    loggedAt: number
    completedAt: number
    _all: number
  }


  export type ExerciseLogAvgAggregateInputType = {
    reps?: true
    sets?: true
    setsCompleted?: true
    weight?: true
    duration?: true
    formRating?: true
  }

  export type ExerciseLogSumAggregateInputType = {
    reps?: true
    sets?: true
    setsCompleted?: true
    weight?: true
    duration?: true
    formRating?: true
  }

  export type ExerciseLogMinAggregateInputType = {
    id?: true
    sessionId?: true
    exerciseId?: true
    userId?: true
    reps?: true
    sets?: true
    setsCompleted?: true
    weight?: true
    duration?: true
    formRating?: true
    skipped?: true
    notes?: true
    loggedAt?: true
    completedAt?: true
  }

  export type ExerciseLogMaxAggregateInputType = {
    id?: true
    sessionId?: true
    exerciseId?: true
    userId?: true
    reps?: true
    sets?: true
    setsCompleted?: true
    weight?: true
    duration?: true
    formRating?: true
    skipped?: true
    notes?: true
    loggedAt?: true
    completedAt?: true
  }

  export type ExerciseLogCountAggregateInputType = {
    id?: true
    sessionId?: true
    exerciseId?: true
    userId?: true
    reps?: true
    sets?: true
    setsCompleted?: true
    weight?: true
    duration?: true
    formRating?: true
    skipped?: true
    notes?: true
    loggedAt?: true
    completedAt?: true
    _all?: true
  }

  export type ExerciseLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciseLog to aggregate.
     */
    where?: ExerciseLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseLogs to fetch.
     */
    orderBy?: ExerciseLogOrderByWithRelationInput | ExerciseLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExerciseLogs
    **/
    _count?: true | ExerciseLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseLogMaxAggregateInputType
  }

  export type GetExerciseLogAggregateType<T extends ExerciseLogAggregateArgs> = {
        [P in keyof T & keyof AggregateExerciseLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExerciseLog[P]>
      : GetScalarType<T[P], AggregateExerciseLog[P]>
  }




  export type ExerciseLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseLogWhereInput
    orderBy?: ExerciseLogOrderByWithAggregationInput | ExerciseLogOrderByWithAggregationInput[]
    by: ExerciseLogScalarFieldEnum[] | ExerciseLogScalarFieldEnum
    having?: ExerciseLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseLogCountAggregateInputType | true
    _avg?: ExerciseLogAvgAggregateInputType
    _sum?: ExerciseLogSumAggregateInputType
    _min?: ExerciseLogMinAggregateInputType
    _max?: ExerciseLogMaxAggregateInputType
  }

  export type ExerciseLogGroupByOutputType = {
    id: string
    sessionId: string
    exerciseId: string
    userId: string | null
    reps: number | null
    sets: number | null
    setsCompleted: number | null
    weight: number | null
    duration: number | null
    formRating: number | null
    skipped: boolean | null
    notes: string | null
    loggedAt: Date
    completedAt: Date | null
    _count: ExerciseLogCountAggregateOutputType | null
    _avg: ExerciseLogAvgAggregateOutputType | null
    _sum: ExerciseLogSumAggregateOutputType | null
    _min: ExerciseLogMinAggregateOutputType | null
    _max: ExerciseLogMaxAggregateOutputType | null
  }

  type GetExerciseLogGroupByPayload<T extends ExerciseLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseLogGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseLogGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    exerciseId?: boolean
    userId?: boolean
    reps?: boolean
    sets?: boolean
    setsCompleted?: boolean
    weight?: boolean
    duration?: boolean
    formRating?: boolean
    skipped?: boolean
    notes?: boolean
    loggedAt?: boolean
    completedAt?: boolean
    session?: boolean | WorkoutSessionDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseLog"]>

  export type ExerciseLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    exerciseId?: boolean
    userId?: boolean
    reps?: boolean
    sets?: boolean
    setsCompleted?: boolean
    weight?: boolean
    duration?: boolean
    formRating?: boolean
    skipped?: boolean
    notes?: boolean
    loggedAt?: boolean
    completedAt?: boolean
    session?: boolean | WorkoutSessionDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseLog"]>

  export type ExerciseLogSelectScalar = {
    id?: boolean
    sessionId?: boolean
    exerciseId?: boolean
    userId?: boolean
    reps?: boolean
    sets?: boolean
    setsCompleted?: boolean
    weight?: boolean
    duration?: boolean
    formRating?: boolean
    skipped?: boolean
    notes?: boolean
    loggedAt?: boolean
    completedAt?: boolean
  }

  export type ExerciseLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | WorkoutSessionDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }
  export type ExerciseLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | WorkoutSessionDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }

  export type $ExerciseLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExerciseLog"
    objects: {
      session: Prisma.$WorkoutSessionPayload<ExtArgs>
      exercise: Prisma.$ExercisePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      exerciseId: string
      userId: string | null
      reps: number | null
      sets: number | null
      setsCompleted: number | null
      weight: number | null
      duration: number | null
      formRating: number | null
      skipped: boolean | null
      notes: string | null
      loggedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["exerciseLog"]>
    composites: {}
  }

  type ExerciseLogGetPayload<S extends boolean | null | undefined | ExerciseLogDefaultArgs> = $Result.GetResult<Prisma.$ExerciseLogPayload, S>

  type ExerciseLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExerciseLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExerciseLogCountAggregateInputType | true
    }

  export interface ExerciseLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExerciseLog'], meta: { name: 'ExerciseLog' } }
    /**
     * Find zero or one ExerciseLog that matches the filter.
     * @param {ExerciseLogFindUniqueArgs} args - Arguments to find a ExerciseLog
     * @example
     * // Get one ExerciseLog
     * const exerciseLog = await prisma.exerciseLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseLogFindUniqueArgs>(args: SelectSubset<T, ExerciseLogFindUniqueArgs<ExtArgs>>): Prisma__ExerciseLogClient<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExerciseLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExerciseLogFindUniqueOrThrowArgs} args - Arguments to find a ExerciseLog
     * @example
     * // Get one ExerciseLog
     * const exerciseLog = await prisma.exerciseLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseLogClient<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExerciseLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogFindFirstArgs} args - Arguments to find a ExerciseLog
     * @example
     * // Get one ExerciseLog
     * const exerciseLog = await prisma.exerciseLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseLogFindFirstArgs>(args?: SelectSubset<T, ExerciseLogFindFirstArgs<ExtArgs>>): Prisma__ExerciseLogClient<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExerciseLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogFindFirstOrThrowArgs} args - Arguments to find a ExerciseLog
     * @example
     * // Get one ExerciseLog
     * const exerciseLog = await prisma.exerciseLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseLogClient<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExerciseLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExerciseLogs
     * const exerciseLogs = await prisma.exerciseLog.findMany()
     * 
     * // Get first 10 ExerciseLogs
     * const exerciseLogs = await prisma.exerciseLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseLogWithIdOnly = await prisma.exerciseLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseLogFindManyArgs>(args?: SelectSubset<T, ExerciseLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExerciseLog.
     * @param {ExerciseLogCreateArgs} args - Arguments to create a ExerciseLog.
     * @example
     * // Create one ExerciseLog
     * const ExerciseLog = await prisma.exerciseLog.create({
     *   data: {
     *     // ... data to create a ExerciseLog
     *   }
     * })
     * 
     */
    create<T extends ExerciseLogCreateArgs>(args: SelectSubset<T, ExerciseLogCreateArgs<ExtArgs>>): Prisma__ExerciseLogClient<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExerciseLogs.
     * @param {ExerciseLogCreateManyArgs} args - Arguments to create many ExerciseLogs.
     * @example
     * // Create many ExerciseLogs
     * const exerciseLog = await prisma.exerciseLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseLogCreateManyArgs>(args?: SelectSubset<T, ExerciseLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExerciseLogs and returns the data saved in the database.
     * @param {ExerciseLogCreateManyAndReturnArgs} args - Arguments to create many ExerciseLogs.
     * @example
     * // Create many ExerciseLogs
     * const exerciseLog = await prisma.exerciseLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExerciseLogs and only return the `id`
     * const exerciseLogWithIdOnly = await prisma.exerciseLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExerciseLog.
     * @param {ExerciseLogDeleteArgs} args - Arguments to delete one ExerciseLog.
     * @example
     * // Delete one ExerciseLog
     * const ExerciseLog = await prisma.exerciseLog.delete({
     *   where: {
     *     // ... filter to delete one ExerciseLog
     *   }
     * })
     * 
     */
    delete<T extends ExerciseLogDeleteArgs>(args: SelectSubset<T, ExerciseLogDeleteArgs<ExtArgs>>): Prisma__ExerciseLogClient<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExerciseLog.
     * @param {ExerciseLogUpdateArgs} args - Arguments to update one ExerciseLog.
     * @example
     * // Update one ExerciseLog
     * const exerciseLog = await prisma.exerciseLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseLogUpdateArgs>(args: SelectSubset<T, ExerciseLogUpdateArgs<ExtArgs>>): Prisma__ExerciseLogClient<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExerciseLogs.
     * @param {ExerciseLogDeleteManyArgs} args - Arguments to filter ExerciseLogs to delete.
     * @example
     * // Delete a few ExerciseLogs
     * const { count } = await prisma.exerciseLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseLogDeleteManyArgs>(args?: SelectSubset<T, ExerciseLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExerciseLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExerciseLogs
     * const exerciseLog = await prisma.exerciseLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseLogUpdateManyArgs>(args: SelectSubset<T, ExerciseLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExerciseLog.
     * @param {ExerciseLogUpsertArgs} args - Arguments to update or create a ExerciseLog.
     * @example
     * // Update or create a ExerciseLog
     * const exerciseLog = await prisma.exerciseLog.upsert({
     *   create: {
     *     // ... data to create a ExerciseLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExerciseLog we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseLogUpsertArgs>(args: SelectSubset<T, ExerciseLogUpsertArgs<ExtArgs>>): Prisma__ExerciseLogClient<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExerciseLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogCountArgs} args - Arguments to filter ExerciseLogs to count.
     * @example
     * // Count the number of ExerciseLogs
     * const count = await prisma.exerciseLog.count({
     *   where: {
     *     // ... the filter for the ExerciseLogs we want to count
     *   }
     * })
    **/
    count<T extends ExerciseLogCountArgs>(
      args?: Subset<T, ExerciseLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExerciseLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseLogAggregateArgs>(args: Subset<T, ExerciseLogAggregateArgs>): Prisma.PrismaPromise<GetExerciseLogAggregateType<T>>

    /**
     * Group by ExerciseLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseLogGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExerciseLog model
   */
  readonly fields: ExerciseLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExerciseLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends WorkoutSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkoutSessionDefaultArgs<ExtArgs>>): Prisma__WorkoutSessionClient<$Result.GetResult<Prisma.$WorkoutSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    exercise<T extends ExerciseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseDefaultArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExerciseLog model
   */ 
  interface ExerciseLogFieldRefs {
    readonly id: FieldRef<"ExerciseLog", 'String'>
    readonly sessionId: FieldRef<"ExerciseLog", 'String'>
    readonly exerciseId: FieldRef<"ExerciseLog", 'String'>
    readonly userId: FieldRef<"ExerciseLog", 'String'>
    readonly reps: FieldRef<"ExerciseLog", 'Int'>
    readonly sets: FieldRef<"ExerciseLog", 'Int'>
    readonly setsCompleted: FieldRef<"ExerciseLog", 'Int'>
    readonly weight: FieldRef<"ExerciseLog", 'Float'>
    readonly duration: FieldRef<"ExerciseLog", 'Int'>
    readonly formRating: FieldRef<"ExerciseLog", 'Int'>
    readonly skipped: FieldRef<"ExerciseLog", 'Boolean'>
    readonly notes: FieldRef<"ExerciseLog", 'String'>
    readonly loggedAt: FieldRef<"ExerciseLog", 'DateTime'>
    readonly completedAt: FieldRef<"ExerciseLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExerciseLog findUnique
   */
  export type ExerciseLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseLog to fetch.
     */
    where: ExerciseLogWhereUniqueInput
  }

  /**
   * ExerciseLog findUniqueOrThrow
   */
  export type ExerciseLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseLog to fetch.
     */
    where: ExerciseLogWhereUniqueInput
  }

  /**
   * ExerciseLog findFirst
   */
  export type ExerciseLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseLog to fetch.
     */
    where?: ExerciseLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseLogs to fetch.
     */
    orderBy?: ExerciseLogOrderByWithRelationInput | ExerciseLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseLogs.
     */
    cursor?: ExerciseLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseLogs.
     */
    distinct?: ExerciseLogScalarFieldEnum | ExerciseLogScalarFieldEnum[]
  }

  /**
   * ExerciseLog findFirstOrThrow
   */
  export type ExerciseLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseLog to fetch.
     */
    where?: ExerciseLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseLogs to fetch.
     */
    orderBy?: ExerciseLogOrderByWithRelationInput | ExerciseLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseLogs.
     */
    cursor?: ExerciseLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseLogs.
     */
    distinct?: ExerciseLogScalarFieldEnum | ExerciseLogScalarFieldEnum[]
  }

  /**
   * ExerciseLog findMany
   */
  export type ExerciseLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseLogs to fetch.
     */
    where?: ExerciseLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseLogs to fetch.
     */
    orderBy?: ExerciseLogOrderByWithRelationInput | ExerciseLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExerciseLogs.
     */
    cursor?: ExerciseLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseLogs.
     */
    skip?: number
    distinct?: ExerciseLogScalarFieldEnum | ExerciseLogScalarFieldEnum[]
  }

  /**
   * ExerciseLog create
   */
  export type ExerciseLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ExerciseLog.
     */
    data: XOR<ExerciseLogCreateInput, ExerciseLogUncheckedCreateInput>
  }

  /**
   * ExerciseLog createMany
   */
  export type ExerciseLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExerciseLogs.
     */
    data: ExerciseLogCreateManyInput | ExerciseLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExerciseLog createManyAndReturn
   */
  export type ExerciseLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExerciseLogs.
     */
    data: ExerciseLogCreateManyInput | ExerciseLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExerciseLog update
   */
  export type ExerciseLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ExerciseLog.
     */
    data: XOR<ExerciseLogUpdateInput, ExerciseLogUncheckedUpdateInput>
    /**
     * Choose, which ExerciseLog to update.
     */
    where: ExerciseLogWhereUniqueInput
  }

  /**
   * ExerciseLog updateMany
   */
  export type ExerciseLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExerciseLogs.
     */
    data: XOR<ExerciseLogUpdateManyMutationInput, ExerciseLogUncheckedUpdateManyInput>
    /**
     * Filter which ExerciseLogs to update
     */
    where?: ExerciseLogWhereInput
  }

  /**
   * ExerciseLog upsert
   */
  export type ExerciseLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ExerciseLog to update in case it exists.
     */
    where: ExerciseLogWhereUniqueInput
    /**
     * In case the ExerciseLog found by the `where` argument doesn't exist, create a new ExerciseLog with this data.
     */
    create: XOR<ExerciseLogCreateInput, ExerciseLogUncheckedCreateInput>
    /**
     * In case the ExerciseLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseLogUpdateInput, ExerciseLogUncheckedUpdateInput>
  }

  /**
   * ExerciseLog delete
   */
  export type ExerciseLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    /**
     * Filter which ExerciseLog to delete.
     */
    where: ExerciseLogWhereUniqueInput
  }

  /**
   * ExerciseLog deleteMany
   */
  export type ExerciseLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciseLogs to delete
     */
    where?: ExerciseLogWhereInput
  }

  /**
   * ExerciseLog without action
   */
  export type ExerciseLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
  }


  /**
   * Model Program
   */

  export type AggregateProgram = {
    _count: ProgramCountAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  export type ProgramMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    coachId: string | null
    ownerId: string | null
    isDraft: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    coachId: string | null
    ownerId: string | null
    isDraft: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramCountAggregateOutputType = {
    id: number
    title: number
    description: number
    coachId: number
    ownerId: number
    isDraft: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProgramMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    coachId?: true
    ownerId?: true
    isDraft?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    coachId?: true
    ownerId?: true
    isDraft?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    coachId?: true
    ownerId?: true
    isDraft?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Program to aggregate.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programs
    **/
    _count?: true | ProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramMaxAggregateInputType
  }

  export type GetProgramAggregateType<T extends ProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgram[P]>
      : GetScalarType<T[P], AggregateProgram[P]>
  }




  export type ProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithAggregationInput | ProgramOrderByWithAggregationInput[]
    by: ProgramScalarFieldEnum[] | ProgramScalarFieldEnum
    having?: ProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramCountAggregateInputType | true
    _min?: ProgramMinAggregateInputType
    _max?: ProgramMaxAggregateInputType
  }

  export type ProgramGroupByOutputType = {
    id: string
    title: string
    description: string | null
    coachId: string
    ownerId: string | null
    isDraft: boolean
    data: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ProgramCountAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  type GetProgramGroupByPayload<T extends ProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramGroupByOutputType[P]>
        }
      >
    >


  export type ProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    coachId?: boolean
    ownerId?: boolean
    isDraft?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignments?: boolean | Program$assignmentsArgs<ExtArgs>
    auditLogs?: boolean | Program$auditLogsArgs<ExtArgs>
    blocks?: boolean | Program$blocksArgs<ExtArgs>
    coach?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    coachId?: boolean
    ownerId?: boolean
    isDraft?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    coachId?: boolean
    ownerId?: boolean
    isDraft?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | Program$assignmentsArgs<ExtArgs>
    auditLogs?: boolean | Program$auditLogsArgs<ExtArgs>
    blocks?: boolean | Program$blocksArgs<ExtArgs>
    coach?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Program"
    objects: {
      assignments: Prisma.$ProgramAssignmentPayload<ExtArgs>[]
      auditLogs: Prisma.$ProgramAuditPayload<ExtArgs>[]
      blocks: Prisma.$ProgramBlockPayload<ExtArgs>[]
      coach: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      coachId: string
      ownerId: string | null
      isDraft: boolean
      data: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["program"]>
    composites: {}
  }

  type ProgramGetPayload<S extends boolean | null | undefined | ProgramDefaultArgs> = $Result.GetResult<Prisma.$ProgramPayload, S>

  type ProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgramFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgramCountAggregateInputType | true
    }

  export interface ProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Program'], meta: { name: 'Program' } }
    /**
     * Find zero or one Program that matches the filter.
     * @param {ProgramFindUniqueArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramFindUniqueArgs>(args: SelectSubset<T, ProgramFindUniqueArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Program that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgramFindUniqueOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Program that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramFindFirstArgs>(args?: SelectSubset<T, ProgramFindFirstArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Program that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Programs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programs
     * const programs = await prisma.program.findMany()
     * 
     * // Get first 10 Programs
     * const programs = await prisma.program.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programWithIdOnly = await prisma.program.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramFindManyArgs>(args?: SelectSubset<T, ProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Program.
     * @param {ProgramCreateArgs} args - Arguments to create a Program.
     * @example
     * // Create one Program
     * const Program = await prisma.program.create({
     *   data: {
     *     // ... data to create a Program
     *   }
     * })
     * 
     */
    create<T extends ProgramCreateArgs>(args: SelectSubset<T, ProgramCreateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Programs.
     * @param {ProgramCreateManyArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramCreateManyArgs>(args?: SelectSubset<T, ProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Programs and returns the data saved in the database.
     * @param {ProgramCreateManyAndReturnArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Programs and only return the `id`
     * const programWithIdOnly = await prisma.program.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Program.
     * @param {ProgramDeleteArgs} args - Arguments to delete one Program.
     * @example
     * // Delete one Program
     * const Program = await prisma.program.delete({
     *   where: {
     *     // ... filter to delete one Program
     *   }
     * })
     * 
     */
    delete<T extends ProgramDeleteArgs>(args: SelectSubset<T, ProgramDeleteArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Program.
     * @param {ProgramUpdateArgs} args - Arguments to update one Program.
     * @example
     * // Update one Program
     * const program = await prisma.program.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramUpdateArgs>(args: SelectSubset<T, ProgramUpdateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Programs.
     * @param {ProgramDeleteManyArgs} args - Arguments to filter Programs to delete.
     * @example
     * // Delete a few Programs
     * const { count } = await prisma.program.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramDeleteManyArgs>(args?: SelectSubset<T, ProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramUpdateManyArgs>(args: SelectSubset<T, ProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Program.
     * @param {ProgramUpsertArgs} args - Arguments to update or create a Program.
     * @example
     * // Update or create a Program
     * const program = await prisma.program.upsert({
     *   create: {
     *     // ... data to create a Program
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Program we want to update
     *   }
     * })
     */
    upsert<T extends ProgramUpsertArgs>(args: SelectSubset<T, ProgramUpsertArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCountArgs} args - Arguments to filter Programs to count.
     * @example
     * // Count the number of Programs
     * const count = await prisma.program.count({
     *   where: {
     *     // ... the filter for the Programs we want to count
     *   }
     * })
    **/
    count<T extends ProgramCountArgs>(
      args?: Subset<T, ProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramAggregateArgs>(args: Subset<T, ProgramAggregateArgs>): Prisma.PrismaPromise<GetProgramAggregateType<T>>

    /**
     * Group by Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramGroupByArgs['orderBy'] }
        : { orderBy?: ProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Program model
   */
  readonly fields: ProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Program.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignments<T extends Program$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Program$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends Program$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Program$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramAuditPayload<ExtArgs>, T, "findMany"> | Null>
    blocks<T extends Program$blocksArgs<ExtArgs> = {}>(args?: Subset<T, Program$blocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramBlockPayload<ExtArgs>, T, "findMany"> | Null>
    coach<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Program model
   */ 
  interface ProgramFieldRefs {
    readonly id: FieldRef<"Program", 'String'>
    readonly title: FieldRef<"Program", 'String'>
    readonly description: FieldRef<"Program", 'String'>
    readonly coachId: FieldRef<"Program", 'String'>
    readonly ownerId: FieldRef<"Program", 'String'>
    readonly isDraft: FieldRef<"Program", 'Boolean'>
    readonly data: FieldRef<"Program", 'Json'>
    readonly createdAt: FieldRef<"Program", 'DateTime'>
    readonly updatedAt: FieldRef<"Program", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Program findUnique
   */
  export type ProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findUniqueOrThrow
   */
  export type ProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findFirst
   */
  export type ProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findFirstOrThrow
   */
  export type ProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findMany
   */
  export type ProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Programs to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program create
   */
  export type ProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a Program.
     */
    data: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
  }

  /**
   * Program createMany
   */
  export type ProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Program createManyAndReturn
   */
  export type ProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Program update
   */
  export type ProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a Program.
     */
    data: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
    /**
     * Choose, which Program to update.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program updateMany
   */
  export type ProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
  }

  /**
   * Program upsert
   */
  export type ProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the Program to update in case it exists.
     */
    where: ProgramWhereUniqueInput
    /**
     * In case the Program found by the `where` argument doesn't exist, create a new Program with this data.
     */
    create: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
    /**
     * In case the Program was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
  }

  /**
   * Program delete
   */
  export type ProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter which Program to delete.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program deleteMany
   */
  export type ProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programs to delete
     */
    where?: ProgramWhereInput
  }

  /**
   * Program.assignments
   */
  export type Program$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAssignment
     */
    select?: ProgramAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAssignmentInclude<ExtArgs> | null
    where?: ProgramAssignmentWhereInput
    orderBy?: ProgramAssignmentOrderByWithRelationInput | ProgramAssignmentOrderByWithRelationInput[]
    cursor?: ProgramAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramAssignmentScalarFieldEnum | ProgramAssignmentScalarFieldEnum[]
  }

  /**
   * Program.auditLogs
   */
  export type Program$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAudit
     */
    select?: ProgramAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAuditInclude<ExtArgs> | null
    where?: ProgramAuditWhereInput
    orderBy?: ProgramAuditOrderByWithRelationInput | ProgramAuditOrderByWithRelationInput[]
    cursor?: ProgramAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramAuditScalarFieldEnum | ProgramAuditScalarFieldEnum[]
  }

  /**
   * Program.blocks
   */
  export type Program$blocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBlock
     */
    select?: ProgramBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBlockInclude<ExtArgs> | null
    where?: ProgramBlockWhereInput
    orderBy?: ProgramBlockOrderByWithRelationInput | ProgramBlockOrderByWithRelationInput[]
    cursor?: ProgramBlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramBlockScalarFieldEnum | ProgramBlockScalarFieldEnum[]
  }

  /**
   * Program without action
   */
  export type ProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
  }


  /**
   * Model ProgramBlock
   */

  export type AggregateProgramBlock = {
    _count: ProgramBlockCountAggregateOutputType | null
    _avg: ProgramBlockAvgAggregateOutputType | null
    _sum: ProgramBlockSumAggregateOutputType | null
    _min: ProgramBlockMinAggregateOutputType | null
    _max: ProgramBlockMaxAggregateOutputType | null
  }

  export type ProgramBlockAvgAggregateOutputType = {
    position: number | null
  }

  export type ProgramBlockSumAggregateOutputType = {
    position: number | null
  }

  export type ProgramBlockMinAggregateOutputType = {
    id: string | null
    programId: string | null
    title: string | null
    position: number | null
    notes: string | null
  }

  export type ProgramBlockMaxAggregateOutputType = {
    id: string | null
    programId: string | null
    title: string | null
    position: number | null
    notes: string | null
  }

  export type ProgramBlockCountAggregateOutputType = {
    id: number
    programId: number
    title: number
    position: number
    notes: number
    _all: number
  }


  export type ProgramBlockAvgAggregateInputType = {
    position?: true
  }

  export type ProgramBlockSumAggregateInputType = {
    position?: true
  }

  export type ProgramBlockMinAggregateInputType = {
    id?: true
    programId?: true
    title?: true
    position?: true
    notes?: true
  }

  export type ProgramBlockMaxAggregateInputType = {
    id?: true
    programId?: true
    title?: true
    position?: true
    notes?: true
  }

  export type ProgramBlockCountAggregateInputType = {
    id?: true
    programId?: true
    title?: true
    position?: true
    notes?: true
    _all?: true
  }

  export type ProgramBlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramBlock to aggregate.
     */
    where?: ProgramBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramBlocks to fetch.
     */
    orderBy?: ProgramBlockOrderByWithRelationInput | ProgramBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgramBlocks
    **/
    _count?: true | ProgramBlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramBlockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramBlockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramBlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramBlockMaxAggregateInputType
  }

  export type GetProgramBlockAggregateType<T extends ProgramBlockAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramBlock[P]>
      : GetScalarType<T[P], AggregateProgramBlock[P]>
  }




  export type ProgramBlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramBlockWhereInput
    orderBy?: ProgramBlockOrderByWithAggregationInput | ProgramBlockOrderByWithAggregationInput[]
    by: ProgramBlockScalarFieldEnum[] | ProgramBlockScalarFieldEnum
    having?: ProgramBlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramBlockCountAggregateInputType | true
    _avg?: ProgramBlockAvgAggregateInputType
    _sum?: ProgramBlockSumAggregateInputType
    _min?: ProgramBlockMinAggregateInputType
    _max?: ProgramBlockMaxAggregateInputType
  }

  export type ProgramBlockGroupByOutputType = {
    id: string
    programId: string
    title: string | null
    position: number
    notes: string | null
    _count: ProgramBlockCountAggregateOutputType | null
    _avg: ProgramBlockAvgAggregateOutputType | null
    _sum: ProgramBlockSumAggregateOutputType | null
    _min: ProgramBlockMinAggregateOutputType | null
    _max: ProgramBlockMaxAggregateOutputType | null
  }

  type GetProgramBlockGroupByPayload<T extends ProgramBlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramBlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramBlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramBlockGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramBlockGroupByOutputType[P]>
        }
      >
    >


  export type ProgramBlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    title?: boolean
    position?: boolean
    notes?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    weeks?: boolean | ProgramBlock$weeksArgs<ExtArgs>
    _count?: boolean | ProgramBlockCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programBlock"]>

  export type ProgramBlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    title?: boolean
    position?: boolean
    notes?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programBlock"]>

  export type ProgramBlockSelectScalar = {
    id?: boolean
    programId?: boolean
    title?: boolean
    position?: boolean
    notes?: boolean
  }

  export type ProgramBlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    weeks?: boolean | ProgramBlock$weeksArgs<ExtArgs>
    _count?: boolean | ProgramBlockCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProgramBlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }

  export type $ProgramBlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgramBlock"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs>
      weeks: Prisma.$WeekPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      programId: string
      title: string | null
      position: number
      notes: string | null
    }, ExtArgs["result"]["programBlock"]>
    composites: {}
  }

  type ProgramBlockGetPayload<S extends boolean | null | undefined | ProgramBlockDefaultArgs> = $Result.GetResult<Prisma.$ProgramBlockPayload, S>

  type ProgramBlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgramBlockFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgramBlockCountAggregateInputType | true
    }

  export interface ProgramBlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgramBlock'], meta: { name: 'ProgramBlock' } }
    /**
     * Find zero or one ProgramBlock that matches the filter.
     * @param {ProgramBlockFindUniqueArgs} args - Arguments to find a ProgramBlock
     * @example
     * // Get one ProgramBlock
     * const programBlock = await prisma.programBlock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramBlockFindUniqueArgs>(args: SelectSubset<T, ProgramBlockFindUniqueArgs<ExtArgs>>): Prisma__ProgramBlockClient<$Result.GetResult<Prisma.$ProgramBlockPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProgramBlock that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgramBlockFindUniqueOrThrowArgs} args - Arguments to find a ProgramBlock
     * @example
     * // Get one ProgramBlock
     * const programBlock = await prisma.programBlock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramBlockFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramBlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramBlockClient<$Result.GetResult<Prisma.$ProgramBlockPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProgramBlock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramBlockFindFirstArgs} args - Arguments to find a ProgramBlock
     * @example
     * // Get one ProgramBlock
     * const programBlock = await prisma.programBlock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramBlockFindFirstArgs>(args?: SelectSubset<T, ProgramBlockFindFirstArgs<ExtArgs>>): Prisma__ProgramBlockClient<$Result.GetResult<Prisma.$ProgramBlockPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProgramBlock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramBlockFindFirstOrThrowArgs} args - Arguments to find a ProgramBlock
     * @example
     * // Get one ProgramBlock
     * const programBlock = await prisma.programBlock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramBlockFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramBlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramBlockClient<$Result.GetResult<Prisma.$ProgramBlockPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProgramBlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramBlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramBlocks
     * const programBlocks = await prisma.programBlock.findMany()
     * 
     * // Get first 10 ProgramBlocks
     * const programBlocks = await prisma.programBlock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programBlockWithIdOnly = await prisma.programBlock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramBlockFindManyArgs>(args?: SelectSubset<T, ProgramBlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramBlockPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProgramBlock.
     * @param {ProgramBlockCreateArgs} args - Arguments to create a ProgramBlock.
     * @example
     * // Create one ProgramBlock
     * const ProgramBlock = await prisma.programBlock.create({
     *   data: {
     *     // ... data to create a ProgramBlock
     *   }
     * })
     * 
     */
    create<T extends ProgramBlockCreateArgs>(args: SelectSubset<T, ProgramBlockCreateArgs<ExtArgs>>): Prisma__ProgramBlockClient<$Result.GetResult<Prisma.$ProgramBlockPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProgramBlocks.
     * @param {ProgramBlockCreateManyArgs} args - Arguments to create many ProgramBlocks.
     * @example
     * // Create many ProgramBlocks
     * const programBlock = await prisma.programBlock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramBlockCreateManyArgs>(args?: SelectSubset<T, ProgramBlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgramBlocks and returns the data saved in the database.
     * @param {ProgramBlockCreateManyAndReturnArgs} args - Arguments to create many ProgramBlocks.
     * @example
     * // Create many ProgramBlocks
     * const programBlock = await prisma.programBlock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgramBlocks and only return the `id`
     * const programBlockWithIdOnly = await prisma.programBlock.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramBlockCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramBlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramBlockPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProgramBlock.
     * @param {ProgramBlockDeleteArgs} args - Arguments to delete one ProgramBlock.
     * @example
     * // Delete one ProgramBlock
     * const ProgramBlock = await prisma.programBlock.delete({
     *   where: {
     *     // ... filter to delete one ProgramBlock
     *   }
     * })
     * 
     */
    delete<T extends ProgramBlockDeleteArgs>(args: SelectSubset<T, ProgramBlockDeleteArgs<ExtArgs>>): Prisma__ProgramBlockClient<$Result.GetResult<Prisma.$ProgramBlockPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProgramBlock.
     * @param {ProgramBlockUpdateArgs} args - Arguments to update one ProgramBlock.
     * @example
     * // Update one ProgramBlock
     * const programBlock = await prisma.programBlock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramBlockUpdateArgs>(args: SelectSubset<T, ProgramBlockUpdateArgs<ExtArgs>>): Prisma__ProgramBlockClient<$Result.GetResult<Prisma.$ProgramBlockPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProgramBlocks.
     * @param {ProgramBlockDeleteManyArgs} args - Arguments to filter ProgramBlocks to delete.
     * @example
     * // Delete a few ProgramBlocks
     * const { count } = await prisma.programBlock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramBlockDeleteManyArgs>(args?: SelectSubset<T, ProgramBlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramBlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramBlocks
     * const programBlock = await prisma.programBlock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramBlockUpdateManyArgs>(args: SelectSubset<T, ProgramBlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProgramBlock.
     * @param {ProgramBlockUpsertArgs} args - Arguments to update or create a ProgramBlock.
     * @example
     * // Update or create a ProgramBlock
     * const programBlock = await prisma.programBlock.upsert({
     *   create: {
     *     // ... data to create a ProgramBlock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramBlock we want to update
     *   }
     * })
     */
    upsert<T extends ProgramBlockUpsertArgs>(args: SelectSubset<T, ProgramBlockUpsertArgs<ExtArgs>>): Prisma__ProgramBlockClient<$Result.GetResult<Prisma.$ProgramBlockPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProgramBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramBlockCountArgs} args - Arguments to filter ProgramBlocks to count.
     * @example
     * // Count the number of ProgramBlocks
     * const count = await prisma.programBlock.count({
     *   where: {
     *     // ... the filter for the ProgramBlocks we want to count
     *   }
     * })
    **/
    count<T extends ProgramBlockCountArgs>(
      args?: Subset<T, ProgramBlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramBlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramBlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramBlockAggregateArgs>(args: Subset<T, ProgramBlockAggregateArgs>): Prisma.PrismaPromise<GetProgramBlockAggregateType<T>>

    /**
     * Group by ProgramBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramBlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramBlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramBlockGroupByArgs['orderBy'] }
        : { orderBy?: ProgramBlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramBlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgramBlock model
   */
  readonly fields: ProgramBlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgramBlock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramBlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    weeks<T extends ProgramBlock$weeksArgs<ExtArgs> = {}>(args?: Subset<T, ProgramBlock$weeksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgramBlock model
   */ 
  interface ProgramBlockFieldRefs {
    readonly id: FieldRef<"ProgramBlock", 'String'>
    readonly programId: FieldRef<"ProgramBlock", 'String'>
    readonly title: FieldRef<"ProgramBlock", 'String'>
    readonly position: FieldRef<"ProgramBlock", 'Int'>
    readonly notes: FieldRef<"ProgramBlock", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProgramBlock findUnique
   */
  export type ProgramBlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBlock
     */
    select?: ProgramBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBlockInclude<ExtArgs> | null
    /**
     * Filter, which ProgramBlock to fetch.
     */
    where: ProgramBlockWhereUniqueInput
  }

  /**
   * ProgramBlock findUniqueOrThrow
   */
  export type ProgramBlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBlock
     */
    select?: ProgramBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBlockInclude<ExtArgs> | null
    /**
     * Filter, which ProgramBlock to fetch.
     */
    where: ProgramBlockWhereUniqueInput
  }

  /**
   * ProgramBlock findFirst
   */
  export type ProgramBlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBlock
     */
    select?: ProgramBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBlockInclude<ExtArgs> | null
    /**
     * Filter, which ProgramBlock to fetch.
     */
    where?: ProgramBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramBlocks to fetch.
     */
    orderBy?: ProgramBlockOrderByWithRelationInput | ProgramBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramBlocks.
     */
    cursor?: ProgramBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramBlocks.
     */
    distinct?: ProgramBlockScalarFieldEnum | ProgramBlockScalarFieldEnum[]
  }

  /**
   * ProgramBlock findFirstOrThrow
   */
  export type ProgramBlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBlock
     */
    select?: ProgramBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBlockInclude<ExtArgs> | null
    /**
     * Filter, which ProgramBlock to fetch.
     */
    where?: ProgramBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramBlocks to fetch.
     */
    orderBy?: ProgramBlockOrderByWithRelationInput | ProgramBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramBlocks.
     */
    cursor?: ProgramBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramBlocks.
     */
    distinct?: ProgramBlockScalarFieldEnum | ProgramBlockScalarFieldEnum[]
  }

  /**
   * ProgramBlock findMany
   */
  export type ProgramBlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBlock
     */
    select?: ProgramBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBlockInclude<ExtArgs> | null
    /**
     * Filter, which ProgramBlocks to fetch.
     */
    where?: ProgramBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramBlocks to fetch.
     */
    orderBy?: ProgramBlockOrderByWithRelationInput | ProgramBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgramBlocks.
     */
    cursor?: ProgramBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramBlocks.
     */
    skip?: number
    distinct?: ProgramBlockScalarFieldEnum | ProgramBlockScalarFieldEnum[]
  }

  /**
   * ProgramBlock create
   */
  export type ProgramBlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBlock
     */
    select?: ProgramBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBlockInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgramBlock.
     */
    data: XOR<ProgramBlockCreateInput, ProgramBlockUncheckedCreateInput>
  }

  /**
   * ProgramBlock createMany
   */
  export type ProgramBlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgramBlocks.
     */
    data: ProgramBlockCreateManyInput | ProgramBlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgramBlock createManyAndReturn
   */
  export type ProgramBlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBlock
     */
    select?: ProgramBlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProgramBlocks.
     */
    data: ProgramBlockCreateManyInput | ProgramBlockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBlockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgramBlock update
   */
  export type ProgramBlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBlock
     */
    select?: ProgramBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBlockInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgramBlock.
     */
    data: XOR<ProgramBlockUpdateInput, ProgramBlockUncheckedUpdateInput>
    /**
     * Choose, which ProgramBlock to update.
     */
    where: ProgramBlockWhereUniqueInput
  }

  /**
   * ProgramBlock updateMany
   */
  export type ProgramBlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgramBlocks.
     */
    data: XOR<ProgramBlockUpdateManyMutationInput, ProgramBlockUncheckedUpdateManyInput>
    /**
     * Filter which ProgramBlocks to update
     */
    where?: ProgramBlockWhereInput
  }

  /**
   * ProgramBlock upsert
   */
  export type ProgramBlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBlock
     */
    select?: ProgramBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBlockInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgramBlock to update in case it exists.
     */
    where: ProgramBlockWhereUniqueInput
    /**
     * In case the ProgramBlock found by the `where` argument doesn't exist, create a new ProgramBlock with this data.
     */
    create: XOR<ProgramBlockCreateInput, ProgramBlockUncheckedCreateInput>
    /**
     * In case the ProgramBlock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramBlockUpdateInput, ProgramBlockUncheckedUpdateInput>
  }

  /**
   * ProgramBlock delete
   */
  export type ProgramBlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBlock
     */
    select?: ProgramBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBlockInclude<ExtArgs> | null
    /**
     * Filter which ProgramBlock to delete.
     */
    where: ProgramBlockWhereUniqueInput
  }

  /**
   * ProgramBlock deleteMany
   */
  export type ProgramBlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramBlocks to delete
     */
    where?: ProgramBlockWhereInput
  }

  /**
   * ProgramBlock.weeks
   */
  export type ProgramBlock$weeksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Week
     */
    select?: WeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekInclude<ExtArgs> | null
    where?: WeekWhereInput
    orderBy?: WeekOrderByWithRelationInput | WeekOrderByWithRelationInput[]
    cursor?: WeekWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeekScalarFieldEnum | WeekScalarFieldEnum[]
  }

  /**
   * ProgramBlock without action
   */
  export type ProgramBlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBlock
     */
    select?: ProgramBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBlockInclude<ExtArgs> | null
  }


  /**
   * Model Week
   */

  export type AggregateWeek = {
    _count: WeekCountAggregateOutputType | null
    _avg: WeekAvgAggregateOutputType | null
    _sum: WeekSumAggregateOutputType | null
    _min: WeekMinAggregateOutputType | null
    _max: WeekMaxAggregateOutputType | null
  }

  export type WeekAvgAggregateOutputType = {
    weekNumber: number | null
    position: number | null
  }

  export type WeekSumAggregateOutputType = {
    weekNumber: number | null
    position: number | null
  }

  export type WeekMinAggregateOutputType = {
    id: string | null
    blockId: string | null
    weekNumber: number | null
    position: number | null
  }

  export type WeekMaxAggregateOutputType = {
    id: string | null
    blockId: string | null
    weekNumber: number | null
    position: number | null
  }

  export type WeekCountAggregateOutputType = {
    id: number
    blockId: number
    weekNumber: number
    position: number
    _all: number
  }


  export type WeekAvgAggregateInputType = {
    weekNumber?: true
    position?: true
  }

  export type WeekSumAggregateInputType = {
    weekNumber?: true
    position?: true
  }

  export type WeekMinAggregateInputType = {
    id?: true
    blockId?: true
    weekNumber?: true
    position?: true
  }

  export type WeekMaxAggregateInputType = {
    id?: true
    blockId?: true
    weekNumber?: true
    position?: true
  }

  export type WeekCountAggregateInputType = {
    id?: true
    blockId?: true
    weekNumber?: true
    position?: true
    _all?: true
  }

  export type WeekAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Week to aggregate.
     */
    where?: WeekWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weeks to fetch.
     */
    orderBy?: WeekOrderByWithRelationInput | WeekOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeekWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weeks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weeks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Weeks
    **/
    _count?: true | WeekCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeekAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeekSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeekMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeekMaxAggregateInputType
  }

  export type GetWeekAggregateType<T extends WeekAggregateArgs> = {
        [P in keyof T & keyof AggregateWeek]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeek[P]>
      : GetScalarType<T[P], AggregateWeek[P]>
  }




  export type WeekGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeekWhereInput
    orderBy?: WeekOrderByWithAggregationInput | WeekOrderByWithAggregationInput[]
    by: WeekScalarFieldEnum[] | WeekScalarFieldEnum
    having?: WeekScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeekCountAggregateInputType | true
    _avg?: WeekAvgAggregateInputType
    _sum?: WeekSumAggregateInputType
    _min?: WeekMinAggregateInputType
    _max?: WeekMaxAggregateInputType
  }

  export type WeekGroupByOutputType = {
    id: string
    blockId: string
    weekNumber: number
    position: number
    _count: WeekCountAggregateOutputType | null
    _avg: WeekAvgAggregateOutputType | null
    _sum: WeekSumAggregateOutputType | null
    _min: WeekMinAggregateOutputType | null
    _max: WeekMaxAggregateOutputType | null
  }

  type GetWeekGroupByPayload<T extends WeekGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeekGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeekGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeekGroupByOutputType[P]>
            : GetScalarType<T[P], WeekGroupByOutputType[P]>
        }
      >
    >


  export type WeekSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockId?: boolean
    weekNumber?: boolean
    position?: boolean
    sessions?: boolean | Week$sessionsArgs<ExtArgs>
    block?: boolean | ProgramBlockDefaultArgs<ExtArgs>
    _count?: boolean | WeekCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["week"]>

  export type WeekSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockId?: boolean
    weekNumber?: boolean
    position?: boolean
    block?: boolean | ProgramBlockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["week"]>

  export type WeekSelectScalar = {
    id?: boolean
    blockId?: boolean
    weekNumber?: boolean
    position?: boolean
  }

  export type WeekInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | Week$sessionsArgs<ExtArgs>
    block?: boolean | ProgramBlockDefaultArgs<ExtArgs>
    _count?: boolean | WeekCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WeekIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    block?: boolean | ProgramBlockDefaultArgs<ExtArgs>
  }

  export type $WeekPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Week"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      block: Prisma.$ProgramBlockPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      blockId: string
      weekNumber: number
      position: number
    }, ExtArgs["result"]["week"]>
    composites: {}
  }

  type WeekGetPayload<S extends boolean | null | undefined | WeekDefaultArgs> = $Result.GetResult<Prisma.$WeekPayload, S>

  type WeekCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WeekFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WeekCountAggregateInputType | true
    }

  export interface WeekDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Week'], meta: { name: 'Week' } }
    /**
     * Find zero or one Week that matches the filter.
     * @param {WeekFindUniqueArgs} args - Arguments to find a Week
     * @example
     * // Get one Week
     * const week = await prisma.week.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeekFindUniqueArgs>(args: SelectSubset<T, WeekFindUniqueArgs<ExtArgs>>): Prisma__WeekClient<$Result.GetResult<Prisma.$WeekPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Week that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WeekFindUniqueOrThrowArgs} args - Arguments to find a Week
     * @example
     * // Get one Week
     * const week = await prisma.week.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeekFindUniqueOrThrowArgs>(args: SelectSubset<T, WeekFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeekClient<$Result.GetResult<Prisma.$WeekPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Week that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekFindFirstArgs} args - Arguments to find a Week
     * @example
     * // Get one Week
     * const week = await prisma.week.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeekFindFirstArgs>(args?: SelectSubset<T, WeekFindFirstArgs<ExtArgs>>): Prisma__WeekClient<$Result.GetResult<Prisma.$WeekPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Week that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekFindFirstOrThrowArgs} args - Arguments to find a Week
     * @example
     * // Get one Week
     * const week = await prisma.week.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeekFindFirstOrThrowArgs>(args?: SelectSubset<T, WeekFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeekClient<$Result.GetResult<Prisma.$WeekPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Weeks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weeks
     * const weeks = await prisma.week.findMany()
     * 
     * // Get first 10 Weeks
     * const weeks = await prisma.week.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weekWithIdOnly = await prisma.week.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeekFindManyArgs>(args?: SelectSubset<T, WeekFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Week.
     * @param {WeekCreateArgs} args - Arguments to create a Week.
     * @example
     * // Create one Week
     * const Week = await prisma.week.create({
     *   data: {
     *     // ... data to create a Week
     *   }
     * })
     * 
     */
    create<T extends WeekCreateArgs>(args: SelectSubset<T, WeekCreateArgs<ExtArgs>>): Prisma__WeekClient<$Result.GetResult<Prisma.$WeekPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Weeks.
     * @param {WeekCreateManyArgs} args - Arguments to create many Weeks.
     * @example
     * // Create many Weeks
     * const week = await prisma.week.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeekCreateManyArgs>(args?: SelectSubset<T, WeekCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Weeks and returns the data saved in the database.
     * @param {WeekCreateManyAndReturnArgs} args - Arguments to create many Weeks.
     * @example
     * // Create many Weeks
     * const week = await prisma.week.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Weeks and only return the `id`
     * const weekWithIdOnly = await prisma.week.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeekCreateManyAndReturnArgs>(args?: SelectSubset<T, WeekCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Week.
     * @param {WeekDeleteArgs} args - Arguments to delete one Week.
     * @example
     * // Delete one Week
     * const Week = await prisma.week.delete({
     *   where: {
     *     // ... filter to delete one Week
     *   }
     * })
     * 
     */
    delete<T extends WeekDeleteArgs>(args: SelectSubset<T, WeekDeleteArgs<ExtArgs>>): Prisma__WeekClient<$Result.GetResult<Prisma.$WeekPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Week.
     * @param {WeekUpdateArgs} args - Arguments to update one Week.
     * @example
     * // Update one Week
     * const week = await prisma.week.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeekUpdateArgs>(args: SelectSubset<T, WeekUpdateArgs<ExtArgs>>): Prisma__WeekClient<$Result.GetResult<Prisma.$WeekPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Weeks.
     * @param {WeekDeleteManyArgs} args - Arguments to filter Weeks to delete.
     * @example
     * // Delete a few Weeks
     * const { count } = await prisma.week.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeekDeleteManyArgs>(args?: SelectSubset<T, WeekDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weeks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weeks
     * const week = await prisma.week.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeekUpdateManyArgs>(args: SelectSubset<T, WeekUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Week.
     * @param {WeekUpsertArgs} args - Arguments to update or create a Week.
     * @example
     * // Update or create a Week
     * const week = await prisma.week.upsert({
     *   create: {
     *     // ... data to create a Week
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Week we want to update
     *   }
     * })
     */
    upsert<T extends WeekUpsertArgs>(args: SelectSubset<T, WeekUpsertArgs<ExtArgs>>): Prisma__WeekClient<$Result.GetResult<Prisma.$WeekPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Weeks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekCountArgs} args - Arguments to filter Weeks to count.
     * @example
     * // Count the number of Weeks
     * const count = await prisma.week.count({
     *   where: {
     *     // ... the filter for the Weeks we want to count
     *   }
     * })
    **/
    count<T extends WeekCountArgs>(
      args?: Subset<T, WeekCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeekCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Week.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeekAggregateArgs>(args: Subset<T, WeekAggregateArgs>): Prisma.PrismaPromise<GetWeekAggregateType<T>>

    /**
     * Group by Week.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeekGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeekGroupByArgs['orderBy'] }
        : { orderBy?: WeekGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeekGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeekGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Week model
   */
  readonly fields: WeekFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Week.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeekClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends Week$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Week$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    block<T extends ProgramBlockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramBlockDefaultArgs<ExtArgs>>): Prisma__ProgramBlockClient<$Result.GetResult<Prisma.$ProgramBlockPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Week model
   */ 
  interface WeekFieldRefs {
    readonly id: FieldRef<"Week", 'String'>
    readonly blockId: FieldRef<"Week", 'String'>
    readonly weekNumber: FieldRef<"Week", 'Int'>
    readonly position: FieldRef<"Week", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Week findUnique
   */
  export type WeekFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Week
     */
    select?: WeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekInclude<ExtArgs> | null
    /**
     * Filter, which Week to fetch.
     */
    where: WeekWhereUniqueInput
  }

  /**
   * Week findUniqueOrThrow
   */
  export type WeekFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Week
     */
    select?: WeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekInclude<ExtArgs> | null
    /**
     * Filter, which Week to fetch.
     */
    where: WeekWhereUniqueInput
  }

  /**
   * Week findFirst
   */
  export type WeekFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Week
     */
    select?: WeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekInclude<ExtArgs> | null
    /**
     * Filter, which Week to fetch.
     */
    where?: WeekWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weeks to fetch.
     */
    orderBy?: WeekOrderByWithRelationInput | WeekOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weeks.
     */
    cursor?: WeekWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weeks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weeks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weeks.
     */
    distinct?: WeekScalarFieldEnum | WeekScalarFieldEnum[]
  }

  /**
   * Week findFirstOrThrow
   */
  export type WeekFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Week
     */
    select?: WeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekInclude<ExtArgs> | null
    /**
     * Filter, which Week to fetch.
     */
    where?: WeekWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weeks to fetch.
     */
    orderBy?: WeekOrderByWithRelationInput | WeekOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weeks.
     */
    cursor?: WeekWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weeks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weeks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weeks.
     */
    distinct?: WeekScalarFieldEnum | WeekScalarFieldEnum[]
  }

  /**
   * Week findMany
   */
  export type WeekFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Week
     */
    select?: WeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekInclude<ExtArgs> | null
    /**
     * Filter, which Weeks to fetch.
     */
    where?: WeekWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weeks to fetch.
     */
    orderBy?: WeekOrderByWithRelationInput | WeekOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Weeks.
     */
    cursor?: WeekWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weeks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weeks.
     */
    skip?: number
    distinct?: WeekScalarFieldEnum | WeekScalarFieldEnum[]
  }

  /**
   * Week create
   */
  export type WeekCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Week
     */
    select?: WeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekInclude<ExtArgs> | null
    /**
     * The data needed to create a Week.
     */
    data: XOR<WeekCreateInput, WeekUncheckedCreateInput>
  }

  /**
   * Week createMany
   */
  export type WeekCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Weeks.
     */
    data: WeekCreateManyInput | WeekCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Week createManyAndReturn
   */
  export type WeekCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Week
     */
    select?: WeekSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Weeks.
     */
    data: WeekCreateManyInput | WeekCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Week update
   */
  export type WeekUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Week
     */
    select?: WeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekInclude<ExtArgs> | null
    /**
     * The data needed to update a Week.
     */
    data: XOR<WeekUpdateInput, WeekUncheckedUpdateInput>
    /**
     * Choose, which Week to update.
     */
    where: WeekWhereUniqueInput
  }

  /**
   * Week updateMany
   */
  export type WeekUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Weeks.
     */
    data: XOR<WeekUpdateManyMutationInput, WeekUncheckedUpdateManyInput>
    /**
     * Filter which Weeks to update
     */
    where?: WeekWhereInput
  }

  /**
   * Week upsert
   */
  export type WeekUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Week
     */
    select?: WeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekInclude<ExtArgs> | null
    /**
     * The filter to search for the Week to update in case it exists.
     */
    where: WeekWhereUniqueInput
    /**
     * In case the Week found by the `where` argument doesn't exist, create a new Week with this data.
     */
    create: XOR<WeekCreateInput, WeekUncheckedCreateInput>
    /**
     * In case the Week was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeekUpdateInput, WeekUncheckedUpdateInput>
  }

  /**
   * Week delete
   */
  export type WeekDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Week
     */
    select?: WeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekInclude<ExtArgs> | null
    /**
     * Filter which Week to delete.
     */
    where: WeekWhereUniqueInput
  }

  /**
   * Week deleteMany
   */
  export type WeekDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weeks to delete
     */
    where?: WeekWhereInput
  }

  /**
   * Week.sessions
   */
  export type Week$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Week without action
   */
  export type WeekDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Week
     */
    select?: WeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    position: number | null
  }

  export type SessionSumAggregateOutputType = {
    position: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    weekId: string | null
    title: string | null
    notes: string | null
    date: Date | null
    position: number | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    weekId: string | null
    title: string | null
    notes: string | null
    date: Date | null
    position: number | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    weekId: number
    title: number
    notes: number
    date: number
    position: number
    data: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    position?: true
  }

  export type SessionSumAggregateInputType = {
    position?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    weekId?: true
    title?: true
    notes?: true
    date?: true
    position?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    weekId?: true
    title?: true
    notes?: true
    date?: true
    position?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    weekId?: true
    title?: true
    notes?: true
    date?: true
    position?: true
    data?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    weekId: string
    title: string | null
    notes: string | null
    date: Date | null
    position: number
    data: JsonValue | null
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    weekId?: boolean
    title?: boolean
    notes?: boolean
    date?: boolean
    position?: boolean
    data?: boolean
    exercises?: boolean | Session$exercisesArgs<ExtArgs>
    progress?: boolean | Session$progressArgs<ExtArgs>
    week?: boolean | WeekDefaultArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    weekId?: boolean
    title?: boolean
    notes?: boolean
    date?: boolean
    position?: boolean
    data?: boolean
    week?: boolean | WeekDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    weekId?: boolean
    title?: boolean
    notes?: boolean
    date?: boolean
    position?: boolean
    data?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercises?: boolean | Session$exercisesArgs<ExtArgs>
    progress?: boolean | Session$progressArgs<ExtArgs>
    week?: boolean | WeekDefaultArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    week?: boolean | WeekDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      exercises: Prisma.$SessionExercisePayload<ExtArgs>[]
      progress: Prisma.$SessionProgressPayload<ExtArgs>[]
      week: Prisma.$WeekPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      weekId: string
      title: string | null
      notes: string | null
      date: Date | null
      position: number
      data: Prisma.JsonValue | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exercises<T extends Session$exercisesArgs<ExtArgs> = {}>(args?: Subset<T, Session$exercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionExercisePayload<ExtArgs>, T, "findMany"> | Null>
    progress<T extends Session$progressArgs<ExtArgs> = {}>(args?: Subset<T, Session$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionProgressPayload<ExtArgs>, T, "findMany"> | Null>
    week<T extends WeekDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WeekDefaultArgs<ExtArgs>>): Prisma__WeekClient<$Result.GetResult<Prisma.$WeekPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly weekId: FieldRef<"Session", 'String'>
    readonly title: FieldRef<"Session", 'String'>
    readonly notes: FieldRef<"Session", 'String'>
    readonly date: FieldRef<"Session", 'DateTime'>
    readonly position: FieldRef<"Session", 'Int'>
    readonly data: FieldRef<"Session", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session.exercises
   */
  export type Session$exercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExercise
     */
    select?: SessionExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExerciseInclude<ExtArgs> | null
    where?: SessionExerciseWhereInput
    orderBy?: SessionExerciseOrderByWithRelationInput | SessionExerciseOrderByWithRelationInput[]
    cursor?: SessionExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionExerciseScalarFieldEnum | SessionExerciseScalarFieldEnum[]
  }

  /**
   * Session.progress
   */
  export type Session$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionProgress
     */
    select?: SessionProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionProgressInclude<ExtArgs> | null
    where?: SessionProgressWhereInput
    orderBy?: SessionProgressOrderByWithRelationInput | SessionProgressOrderByWithRelationInput[]
    cursor?: SessionProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionProgressScalarFieldEnum | SessionProgressScalarFieldEnum[]
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model SessionExercise
   */

  export type AggregateSessionExercise = {
    _count: SessionExerciseCountAggregateOutputType | null
    _avg: SessionExerciseAvgAggregateOutputType | null
    _sum: SessionExerciseSumAggregateOutputType | null
    _min: SessionExerciseMinAggregateOutputType | null
    _max: SessionExerciseMaxAggregateOutputType | null
  }

  export type SessionExerciseAvgAggregateOutputType = {
    position: number | null
  }

  export type SessionExerciseSumAggregateOutputType = {
    position: number | null
  }

  export type SessionExerciseMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    exerciseId: string | null
    position: number | null
  }

  export type SessionExerciseMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    exerciseId: string | null
    position: number | null
  }

  export type SessionExerciseCountAggregateOutputType = {
    id: number
    sessionId: number
    exerciseId: number
    config: number
    position: number
    _all: number
  }


  export type SessionExerciseAvgAggregateInputType = {
    position?: true
  }

  export type SessionExerciseSumAggregateInputType = {
    position?: true
  }

  export type SessionExerciseMinAggregateInputType = {
    id?: true
    sessionId?: true
    exerciseId?: true
    position?: true
  }

  export type SessionExerciseMaxAggregateInputType = {
    id?: true
    sessionId?: true
    exerciseId?: true
    position?: true
  }

  export type SessionExerciseCountAggregateInputType = {
    id?: true
    sessionId?: true
    exerciseId?: true
    config?: true
    position?: true
    _all?: true
  }

  export type SessionExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionExercise to aggregate.
     */
    where?: SessionExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionExercises to fetch.
     */
    orderBy?: SessionExerciseOrderByWithRelationInput | SessionExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionExercises
    **/
    _count?: true | SessionExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionExerciseMaxAggregateInputType
  }

  export type GetSessionExerciseAggregateType<T extends SessionExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionExercise[P]>
      : GetScalarType<T[P], AggregateSessionExercise[P]>
  }




  export type SessionExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionExerciseWhereInput
    orderBy?: SessionExerciseOrderByWithAggregationInput | SessionExerciseOrderByWithAggregationInput[]
    by: SessionExerciseScalarFieldEnum[] | SessionExerciseScalarFieldEnum
    having?: SessionExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionExerciseCountAggregateInputType | true
    _avg?: SessionExerciseAvgAggregateInputType
    _sum?: SessionExerciseSumAggregateInputType
    _min?: SessionExerciseMinAggregateInputType
    _max?: SessionExerciseMaxAggregateInputType
  }

  export type SessionExerciseGroupByOutputType = {
    id: string
    sessionId: string
    exerciseId: string
    config: JsonValue | null
    position: number
    _count: SessionExerciseCountAggregateOutputType | null
    _avg: SessionExerciseAvgAggregateOutputType | null
    _sum: SessionExerciseSumAggregateOutputType | null
    _min: SessionExerciseMinAggregateOutputType | null
    _max: SessionExerciseMaxAggregateOutputType | null
  }

  type GetSessionExerciseGroupByPayload<T extends SessionExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], SessionExerciseGroupByOutputType[P]>
        }
      >
    >


  export type SessionExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    exerciseId?: boolean
    config?: boolean
    position?: boolean
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    session?: boolean | SessionDefaultArgs<ExtArgs>
    progressInstances?: boolean | SessionExercise$progressInstancesArgs<ExtArgs>
    _count?: boolean | SessionExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionExercise"]>

  export type SessionExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    exerciseId?: boolean
    config?: boolean
    position?: boolean
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionExercise"]>

  export type SessionExerciseSelectScalar = {
    id?: boolean
    sessionId?: boolean
    exerciseId?: boolean
    config?: boolean
    position?: boolean
  }

  export type SessionExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    session?: boolean | SessionDefaultArgs<ExtArgs>
    progressInstances?: boolean | SessionExercise$progressInstancesArgs<ExtArgs>
    _count?: boolean | SessionExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SessionExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }

  export type $SessionExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionExercise"
    objects: {
      exercise: Prisma.$ExercisePayload<ExtArgs>
      session: Prisma.$SessionPayload<ExtArgs>
      progressInstances: Prisma.$SessionProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      exerciseId: string
      config: Prisma.JsonValue | null
      position: number
    }, ExtArgs["result"]["sessionExercise"]>
    composites: {}
  }

  type SessionExerciseGetPayload<S extends boolean | null | undefined | SessionExerciseDefaultArgs> = $Result.GetResult<Prisma.$SessionExercisePayload, S>

  type SessionExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionExerciseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionExerciseCountAggregateInputType | true
    }

  export interface SessionExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionExercise'], meta: { name: 'SessionExercise' } }
    /**
     * Find zero or one SessionExercise that matches the filter.
     * @param {SessionExerciseFindUniqueArgs} args - Arguments to find a SessionExercise
     * @example
     * // Get one SessionExercise
     * const sessionExercise = await prisma.sessionExercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionExerciseFindUniqueArgs>(args: SelectSubset<T, SessionExerciseFindUniqueArgs<ExtArgs>>): Prisma__SessionExerciseClient<$Result.GetResult<Prisma.$SessionExercisePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SessionExercise that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionExerciseFindUniqueOrThrowArgs} args - Arguments to find a SessionExercise
     * @example
     * // Get one SessionExercise
     * const sessionExercise = await prisma.sessionExercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionExerciseClient<$Result.GetResult<Prisma.$SessionExercisePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SessionExercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionExerciseFindFirstArgs} args - Arguments to find a SessionExercise
     * @example
     * // Get one SessionExercise
     * const sessionExercise = await prisma.sessionExercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionExerciseFindFirstArgs>(args?: SelectSubset<T, SessionExerciseFindFirstArgs<ExtArgs>>): Prisma__SessionExerciseClient<$Result.GetResult<Prisma.$SessionExercisePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SessionExercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionExerciseFindFirstOrThrowArgs} args - Arguments to find a SessionExercise
     * @example
     * // Get one SessionExercise
     * const sessionExercise = await prisma.sessionExercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionExerciseClient<$Result.GetResult<Prisma.$SessionExercisePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SessionExercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionExercises
     * const sessionExercises = await prisma.sessionExercise.findMany()
     * 
     * // Get first 10 SessionExercises
     * const sessionExercises = await prisma.sessionExercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionExerciseWithIdOnly = await prisma.sessionExercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionExerciseFindManyArgs>(args?: SelectSubset<T, SessionExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionExercisePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SessionExercise.
     * @param {SessionExerciseCreateArgs} args - Arguments to create a SessionExercise.
     * @example
     * // Create one SessionExercise
     * const SessionExercise = await prisma.sessionExercise.create({
     *   data: {
     *     // ... data to create a SessionExercise
     *   }
     * })
     * 
     */
    create<T extends SessionExerciseCreateArgs>(args: SelectSubset<T, SessionExerciseCreateArgs<ExtArgs>>): Prisma__SessionExerciseClient<$Result.GetResult<Prisma.$SessionExercisePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SessionExercises.
     * @param {SessionExerciseCreateManyArgs} args - Arguments to create many SessionExercises.
     * @example
     * // Create many SessionExercises
     * const sessionExercise = await prisma.sessionExercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionExerciseCreateManyArgs>(args?: SelectSubset<T, SessionExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionExercises and returns the data saved in the database.
     * @param {SessionExerciseCreateManyAndReturnArgs} args - Arguments to create many SessionExercises.
     * @example
     * // Create many SessionExercises
     * const sessionExercise = await prisma.sessionExercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionExercises and only return the `id`
     * const sessionExerciseWithIdOnly = await prisma.sessionExercise.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionExercisePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SessionExercise.
     * @param {SessionExerciseDeleteArgs} args - Arguments to delete one SessionExercise.
     * @example
     * // Delete one SessionExercise
     * const SessionExercise = await prisma.sessionExercise.delete({
     *   where: {
     *     // ... filter to delete one SessionExercise
     *   }
     * })
     * 
     */
    delete<T extends SessionExerciseDeleteArgs>(args: SelectSubset<T, SessionExerciseDeleteArgs<ExtArgs>>): Prisma__SessionExerciseClient<$Result.GetResult<Prisma.$SessionExercisePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SessionExercise.
     * @param {SessionExerciseUpdateArgs} args - Arguments to update one SessionExercise.
     * @example
     * // Update one SessionExercise
     * const sessionExercise = await prisma.sessionExercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionExerciseUpdateArgs>(args: SelectSubset<T, SessionExerciseUpdateArgs<ExtArgs>>): Prisma__SessionExerciseClient<$Result.GetResult<Prisma.$SessionExercisePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SessionExercises.
     * @param {SessionExerciseDeleteManyArgs} args - Arguments to filter SessionExercises to delete.
     * @example
     * // Delete a few SessionExercises
     * const { count } = await prisma.sessionExercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionExerciseDeleteManyArgs>(args?: SelectSubset<T, SessionExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionExercises
     * const sessionExercise = await prisma.sessionExercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionExerciseUpdateManyArgs>(args: SelectSubset<T, SessionExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SessionExercise.
     * @param {SessionExerciseUpsertArgs} args - Arguments to update or create a SessionExercise.
     * @example
     * // Update or create a SessionExercise
     * const sessionExercise = await prisma.sessionExercise.upsert({
     *   create: {
     *     // ... data to create a SessionExercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionExercise we want to update
     *   }
     * })
     */
    upsert<T extends SessionExerciseUpsertArgs>(args: SelectSubset<T, SessionExerciseUpsertArgs<ExtArgs>>): Prisma__SessionExerciseClient<$Result.GetResult<Prisma.$SessionExercisePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SessionExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionExerciseCountArgs} args - Arguments to filter SessionExercises to count.
     * @example
     * // Count the number of SessionExercises
     * const count = await prisma.sessionExercise.count({
     *   where: {
     *     // ... the filter for the SessionExercises we want to count
     *   }
     * })
    **/
    count<T extends SessionExerciseCountArgs>(
      args?: Subset<T, SessionExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionExerciseAggregateArgs>(args: Subset<T, SessionExerciseAggregateArgs>): Prisma.PrismaPromise<GetSessionExerciseAggregateType<T>>

    /**
     * Group by SessionExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionExerciseGroupByArgs['orderBy'] }
        : { orderBy?: SessionExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionExercise model
   */
  readonly fields: SessionExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionExercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exercise<T extends ExerciseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseDefaultArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    progressInstances<T extends SessionExercise$progressInstancesArgs<ExtArgs> = {}>(args?: Subset<T, SessionExercise$progressInstancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionProgressPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionExercise model
   */ 
  interface SessionExerciseFieldRefs {
    readonly id: FieldRef<"SessionExercise", 'String'>
    readonly sessionId: FieldRef<"SessionExercise", 'String'>
    readonly exerciseId: FieldRef<"SessionExercise", 'String'>
    readonly config: FieldRef<"SessionExercise", 'Json'>
    readonly position: FieldRef<"SessionExercise", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SessionExercise findUnique
   */
  export type SessionExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExercise
     */
    select?: SessionExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExerciseInclude<ExtArgs> | null
    /**
     * Filter, which SessionExercise to fetch.
     */
    where: SessionExerciseWhereUniqueInput
  }

  /**
   * SessionExercise findUniqueOrThrow
   */
  export type SessionExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExercise
     */
    select?: SessionExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExerciseInclude<ExtArgs> | null
    /**
     * Filter, which SessionExercise to fetch.
     */
    where: SessionExerciseWhereUniqueInput
  }

  /**
   * SessionExercise findFirst
   */
  export type SessionExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExercise
     */
    select?: SessionExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExerciseInclude<ExtArgs> | null
    /**
     * Filter, which SessionExercise to fetch.
     */
    where?: SessionExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionExercises to fetch.
     */
    orderBy?: SessionExerciseOrderByWithRelationInput | SessionExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionExercises.
     */
    cursor?: SessionExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionExercises.
     */
    distinct?: SessionExerciseScalarFieldEnum | SessionExerciseScalarFieldEnum[]
  }

  /**
   * SessionExercise findFirstOrThrow
   */
  export type SessionExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExercise
     */
    select?: SessionExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExerciseInclude<ExtArgs> | null
    /**
     * Filter, which SessionExercise to fetch.
     */
    where?: SessionExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionExercises to fetch.
     */
    orderBy?: SessionExerciseOrderByWithRelationInput | SessionExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionExercises.
     */
    cursor?: SessionExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionExercises.
     */
    distinct?: SessionExerciseScalarFieldEnum | SessionExerciseScalarFieldEnum[]
  }

  /**
   * SessionExercise findMany
   */
  export type SessionExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExercise
     */
    select?: SessionExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExerciseInclude<ExtArgs> | null
    /**
     * Filter, which SessionExercises to fetch.
     */
    where?: SessionExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionExercises to fetch.
     */
    orderBy?: SessionExerciseOrderByWithRelationInput | SessionExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionExercises.
     */
    cursor?: SessionExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionExercises.
     */
    skip?: number
    distinct?: SessionExerciseScalarFieldEnum | SessionExerciseScalarFieldEnum[]
  }

  /**
   * SessionExercise create
   */
  export type SessionExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExercise
     */
    select?: SessionExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionExercise.
     */
    data: XOR<SessionExerciseCreateInput, SessionExerciseUncheckedCreateInput>
  }

  /**
   * SessionExercise createMany
   */
  export type SessionExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionExercises.
     */
    data: SessionExerciseCreateManyInput | SessionExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionExercise createManyAndReturn
   */
  export type SessionExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExercise
     */
    select?: SessionExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SessionExercises.
     */
    data: SessionExerciseCreateManyInput | SessionExerciseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExerciseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionExercise update
   */
  export type SessionExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExercise
     */
    select?: SessionExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionExercise.
     */
    data: XOR<SessionExerciseUpdateInput, SessionExerciseUncheckedUpdateInput>
    /**
     * Choose, which SessionExercise to update.
     */
    where: SessionExerciseWhereUniqueInput
  }

  /**
   * SessionExercise updateMany
   */
  export type SessionExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionExercises.
     */
    data: XOR<SessionExerciseUpdateManyMutationInput, SessionExerciseUncheckedUpdateManyInput>
    /**
     * Filter which SessionExercises to update
     */
    where?: SessionExerciseWhereInput
  }

  /**
   * SessionExercise upsert
   */
  export type SessionExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExercise
     */
    select?: SessionExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionExercise to update in case it exists.
     */
    where: SessionExerciseWhereUniqueInput
    /**
     * In case the SessionExercise found by the `where` argument doesn't exist, create a new SessionExercise with this data.
     */
    create: XOR<SessionExerciseCreateInput, SessionExerciseUncheckedCreateInput>
    /**
     * In case the SessionExercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionExerciseUpdateInput, SessionExerciseUncheckedUpdateInput>
  }

  /**
   * SessionExercise delete
   */
  export type SessionExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExercise
     */
    select?: SessionExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExerciseInclude<ExtArgs> | null
    /**
     * Filter which SessionExercise to delete.
     */
    where: SessionExerciseWhereUniqueInput
  }

  /**
   * SessionExercise deleteMany
   */
  export type SessionExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionExercises to delete
     */
    where?: SessionExerciseWhereInput
  }

  /**
   * SessionExercise.progressInstances
   */
  export type SessionExercise$progressInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionProgress
     */
    select?: SessionProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionProgressInclude<ExtArgs> | null
    where?: SessionProgressWhereInput
    orderBy?: SessionProgressOrderByWithRelationInput | SessionProgressOrderByWithRelationInput[]
    cursor?: SessionProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionProgressScalarFieldEnum | SessionProgressScalarFieldEnum[]
  }

  /**
   * SessionExercise without action
   */
  export type SessionExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExercise
     */
    select?: SessionExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExerciseInclude<ExtArgs> | null
  }


  /**
   * Model SessionProgress
   */

  export type AggregateSessionProgress = {
    _count: SessionProgressCountAggregateOutputType | null
    _min: SessionProgressMinAggregateOutputType | null
    _max: SessionProgressMaxAggregateOutputType | null
  }

  export type SessionProgressMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    studentId: string | null
    exerciseInstanceId: string | null
    notes: string | null
    savedAt: Date | null
  }

  export type SessionProgressMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    studentId: string | null
    exerciseInstanceId: string | null
    notes: string | null
    savedAt: Date | null
  }

  export type SessionProgressCountAggregateOutputType = {
    id: number
    sessionId: number
    studentId: number
    exerciseInstanceId: number
    progress: number
    notes: number
    videos: number
    savedAt: number
    _all: number
  }


  export type SessionProgressMinAggregateInputType = {
    id?: true
    sessionId?: true
    studentId?: true
    exerciseInstanceId?: true
    notes?: true
    savedAt?: true
  }

  export type SessionProgressMaxAggregateInputType = {
    id?: true
    sessionId?: true
    studentId?: true
    exerciseInstanceId?: true
    notes?: true
    savedAt?: true
  }

  export type SessionProgressCountAggregateInputType = {
    id?: true
    sessionId?: true
    studentId?: true
    exerciseInstanceId?: true
    progress?: true
    notes?: true
    videos?: true
    savedAt?: true
    _all?: true
  }

  export type SessionProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionProgress to aggregate.
     */
    where?: SessionProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionProgresses to fetch.
     */
    orderBy?: SessionProgressOrderByWithRelationInput | SessionProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionProgresses
    **/
    _count?: true | SessionProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionProgressMaxAggregateInputType
  }

  export type GetSessionProgressAggregateType<T extends SessionProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionProgress[P]>
      : GetScalarType<T[P], AggregateSessionProgress[P]>
  }




  export type SessionProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionProgressWhereInput
    orderBy?: SessionProgressOrderByWithAggregationInput | SessionProgressOrderByWithAggregationInput[]
    by: SessionProgressScalarFieldEnum[] | SessionProgressScalarFieldEnum
    having?: SessionProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionProgressCountAggregateInputType | true
    _min?: SessionProgressMinAggregateInputType
    _max?: SessionProgressMaxAggregateInputType
  }

  export type SessionProgressGroupByOutputType = {
    id: string
    sessionId: string
    studentId: string
    exerciseInstanceId: string | null
    progress: JsonValue | null
    notes: string | null
    videos: string[]
    savedAt: Date
    _count: SessionProgressCountAggregateOutputType | null
    _min: SessionProgressMinAggregateOutputType | null
    _max: SessionProgressMaxAggregateOutputType | null
  }

  type GetSessionProgressGroupByPayload<T extends SessionProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionProgressGroupByOutputType[P]>
            : GetScalarType<T[P], SessionProgressGroupByOutputType[P]>
        }
      >
    >


  export type SessionProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    studentId?: boolean
    exerciseInstanceId?: boolean
    progress?: boolean
    notes?: boolean
    videos?: boolean
    savedAt?: boolean
    exerciseInstance?: boolean | SessionProgress$exerciseInstanceArgs<ExtArgs>
    session?: boolean | SessionDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionProgress"]>

  export type SessionProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    studentId?: boolean
    exerciseInstanceId?: boolean
    progress?: boolean
    notes?: boolean
    videos?: boolean
    savedAt?: boolean
    exerciseInstance?: boolean | SessionProgress$exerciseInstanceArgs<ExtArgs>
    session?: boolean | SessionDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionProgress"]>

  export type SessionProgressSelectScalar = {
    id?: boolean
    sessionId?: boolean
    studentId?: boolean
    exerciseInstanceId?: boolean
    progress?: boolean
    notes?: boolean
    videos?: boolean
    savedAt?: boolean
  }

  export type SessionProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exerciseInstance?: boolean | SessionProgress$exerciseInstanceArgs<ExtArgs>
    session?: boolean | SessionDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exerciseInstance?: boolean | SessionProgress$exerciseInstanceArgs<ExtArgs>
    session?: boolean | SessionDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionProgress"
    objects: {
      exerciseInstance: Prisma.$SessionExercisePayload<ExtArgs> | null
      session: Prisma.$SessionPayload<ExtArgs>
      student: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      studentId: string
      exerciseInstanceId: string | null
      progress: Prisma.JsonValue | null
      notes: string | null
      videos: string[]
      savedAt: Date
    }, ExtArgs["result"]["sessionProgress"]>
    composites: {}
  }

  type SessionProgressGetPayload<S extends boolean | null | undefined | SessionProgressDefaultArgs> = $Result.GetResult<Prisma.$SessionProgressPayload, S>

  type SessionProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionProgressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionProgressCountAggregateInputType | true
    }

  export interface SessionProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionProgress'], meta: { name: 'SessionProgress' } }
    /**
     * Find zero or one SessionProgress that matches the filter.
     * @param {SessionProgressFindUniqueArgs} args - Arguments to find a SessionProgress
     * @example
     * // Get one SessionProgress
     * const sessionProgress = await prisma.sessionProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionProgressFindUniqueArgs>(args: SelectSubset<T, SessionProgressFindUniqueArgs<ExtArgs>>): Prisma__SessionProgressClient<$Result.GetResult<Prisma.$SessionProgressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SessionProgress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionProgressFindUniqueOrThrowArgs} args - Arguments to find a SessionProgress
     * @example
     * // Get one SessionProgress
     * const sessionProgress = await prisma.sessionProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionProgressClient<$Result.GetResult<Prisma.$SessionProgressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SessionProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionProgressFindFirstArgs} args - Arguments to find a SessionProgress
     * @example
     * // Get one SessionProgress
     * const sessionProgress = await prisma.sessionProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionProgressFindFirstArgs>(args?: SelectSubset<T, SessionProgressFindFirstArgs<ExtArgs>>): Prisma__SessionProgressClient<$Result.GetResult<Prisma.$SessionProgressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SessionProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionProgressFindFirstOrThrowArgs} args - Arguments to find a SessionProgress
     * @example
     * // Get one SessionProgress
     * const sessionProgress = await prisma.sessionProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionProgressClient<$Result.GetResult<Prisma.$SessionProgressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SessionProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionProgresses
     * const sessionProgresses = await prisma.sessionProgress.findMany()
     * 
     * // Get first 10 SessionProgresses
     * const sessionProgresses = await prisma.sessionProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionProgressWithIdOnly = await prisma.sessionProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionProgressFindManyArgs>(args?: SelectSubset<T, SessionProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionProgressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SessionProgress.
     * @param {SessionProgressCreateArgs} args - Arguments to create a SessionProgress.
     * @example
     * // Create one SessionProgress
     * const SessionProgress = await prisma.sessionProgress.create({
     *   data: {
     *     // ... data to create a SessionProgress
     *   }
     * })
     * 
     */
    create<T extends SessionProgressCreateArgs>(args: SelectSubset<T, SessionProgressCreateArgs<ExtArgs>>): Prisma__SessionProgressClient<$Result.GetResult<Prisma.$SessionProgressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SessionProgresses.
     * @param {SessionProgressCreateManyArgs} args - Arguments to create many SessionProgresses.
     * @example
     * // Create many SessionProgresses
     * const sessionProgress = await prisma.sessionProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionProgressCreateManyArgs>(args?: SelectSubset<T, SessionProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionProgresses and returns the data saved in the database.
     * @param {SessionProgressCreateManyAndReturnArgs} args - Arguments to create many SessionProgresses.
     * @example
     * // Create many SessionProgresses
     * const sessionProgress = await prisma.sessionProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionProgresses and only return the `id`
     * const sessionProgressWithIdOnly = await prisma.sessionProgress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionProgressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SessionProgress.
     * @param {SessionProgressDeleteArgs} args - Arguments to delete one SessionProgress.
     * @example
     * // Delete one SessionProgress
     * const SessionProgress = await prisma.sessionProgress.delete({
     *   where: {
     *     // ... filter to delete one SessionProgress
     *   }
     * })
     * 
     */
    delete<T extends SessionProgressDeleteArgs>(args: SelectSubset<T, SessionProgressDeleteArgs<ExtArgs>>): Prisma__SessionProgressClient<$Result.GetResult<Prisma.$SessionProgressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SessionProgress.
     * @param {SessionProgressUpdateArgs} args - Arguments to update one SessionProgress.
     * @example
     * // Update one SessionProgress
     * const sessionProgress = await prisma.sessionProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionProgressUpdateArgs>(args: SelectSubset<T, SessionProgressUpdateArgs<ExtArgs>>): Prisma__SessionProgressClient<$Result.GetResult<Prisma.$SessionProgressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SessionProgresses.
     * @param {SessionProgressDeleteManyArgs} args - Arguments to filter SessionProgresses to delete.
     * @example
     * // Delete a few SessionProgresses
     * const { count } = await prisma.sessionProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionProgressDeleteManyArgs>(args?: SelectSubset<T, SessionProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionProgresses
     * const sessionProgress = await prisma.sessionProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionProgressUpdateManyArgs>(args: SelectSubset<T, SessionProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SessionProgress.
     * @param {SessionProgressUpsertArgs} args - Arguments to update or create a SessionProgress.
     * @example
     * // Update or create a SessionProgress
     * const sessionProgress = await prisma.sessionProgress.upsert({
     *   create: {
     *     // ... data to create a SessionProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionProgress we want to update
     *   }
     * })
     */
    upsert<T extends SessionProgressUpsertArgs>(args: SelectSubset<T, SessionProgressUpsertArgs<ExtArgs>>): Prisma__SessionProgressClient<$Result.GetResult<Prisma.$SessionProgressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SessionProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionProgressCountArgs} args - Arguments to filter SessionProgresses to count.
     * @example
     * // Count the number of SessionProgresses
     * const count = await prisma.sessionProgress.count({
     *   where: {
     *     // ... the filter for the SessionProgresses we want to count
     *   }
     * })
    **/
    count<T extends SessionProgressCountArgs>(
      args?: Subset<T, SessionProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionProgressAggregateArgs>(args: Subset<T, SessionProgressAggregateArgs>): Prisma.PrismaPromise<GetSessionProgressAggregateType<T>>

    /**
     * Group by SessionProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionProgressGroupByArgs['orderBy'] }
        : { orderBy?: SessionProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionProgress model
   */
  readonly fields: SessionProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exerciseInstance<T extends SessionProgress$exerciseInstanceArgs<ExtArgs> = {}>(args?: Subset<T, SessionProgress$exerciseInstanceArgs<ExtArgs>>): Prisma__SessionExerciseClient<$Result.GetResult<Prisma.$SessionExercisePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionProgress model
   */ 
  interface SessionProgressFieldRefs {
    readonly id: FieldRef<"SessionProgress", 'String'>
    readonly sessionId: FieldRef<"SessionProgress", 'String'>
    readonly studentId: FieldRef<"SessionProgress", 'String'>
    readonly exerciseInstanceId: FieldRef<"SessionProgress", 'String'>
    readonly progress: FieldRef<"SessionProgress", 'Json'>
    readonly notes: FieldRef<"SessionProgress", 'String'>
    readonly videos: FieldRef<"SessionProgress", 'String[]'>
    readonly savedAt: FieldRef<"SessionProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessionProgress findUnique
   */
  export type SessionProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionProgress
     */
    select?: SessionProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionProgressInclude<ExtArgs> | null
    /**
     * Filter, which SessionProgress to fetch.
     */
    where: SessionProgressWhereUniqueInput
  }

  /**
   * SessionProgress findUniqueOrThrow
   */
  export type SessionProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionProgress
     */
    select?: SessionProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionProgressInclude<ExtArgs> | null
    /**
     * Filter, which SessionProgress to fetch.
     */
    where: SessionProgressWhereUniqueInput
  }

  /**
   * SessionProgress findFirst
   */
  export type SessionProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionProgress
     */
    select?: SessionProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionProgressInclude<ExtArgs> | null
    /**
     * Filter, which SessionProgress to fetch.
     */
    where?: SessionProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionProgresses to fetch.
     */
    orderBy?: SessionProgressOrderByWithRelationInput | SessionProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionProgresses.
     */
    cursor?: SessionProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionProgresses.
     */
    distinct?: SessionProgressScalarFieldEnum | SessionProgressScalarFieldEnum[]
  }

  /**
   * SessionProgress findFirstOrThrow
   */
  export type SessionProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionProgress
     */
    select?: SessionProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionProgressInclude<ExtArgs> | null
    /**
     * Filter, which SessionProgress to fetch.
     */
    where?: SessionProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionProgresses to fetch.
     */
    orderBy?: SessionProgressOrderByWithRelationInput | SessionProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionProgresses.
     */
    cursor?: SessionProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionProgresses.
     */
    distinct?: SessionProgressScalarFieldEnum | SessionProgressScalarFieldEnum[]
  }

  /**
   * SessionProgress findMany
   */
  export type SessionProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionProgress
     */
    select?: SessionProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionProgressInclude<ExtArgs> | null
    /**
     * Filter, which SessionProgresses to fetch.
     */
    where?: SessionProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionProgresses to fetch.
     */
    orderBy?: SessionProgressOrderByWithRelationInput | SessionProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionProgresses.
     */
    cursor?: SessionProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionProgresses.
     */
    skip?: number
    distinct?: SessionProgressScalarFieldEnum | SessionProgressScalarFieldEnum[]
  }

  /**
   * SessionProgress create
   */
  export type SessionProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionProgress
     */
    select?: SessionProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionProgress.
     */
    data: XOR<SessionProgressCreateInput, SessionProgressUncheckedCreateInput>
  }

  /**
   * SessionProgress createMany
   */
  export type SessionProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionProgresses.
     */
    data: SessionProgressCreateManyInput | SessionProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionProgress createManyAndReturn
   */
  export type SessionProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionProgress
     */
    select?: SessionProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SessionProgresses.
     */
    data: SessionProgressCreateManyInput | SessionProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionProgress update
   */
  export type SessionProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionProgress
     */
    select?: SessionProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionProgress.
     */
    data: XOR<SessionProgressUpdateInput, SessionProgressUncheckedUpdateInput>
    /**
     * Choose, which SessionProgress to update.
     */
    where: SessionProgressWhereUniqueInput
  }

  /**
   * SessionProgress updateMany
   */
  export type SessionProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionProgresses.
     */
    data: XOR<SessionProgressUpdateManyMutationInput, SessionProgressUncheckedUpdateManyInput>
    /**
     * Filter which SessionProgresses to update
     */
    where?: SessionProgressWhereInput
  }

  /**
   * SessionProgress upsert
   */
  export type SessionProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionProgress
     */
    select?: SessionProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionProgress to update in case it exists.
     */
    where: SessionProgressWhereUniqueInput
    /**
     * In case the SessionProgress found by the `where` argument doesn't exist, create a new SessionProgress with this data.
     */
    create: XOR<SessionProgressCreateInput, SessionProgressUncheckedCreateInput>
    /**
     * In case the SessionProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionProgressUpdateInput, SessionProgressUncheckedUpdateInput>
  }

  /**
   * SessionProgress delete
   */
  export type SessionProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionProgress
     */
    select?: SessionProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionProgressInclude<ExtArgs> | null
    /**
     * Filter which SessionProgress to delete.
     */
    where: SessionProgressWhereUniqueInput
  }

  /**
   * SessionProgress deleteMany
   */
  export type SessionProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionProgresses to delete
     */
    where?: SessionProgressWhereInput
  }

  /**
   * SessionProgress.exerciseInstance
   */
  export type SessionProgress$exerciseInstanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExercise
     */
    select?: SessionExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExerciseInclude<ExtArgs> | null
    where?: SessionExerciseWhereInput
  }

  /**
   * SessionProgress without action
   */
  export type SessionProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionProgress
     */
    select?: SessionProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionProgressInclude<ExtArgs> | null
  }


  /**
   * Model ProgramAssignment
   */

  export type AggregateProgramAssignment = {
    _count: ProgramAssignmentCountAggregateOutputType | null
    _min: ProgramAssignmentMinAggregateOutputType | null
    _max: ProgramAssignmentMaxAggregateOutputType | null
  }

  export type ProgramAssignmentMinAggregateOutputType = {
    id: string | null
    programId: string | null
    studentId: string | null
    assignedBy: string | null
    assignedAt: Date | null
  }

  export type ProgramAssignmentMaxAggregateOutputType = {
    id: string | null
    programId: string | null
    studentId: string | null
    assignedBy: string | null
    assignedAt: Date | null
  }

  export type ProgramAssignmentCountAggregateOutputType = {
    id: number
    programId: number
    studentId: number
    assignedBy: number
    assignedAt: number
    _all: number
  }


  export type ProgramAssignmentMinAggregateInputType = {
    id?: true
    programId?: true
    studentId?: true
    assignedBy?: true
    assignedAt?: true
  }

  export type ProgramAssignmentMaxAggregateInputType = {
    id?: true
    programId?: true
    studentId?: true
    assignedBy?: true
    assignedAt?: true
  }

  export type ProgramAssignmentCountAggregateInputType = {
    id?: true
    programId?: true
    studentId?: true
    assignedBy?: true
    assignedAt?: true
    _all?: true
  }

  export type ProgramAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramAssignment to aggregate.
     */
    where?: ProgramAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramAssignments to fetch.
     */
    orderBy?: ProgramAssignmentOrderByWithRelationInput | ProgramAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgramAssignments
    **/
    _count?: true | ProgramAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramAssignmentMaxAggregateInputType
  }

  export type GetProgramAssignmentAggregateType<T extends ProgramAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramAssignment[P]>
      : GetScalarType<T[P], AggregateProgramAssignment[P]>
  }




  export type ProgramAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramAssignmentWhereInput
    orderBy?: ProgramAssignmentOrderByWithAggregationInput | ProgramAssignmentOrderByWithAggregationInput[]
    by: ProgramAssignmentScalarFieldEnum[] | ProgramAssignmentScalarFieldEnum
    having?: ProgramAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramAssignmentCountAggregateInputType | true
    _min?: ProgramAssignmentMinAggregateInputType
    _max?: ProgramAssignmentMaxAggregateInputType
  }

  export type ProgramAssignmentGroupByOutputType = {
    id: string
    programId: string
    studentId: string
    assignedBy: string | null
    assignedAt: Date
    _count: ProgramAssignmentCountAggregateOutputType | null
    _min: ProgramAssignmentMinAggregateOutputType | null
    _max: ProgramAssignmentMaxAggregateOutputType | null
  }

  type GetProgramAssignmentGroupByPayload<T extends ProgramAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type ProgramAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    studentId?: boolean
    assignedBy?: boolean
    assignedAt?: boolean
    assigner?: boolean | ProgramAssignment$assignerArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programAssignment"]>

  export type ProgramAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    studentId?: boolean
    assignedBy?: boolean
    assignedAt?: boolean
    assigner?: boolean | ProgramAssignment$assignerArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programAssignment"]>

  export type ProgramAssignmentSelectScalar = {
    id?: boolean
    programId?: boolean
    studentId?: boolean
    assignedBy?: boolean
    assignedAt?: boolean
  }

  export type ProgramAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assigner?: boolean | ProgramAssignment$assignerArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProgramAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assigner?: boolean | ProgramAssignment$assignerArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProgramAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgramAssignment"
    objects: {
      assigner: Prisma.$UserPayload<ExtArgs> | null
      program: Prisma.$ProgramPayload<ExtArgs>
      student: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      programId: string
      studentId: string
      assignedBy: string | null
      assignedAt: Date
    }, ExtArgs["result"]["programAssignment"]>
    composites: {}
  }

  type ProgramAssignmentGetPayload<S extends boolean | null | undefined | ProgramAssignmentDefaultArgs> = $Result.GetResult<Prisma.$ProgramAssignmentPayload, S>

  type ProgramAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgramAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgramAssignmentCountAggregateInputType | true
    }

  export interface ProgramAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgramAssignment'], meta: { name: 'ProgramAssignment' } }
    /**
     * Find zero or one ProgramAssignment that matches the filter.
     * @param {ProgramAssignmentFindUniqueArgs} args - Arguments to find a ProgramAssignment
     * @example
     * // Get one ProgramAssignment
     * const programAssignment = await prisma.programAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramAssignmentFindUniqueArgs>(args: SelectSubset<T, ProgramAssignmentFindUniqueArgs<ExtArgs>>): Prisma__ProgramAssignmentClient<$Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProgramAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgramAssignmentFindUniqueOrThrowArgs} args - Arguments to find a ProgramAssignment
     * @example
     * // Get one ProgramAssignment
     * const programAssignment = await prisma.programAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramAssignmentClient<$Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProgramAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAssignmentFindFirstArgs} args - Arguments to find a ProgramAssignment
     * @example
     * // Get one ProgramAssignment
     * const programAssignment = await prisma.programAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramAssignmentFindFirstArgs>(args?: SelectSubset<T, ProgramAssignmentFindFirstArgs<ExtArgs>>): Prisma__ProgramAssignmentClient<$Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProgramAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAssignmentFindFirstOrThrowArgs} args - Arguments to find a ProgramAssignment
     * @example
     * // Get one ProgramAssignment
     * const programAssignment = await prisma.programAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramAssignmentClient<$Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProgramAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramAssignments
     * const programAssignments = await prisma.programAssignment.findMany()
     * 
     * // Get first 10 ProgramAssignments
     * const programAssignments = await prisma.programAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programAssignmentWithIdOnly = await prisma.programAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramAssignmentFindManyArgs>(args?: SelectSubset<T, ProgramAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProgramAssignment.
     * @param {ProgramAssignmentCreateArgs} args - Arguments to create a ProgramAssignment.
     * @example
     * // Create one ProgramAssignment
     * const ProgramAssignment = await prisma.programAssignment.create({
     *   data: {
     *     // ... data to create a ProgramAssignment
     *   }
     * })
     * 
     */
    create<T extends ProgramAssignmentCreateArgs>(args: SelectSubset<T, ProgramAssignmentCreateArgs<ExtArgs>>): Prisma__ProgramAssignmentClient<$Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProgramAssignments.
     * @param {ProgramAssignmentCreateManyArgs} args - Arguments to create many ProgramAssignments.
     * @example
     * // Create many ProgramAssignments
     * const programAssignment = await prisma.programAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramAssignmentCreateManyArgs>(args?: SelectSubset<T, ProgramAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgramAssignments and returns the data saved in the database.
     * @param {ProgramAssignmentCreateManyAndReturnArgs} args - Arguments to create many ProgramAssignments.
     * @example
     * // Create many ProgramAssignments
     * const programAssignment = await prisma.programAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgramAssignments and only return the `id`
     * const programAssignmentWithIdOnly = await prisma.programAssignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProgramAssignment.
     * @param {ProgramAssignmentDeleteArgs} args - Arguments to delete one ProgramAssignment.
     * @example
     * // Delete one ProgramAssignment
     * const ProgramAssignment = await prisma.programAssignment.delete({
     *   where: {
     *     // ... filter to delete one ProgramAssignment
     *   }
     * })
     * 
     */
    delete<T extends ProgramAssignmentDeleteArgs>(args: SelectSubset<T, ProgramAssignmentDeleteArgs<ExtArgs>>): Prisma__ProgramAssignmentClient<$Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProgramAssignment.
     * @param {ProgramAssignmentUpdateArgs} args - Arguments to update one ProgramAssignment.
     * @example
     * // Update one ProgramAssignment
     * const programAssignment = await prisma.programAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramAssignmentUpdateArgs>(args: SelectSubset<T, ProgramAssignmentUpdateArgs<ExtArgs>>): Prisma__ProgramAssignmentClient<$Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProgramAssignments.
     * @param {ProgramAssignmentDeleteManyArgs} args - Arguments to filter ProgramAssignments to delete.
     * @example
     * // Delete a few ProgramAssignments
     * const { count } = await prisma.programAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramAssignmentDeleteManyArgs>(args?: SelectSubset<T, ProgramAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramAssignments
     * const programAssignment = await prisma.programAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramAssignmentUpdateManyArgs>(args: SelectSubset<T, ProgramAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProgramAssignment.
     * @param {ProgramAssignmentUpsertArgs} args - Arguments to update or create a ProgramAssignment.
     * @example
     * // Update or create a ProgramAssignment
     * const programAssignment = await prisma.programAssignment.upsert({
     *   create: {
     *     // ... data to create a ProgramAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramAssignment we want to update
     *   }
     * })
     */
    upsert<T extends ProgramAssignmentUpsertArgs>(args: SelectSubset<T, ProgramAssignmentUpsertArgs<ExtArgs>>): Prisma__ProgramAssignmentClient<$Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProgramAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAssignmentCountArgs} args - Arguments to filter ProgramAssignments to count.
     * @example
     * // Count the number of ProgramAssignments
     * const count = await prisma.programAssignment.count({
     *   where: {
     *     // ... the filter for the ProgramAssignments we want to count
     *   }
     * })
    **/
    count<T extends ProgramAssignmentCountArgs>(
      args?: Subset<T, ProgramAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramAssignmentAggregateArgs>(args: Subset<T, ProgramAssignmentAggregateArgs>): Prisma.PrismaPromise<GetProgramAssignmentAggregateType<T>>

    /**
     * Group by ProgramAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: ProgramAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgramAssignment model
   */
  readonly fields: ProgramAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgramAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assigner<T extends ProgramAssignment$assignerArgs<ExtArgs> = {}>(args?: Subset<T, ProgramAssignment$assignerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgramAssignment model
   */ 
  interface ProgramAssignmentFieldRefs {
    readonly id: FieldRef<"ProgramAssignment", 'String'>
    readonly programId: FieldRef<"ProgramAssignment", 'String'>
    readonly studentId: FieldRef<"ProgramAssignment", 'String'>
    readonly assignedBy: FieldRef<"ProgramAssignment", 'String'>
    readonly assignedAt: FieldRef<"ProgramAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProgramAssignment findUnique
   */
  export type ProgramAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAssignment
     */
    select?: ProgramAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ProgramAssignment to fetch.
     */
    where: ProgramAssignmentWhereUniqueInput
  }

  /**
   * ProgramAssignment findUniqueOrThrow
   */
  export type ProgramAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAssignment
     */
    select?: ProgramAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ProgramAssignment to fetch.
     */
    where: ProgramAssignmentWhereUniqueInput
  }

  /**
   * ProgramAssignment findFirst
   */
  export type ProgramAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAssignment
     */
    select?: ProgramAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ProgramAssignment to fetch.
     */
    where?: ProgramAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramAssignments to fetch.
     */
    orderBy?: ProgramAssignmentOrderByWithRelationInput | ProgramAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramAssignments.
     */
    cursor?: ProgramAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramAssignments.
     */
    distinct?: ProgramAssignmentScalarFieldEnum | ProgramAssignmentScalarFieldEnum[]
  }

  /**
   * ProgramAssignment findFirstOrThrow
   */
  export type ProgramAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAssignment
     */
    select?: ProgramAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ProgramAssignment to fetch.
     */
    where?: ProgramAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramAssignments to fetch.
     */
    orderBy?: ProgramAssignmentOrderByWithRelationInput | ProgramAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramAssignments.
     */
    cursor?: ProgramAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramAssignments.
     */
    distinct?: ProgramAssignmentScalarFieldEnum | ProgramAssignmentScalarFieldEnum[]
  }

  /**
   * ProgramAssignment findMany
   */
  export type ProgramAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAssignment
     */
    select?: ProgramAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ProgramAssignments to fetch.
     */
    where?: ProgramAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramAssignments to fetch.
     */
    orderBy?: ProgramAssignmentOrderByWithRelationInput | ProgramAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgramAssignments.
     */
    cursor?: ProgramAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramAssignments.
     */
    skip?: number
    distinct?: ProgramAssignmentScalarFieldEnum | ProgramAssignmentScalarFieldEnum[]
  }

  /**
   * ProgramAssignment create
   */
  export type ProgramAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAssignment
     */
    select?: ProgramAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgramAssignment.
     */
    data: XOR<ProgramAssignmentCreateInput, ProgramAssignmentUncheckedCreateInput>
  }

  /**
   * ProgramAssignment createMany
   */
  export type ProgramAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgramAssignments.
     */
    data: ProgramAssignmentCreateManyInput | ProgramAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgramAssignment createManyAndReturn
   */
  export type ProgramAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAssignment
     */
    select?: ProgramAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProgramAssignments.
     */
    data: ProgramAssignmentCreateManyInput | ProgramAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgramAssignment update
   */
  export type ProgramAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAssignment
     */
    select?: ProgramAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgramAssignment.
     */
    data: XOR<ProgramAssignmentUpdateInput, ProgramAssignmentUncheckedUpdateInput>
    /**
     * Choose, which ProgramAssignment to update.
     */
    where: ProgramAssignmentWhereUniqueInput
  }

  /**
   * ProgramAssignment updateMany
   */
  export type ProgramAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgramAssignments.
     */
    data: XOR<ProgramAssignmentUpdateManyMutationInput, ProgramAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ProgramAssignments to update
     */
    where?: ProgramAssignmentWhereInput
  }

  /**
   * ProgramAssignment upsert
   */
  export type ProgramAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAssignment
     */
    select?: ProgramAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgramAssignment to update in case it exists.
     */
    where: ProgramAssignmentWhereUniqueInput
    /**
     * In case the ProgramAssignment found by the `where` argument doesn't exist, create a new ProgramAssignment with this data.
     */
    create: XOR<ProgramAssignmentCreateInput, ProgramAssignmentUncheckedCreateInput>
    /**
     * In case the ProgramAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramAssignmentUpdateInput, ProgramAssignmentUncheckedUpdateInput>
  }

  /**
   * ProgramAssignment delete
   */
  export type ProgramAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAssignment
     */
    select?: ProgramAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAssignmentInclude<ExtArgs> | null
    /**
     * Filter which ProgramAssignment to delete.
     */
    where: ProgramAssignmentWhereUniqueInput
  }

  /**
   * ProgramAssignment deleteMany
   */
  export type ProgramAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramAssignments to delete
     */
    where?: ProgramAssignmentWhereInput
  }

  /**
   * ProgramAssignment.assigner
   */
  export type ProgramAssignment$assignerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ProgramAssignment without action
   */
  export type ProgramAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAssignment
     */
    select?: ProgramAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model ProgramAudit
   */

  export type AggregateProgramAudit = {
    _count: ProgramAuditCountAggregateOutputType | null
    _min: ProgramAuditMinAggregateOutputType | null
    _max: ProgramAuditMaxAggregateOutputType | null
  }

  export type ProgramAuditMinAggregateOutputType = {
    id: string | null
    programId: string | null
    changedBy: string | null
    changeType: string | null
    createdAt: Date | null
  }

  export type ProgramAuditMaxAggregateOutputType = {
    id: string | null
    programId: string | null
    changedBy: string | null
    changeType: string | null
    createdAt: Date | null
  }

  export type ProgramAuditCountAggregateOutputType = {
    id: number
    programId: number
    changedBy: number
    changeType: number
    diff: number
    createdAt: number
    _all: number
  }


  export type ProgramAuditMinAggregateInputType = {
    id?: true
    programId?: true
    changedBy?: true
    changeType?: true
    createdAt?: true
  }

  export type ProgramAuditMaxAggregateInputType = {
    id?: true
    programId?: true
    changedBy?: true
    changeType?: true
    createdAt?: true
  }

  export type ProgramAuditCountAggregateInputType = {
    id?: true
    programId?: true
    changedBy?: true
    changeType?: true
    diff?: true
    createdAt?: true
    _all?: true
  }

  export type ProgramAuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramAudit to aggregate.
     */
    where?: ProgramAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramAudits to fetch.
     */
    orderBy?: ProgramAuditOrderByWithRelationInput | ProgramAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgramAudits
    **/
    _count?: true | ProgramAuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramAuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramAuditMaxAggregateInputType
  }

  export type GetProgramAuditAggregateType<T extends ProgramAuditAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramAudit[P]>
      : GetScalarType<T[P], AggregateProgramAudit[P]>
  }




  export type ProgramAuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramAuditWhereInput
    orderBy?: ProgramAuditOrderByWithAggregationInput | ProgramAuditOrderByWithAggregationInput[]
    by: ProgramAuditScalarFieldEnum[] | ProgramAuditScalarFieldEnum
    having?: ProgramAuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramAuditCountAggregateInputType | true
    _min?: ProgramAuditMinAggregateInputType
    _max?: ProgramAuditMaxAggregateInputType
  }

  export type ProgramAuditGroupByOutputType = {
    id: string
    programId: string
    changedBy: string
    changeType: string
    diff: JsonValue | null
    createdAt: Date
    _count: ProgramAuditCountAggregateOutputType | null
    _min: ProgramAuditMinAggregateOutputType | null
    _max: ProgramAuditMaxAggregateOutputType | null
  }

  type GetProgramAuditGroupByPayload<T extends ProgramAuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramAuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramAuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramAuditGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramAuditGroupByOutputType[P]>
        }
      >
    >


  export type ProgramAuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    changedBy?: boolean
    changeType?: boolean
    diff?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programAudit"]>

  export type ProgramAuditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    changedBy?: boolean
    changeType?: boolean
    diff?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programAudit"]>

  export type ProgramAuditSelectScalar = {
    id?: boolean
    programId?: boolean
    changedBy?: boolean
    changeType?: boolean
    diff?: boolean
    createdAt?: boolean
  }

  export type ProgramAuditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }
  export type ProgramAuditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }

  export type $ProgramAuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgramAudit"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      program: Prisma.$ProgramPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      programId: string
      changedBy: string
      changeType: string
      diff: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["programAudit"]>
    composites: {}
  }

  type ProgramAuditGetPayload<S extends boolean | null | undefined | ProgramAuditDefaultArgs> = $Result.GetResult<Prisma.$ProgramAuditPayload, S>

  type ProgramAuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgramAuditFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgramAuditCountAggregateInputType | true
    }

  export interface ProgramAuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgramAudit'], meta: { name: 'ProgramAudit' } }
    /**
     * Find zero or one ProgramAudit that matches the filter.
     * @param {ProgramAuditFindUniqueArgs} args - Arguments to find a ProgramAudit
     * @example
     * // Get one ProgramAudit
     * const programAudit = await prisma.programAudit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramAuditFindUniqueArgs>(args: SelectSubset<T, ProgramAuditFindUniqueArgs<ExtArgs>>): Prisma__ProgramAuditClient<$Result.GetResult<Prisma.$ProgramAuditPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProgramAudit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgramAuditFindUniqueOrThrowArgs} args - Arguments to find a ProgramAudit
     * @example
     * // Get one ProgramAudit
     * const programAudit = await prisma.programAudit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramAuditFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramAuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramAuditClient<$Result.GetResult<Prisma.$ProgramAuditPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProgramAudit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAuditFindFirstArgs} args - Arguments to find a ProgramAudit
     * @example
     * // Get one ProgramAudit
     * const programAudit = await prisma.programAudit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramAuditFindFirstArgs>(args?: SelectSubset<T, ProgramAuditFindFirstArgs<ExtArgs>>): Prisma__ProgramAuditClient<$Result.GetResult<Prisma.$ProgramAuditPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProgramAudit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAuditFindFirstOrThrowArgs} args - Arguments to find a ProgramAudit
     * @example
     * // Get one ProgramAudit
     * const programAudit = await prisma.programAudit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramAuditFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramAuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramAuditClient<$Result.GetResult<Prisma.$ProgramAuditPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProgramAudits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramAudits
     * const programAudits = await prisma.programAudit.findMany()
     * 
     * // Get first 10 ProgramAudits
     * const programAudits = await prisma.programAudit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programAuditWithIdOnly = await prisma.programAudit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramAuditFindManyArgs>(args?: SelectSubset<T, ProgramAuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramAuditPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProgramAudit.
     * @param {ProgramAuditCreateArgs} args - Arguments to create a ProgramAudit.
     * @example
     * // Create one ProgramAudit
     * const ProgramAudit = await prisma.programAudit.create({
     *   data: {
     *     // ... data to create a ProgramAudit
     *   }
     * })
     * 
     */
    create<T extends ProgramAuditCreateArgs>(args: SelectSubset<T, ProgramAuditCreateArgs<ExtArgs>>): Prisma__ProgramAuditClient<$Result.GetResult<Prisma.$ProgramAuditPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProgramAudits.
     * @param {ProgramAuditCreateManyArgs} args - Arguments to create many ProgramAudits.
     * @example
     * // Create many ProgramAudits
     * const programAudit = await prisma.programAudit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramAuditCreateManyArgs>(args?: SelectSubset<T, ProgramAuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgramAudits and returns the data saved in the database.
     * @param {ProgramAuditCreateManyAndReturnArgs} args - Arguments to create many ProgramAudits.
     * @example
     * // Create many ProgramAudits
     * const programAudit = await prisma.programAudit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgramAudits and only return the `id`
     * const programAuditWithIdOnly = await prisma.programAudit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramAuditCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramAuditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramAuditPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProgramAudit.
     * @param {ProgramAuditDeleteArgs} args - Arguments to delete one ProgramAudit.
     * @example
     * // Delete one ProgramAudit
     * const ProgramAudit = await prisma.programAudit.delete({
     *   where: {
     *     // ... filter to delete one ProgramAudit
     *   }
     * })
     * 
     */
    delete<T extends ProgramAuditDeleteArgs>(args: SelectSubset<T, ProgramAuditDeleteArgs<ExtArgs>>): Prisma__ProgramAuditClient<$Result.GetResult<Prisma.$ProgramAuditPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProgramAudit.
     * @param {ProgramAuditUpdateArgs} args - Arguments to update one ProgramAudit.
     * @example
     * // Update one ProgramAudit
     * const programAudit = await prisma.programAudit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramAuditUpdateArgs>(args: SelectSubset<T, ProgramAuditUpdateArgs<ExtArgs>>): Prisma__ProgramAuditClient<$Result.GetResult<Prisma.$ProgramAuditPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProgramAudits.
     * @param {ProgramAuditDeleteManyArgs} args - Arguments to filter ProgramAudits to delete.
     * @example
     * // Delete a few ProgramAudits
     * const { count } = await prisma.programAudit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramAuditDeleteManyArgs>(args?: SelectSubset<T, ProgramAuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramAudits
     * const programAudit = await prisma.programAudit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramAuditUpdateManyArgs>(args: SelectSubset<T, ProgramAuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProgramAudit.
     * @param {ProgramAuditUpsertArgs} args - Arguments to update or create a ProgramAudit.
     * @example
     * // Update or create a ProgramAudit
     * const programAudit = await prisma.programAudit.upsert({
     *   create: {
     *     // ... data to create a ProgramAudit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramAudit we want to update
     *   }
     * })
     */
    upsert<T extends ProgramAuditUpsertArgs>(args: SelectSubset<T, ProgramAuditUpsertArgs<ExtArgs>>): Prisma__ProgramAuditClient<$Result.GetResult<Prisma.$ProgramAuditPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProgramAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAuditCountArgs} args - Arguments to filter ProgramAudits to count.
     * @example
     * // Count the number of ProgramAudits
     * const count = await prisma.programAudit.count({
     *   where: {
     *     // ... the filter for the ProgramAudits we want to count
     *   }
     * })
    **/
    count<T extends ProgramAuditCountArgs>(
      args?: Subset<T, ProgramAuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramAuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramAuditAggregateArgs>(args: Subset<T, ProgramAuditAggregateArgs>): Prisma.PrismaPromise<GetProgramAuditAggregateType<T>>

    /**
     * Group by ProgramAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramAuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramAuditGroupByArgs['orderBy'] }
        : { orderBy?: ProgramAuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramAuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgramAudit model
   */
  readonly fields: ProgramAuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgramAudit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramAuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgramAudit model
   */ 
  interface ProgramAuditFieldRefs {
    readonly id: FieldRef<"ProgramAudit", 'String'>
    readonly programId: FieldRef<"ProgramAudit", 'String'>
    readonly changedBy: FieldRef<"ProgramAudit", 'String'>
    readonly changeType: FieldRef<"ProgramAudit", 'String'>
    readonly diff: FieldRef<"ProgramAudit", 'Json'>
    readonly createdAt: FieldRef<"ProgramAudit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProgramAudit findUnique
   */
  export type ProgramAuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAudit
     */
    select?: ProgramAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAuditInclude<ExtArgs> | null
    /**
     * Filter, which ProgramAudit to fetch.
     */
    where: ProgramAuditWhereUniqueInput
  }

  /**
   * ProgramAudit findUniqueOrThrow
   */
  export type ProgramAuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAudit
     */
    select?: ProgramAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAuditInclude<ExtArgs> | null
    /**
     * Filter, which ProgramAudit to fetch.
     */
    where: ProgramAuditWhereUniqueInput
  }

  /**
   * ProgramAudit findFirst
   */
  export type ProgramAuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAudit
     */
    select?: ProgramAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAuditInclude<ExtArgs> | null
    /**
     * Filter, which ProgramAudit to fetch.
     */
    where?: ProgramAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramAudits to fetch.
     */
    orderBy?: ProgramAuditOrderByWithRelationInput | ProgramAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramAudits.
     */
    cursor?: ProgramAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramAudits.
     */
    distinct?: ProgramAuditScalarFieldEnum | ProgramAuditScalarFieldEnum[]
  }

  /**
   * ProgramAudit findFirstOrThrow
   */
  export type ProgramAuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAudit
     */
    select?: ProgramAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAuditInclude<ExtArgs> | null
    /**
     * Filter, which ProgramAudit to fetch.
     */
    where?: ProgramAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramAudits to fetch.
     */
    orderBy?: ProgramAuditOrderByWithRelationInput | ProgramAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramAudits.
     */
    cursor?: ProgramAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramAudits.
     */
    distinct?: ProgramAuditScalarFieldEnum | ProgramAuditScalarFieldEnum[]
  }

  /**
   * ProgramAudit findMany
   */
  export type ProgramAuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAudit
     */
    select?: ProgramAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAuditInclude<ExtArgs> | null
    /**
     * Filter, which ProgramAudits to fetch.
     */
    where?: ProgramAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramAudits to fetch.
     */
    orderBy?: ProgramAuditOrderByWithRelationInput | ProgramAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgramAudits.
     */
    cursor?: ProgramAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramAudits.
     */
    skip?: number
    distinct?: ProgramAuditScalarFieldEnum | ProgramAuditScalarFieldEnum[]
  }

  /**
   * ProgramAudit create
   */
  export type ProgramAuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAudit
     */
    select?: ProgramAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAuditInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgramAudit.
     */
    data: XOR<ProgramAuditCreateInput, ProgramAuditUncheckedCreateInput>
  }

  /**
   * ProgramAudit createMany
   */
  export type ProgramAuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgramAudits.
     */
    data: ProgramAuditCreateManyInput | ProgramAuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgramAudit createManyAndReturn
   */
  export type ProgramAuditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAudit
     */
    select?: ProgramAuditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProgramAudits.
     */
    data: ProgramAuditCreateManyInput | ProgramAuditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAuditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgramAudit update
   */
  export type ProgramAuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAudit
     */
    select?: ProgramAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAuditInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgramAudit.
     */
    data: XOR<ProgramAuditUpdateInput, ProgramAuditUncheckedUpdateInput>
    /**
     * Choose, which ProgramAudit to update.
     */
    where: ProgramAuditWhereUniqueInput
  }

  /**
   * ProgramAudit updateMany
   */
  export type ProgramAuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgramAudits.
     */
    data: XOR<ProgramAuditUpdateManyMutationInput, ProgramAuditUncheckedUpdateManyInput>
    /**
     * Filter which ProgramAudits to update
     */
    where?: ProgramAuditWhereInput
  }

  /**
   * ProgramAudit upsert
   */
  export type ProgramAuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAudit
     */
    select?: ProgramAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAuditInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgramAudit to update in case it exists.
     */
    where: ProgramAuditWhereUniqueInput
    /**
     * In case the ProgramAudit found by the `where` argument doesn't exist, create a new ProgramAudit with this data.
     */
    create: XOR<ProgramAuditCreateInput, ProgramAuditUncheckedCreateInput>
    /**
     * In case the ProgramAudit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramAuditUpdateInput, ProgramAuditUncheckedUpdateInput>
  }

  /**
   * ProgramAudit delete
   */
  export type ProgramAuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAudit
     */
    select?: ProgramAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAuditInclude<ExtArgs> | null
    /**
     * Filter which ProgramAudit to delete.
     */
    where: ProgramAuditWhereUniqueInput
  }

  /**
   * ProgramAudit deleteMany
   */
  export type ProgramAuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramAudits to delete
     */
    where?: ProgramAuditWhereInput
  }

  /**
   * ProgramAudit without action
   */
  export type ProgramAuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramAudit
     */
    select?: ProgramAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramAuditInclude<ExtArgs> | null
  }


  /**
   * Model Badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeMinAggregateOutputType = {
    id: string | null
    key: string | null
  }

  export type BadgeMaxAggregateOutputType = {
    id: string | null
    key: string | null
  }

  export type BadgeCountAggregateOutputType = {
    id: number
    key: number
    title: number
    description: number
    criteria: number
    _all: number
  }


  export type BadgeMinAggregateInputType = {
    id?: true
    key?: true
  }

  export type BadgeMaxAggregateInputType = {
    id?: true
    key?: true
  }

  export type BadgeCountAggregateInputType = {
    id?: true
    key?: true
    title?: true
    description?: true
    criteria?: true
    _all?: true
  }

  export type BadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badge to aggregate.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type BadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithAggregationInput | BadgeOrderByWithAggregationInput[]
    by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum
    having?: BadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }

  export type BadgeGroupByOutputType = {
    id: string
    key: string
    title: JsonValue
    description: JsonValue
    criteria: JsonValue
    _count: BadgeCountAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends BadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type BadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    title?: boolean
    description?: boolean
    criteria?: boolean
    userBadges?: boolean | Badge$userBadgesArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    title?: boolean
    description?: boolean
    criteria?: boolean
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectScalar = {
    id?: boolean
    key?: boolean
    title?: boolean
    description?: boolean
    criteria?: boolean
  }

  export type BadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userBadges?: boolean | Badge$userBadgesArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Badge"
    objects: {
      userBadges: Prisma.$UserBadgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      title: Prisma.JsonValue
      description: Prisma.JsonValue
      criteria: Prisma.JsonValue
    }, ExtArgs["result"]["badge"]>
    composites: {}
  }

  type BadgeGetPayload<S extends boolean | null | undefined | BadgeDefaultArgs> = $Result.GetResult<Prisma.$BadgePayload, S>

  type BadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BadgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BadgeCountAggregateInputType | true
    }

  export interface BadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Badge'], meta: { name: 'Badge' } }
    /**
     * Find zero or one Badge that matches the filter.
     * @param {BadgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeFindUniqueArgs>(args: SelectSubset<T, BadgeFindUniqueArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BadgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeFindFirstArgs>(args?: SelectSubset<T, BadgeFindFirstArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeFindManyArgs>(args?: SelectSubset<T, BadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Badge.
     * @param {BadgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
     */
    create<T extends BadgeCreateArgs>(args: SelectSubset<T, BadgeCreateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Badges.
     * @param {BadgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeCreateManyArgs>(args?: SelectSubset<T, BadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {BadgeCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Badge.
     * @param {BadgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
     */
    delete<T extends BadgeDeleteArgs>(args: SelectSubset<T, BadgeDeleteArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Badge.
     * @param {BadgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeUpdateArgs>(args: SelectSubset<T, BadgeUpdateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Badges.
     * @param {BadgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeDeleteManyArgs>(args?: SelectSubset<T, BadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeUpdateManyArgs>(args: SelectSubset<T, BadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Badge.
     * @param {BadgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends BadgeUpsertArgs>(args: SelectSubset<T, BadgeUpsertArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends BadgeCountArgs>(
      args?: Subset<T, BadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): Prisma.PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Badge model
   */
  readonly fields: BadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userBadges<T extends Badge$userBadgesArgs<ExtArgs> = {}>(args?: Subset<T, Badge$userBadgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Badge model
   */ 
  interface BadgeFieldRefs {
    readonly id: FieldRef<"Badge", 'String'>
    readonly key: FieldRef<"Badge", 'String'>
    readonly title: FieldRef<"Badge", 'Json'>
    readonly description: FieldRef<"Badge", 'Json'>
    readonly criteria: FieldRef<"Badge", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Badge findUnique
   */
  export type BadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findUniqueOrThrow
   */
  export type BadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findFirst
   */
  export type BadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findFirstOrThrow
   */
  export type BadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findMany
   */
  export type BadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge create
   */
  export type BadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Badge.
     */
    data: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
  }

  /**
   * Badge createMany
   */
  export type BadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge createManyAndReturn
   */
  export type BadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge update
   */
  export type BadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Badge.
     */
    data: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
    /**
     * Choose, which Badge to update.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge updateMany
   */
  export type BadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
  }

  /**
   * Badge upsert
   */
  export type BadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Badge to update in case it exists.
     */
    where: BadgeWhereUniqueInput
    /**
     * In case the Badge found by the `where` argument doesn't exist, create a new Badge with this data.
     */
    create: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
    /**
     * In case the Badge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
  }

  /**
   * Badge delete
   */
  export type BadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter which Badge to delete.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge deleteMany
   */
  export type BadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badges to delete
     */
    where?: BadgeWhereInput
  }

  /**
   * Badge.userBadges
   */
  export type Badge$userBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    cursor?: UserBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * Badge without action
   */
  export type BadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
  }


  /**
   * Model UserBadge
   */

  export type AggregateUserBadge = {
    _count: UserBadgeCountAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  export type UserBadgeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    badgeId: string | null
    awardedAt: Date | null
  }

  export type UserBadgeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    badgeId: string | null
    awardedAt: Date | null
  }

  export type UserBadgeCountAggregateOutputType = {
    id: number
    userId: number
    badgeId: number
    awardedAt: number
    _all: number
  }


  export type UserBadgeMinAggregateInputType = {
    id?: true
    userId?: true
    badgeId?: true
    awardedAt?: true
  }

  export type UserBadgeMaxAggregateInputType = {
    id?: true
    userId?: true
    badgeId?: true
    awardedAt?: true
  }

  export type UserBadgeCountAggregateInputType = {
    id?: true
    userId?: true
    badgeId?: true
    awardedAt?: true
    _all?: true
  }

  export type UserBadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadge to aggregate.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBadges
    **/
    _count?: true | UserBadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBadgeMaxAggregateInputType
  }

  export type GetUserBadgeAggregateType<T extends UserBadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBadge[P]>
      : GetScalarType<T[P], AggregateUserBadge[P]>
  }




  export type UserBadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithAggregationInput | UserBadgeOrderByWithAggregationInput[]
    by: UserBadgeScalarFieldEnum[] | UserBadgeScalarFieldEnum
    having?: UserBadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBadgeCountAggregateInputType | true
    _min?: UserBadgeMinAggregateInputType
    _max?: UserBadgeMaxAggregateInputType
  }

  export type UserBadgeGroupByOutputType = {
    id: string
    userId: string
    badgeId: string
    awardedAt: Date
    _count: UserBadgeCountAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  type GetUserBadgeGroupByPayload<T extends UserBadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
            : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
        }
      >
    >


  export type UserBadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    badgeId?: boolean
    awardedAt?: boolean
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type UserBadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    badgeId?: boolean
    awardedAt?: boolean
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type UserBadgeSelectScalar = {
    id?: boolean
    userId?: boolean
    badgeId?: boolean
    awardedAt?: boolean
  }

  export type UserBadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserBadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserBadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBadge"
    objects: {
      badge: Prisma.$BadgePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      badgeId: string
      awardedAt: Date
    }, ExtArgs["result"]["userBadge"]>
    composites: {}
  }

  type UserBadgeGetPayload<S extends boolean | null | undefined | UserBadgeDefaultArgs> = $Result.GetResult<Prisma.$UserBadgePayload, S>

  type UserBadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserBadgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserBadgeCountAggregateInputType | true
    }

  export interface UserBadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBadge'], meta: { name: 'UserBadge' } }
    /**
     * Find zero or one UserBadge that matches the filter.
     * @param {UserBadgeFindUniqueArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBadgeFindUniqueArgs>(args: SelectSubset<T, UserBadgeFindUniqueArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserBadge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserBadgeFindUniqueOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserBadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBadgeFindFirstArgs>(args?: SelectSubset<T, UserBadgeFindFirstArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserBadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserBadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBadges
     * const userBadges = await prisma.userBadge.findMany()
     * 
     * // Get first 10 UserBadges
     * const userBadges = await prisma.userBadge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBadgeWithIdOnly = await prisma.userBadge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBadgeFindManyArgs>(args?: SelectSubset<T, UserBadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserBadge.
     * @param {UserBadgeCreateArgs} args - Arguments to create a UserBadge.
     * @example
     * // Create one UserBadge
     * const UserBadge = await prisma.userBadge.create({
     *   data: {
     *     // ... data to create a UserBadge
     *   }
     * })
     * 
     */
    create<T extends UserBadgeCreateArgs>(args: SelectSubset<T, UserBadgeCreateArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserBadges.
     * @param {UserBadgeCreateManyArgs} args - Arguments to create many UserBadges.
     * @example
     * // Create many UserBadges
     * const userBadge = await prisma.userBadge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBadgeCreateManyArgs>(args?: SelectSubset<T, UserBadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBadges and returns the data saved in the database.
     * @param {UserBadgeCreateManyAndReturnArgs} args - Arguments to create many UserBadges.
     * @example
     * // Create many UserBadges
     * const userBadge = await prisma.userBadge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBadges and only return the `id`
     * const userBadgeWithIdOnly = await prisma.userBadge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserBadge.
     * @param {UserBadgeDeleteArgs} args - Arguments to delete one UserBadge.
     * @example
     * // Delete one UserBadge
     * const UserBadge = await prisma.userBadge.delete({
     *   where: {
     *     // ... filter to delete one UserBadge
     *   }
     * })
     * 
     */
    delete<T extends UserBadgeDeleteArgs>(args: SelectSubset<T, UserBadgeDeleteArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserBadge.
     * @param {UserBadgeUpdateArgs} args - Arguments to update one UserBadge.
     * @example
     * // Update one UserBadge
     * const userBadge = await prisma.userBadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBadgeUpdateArgs>(args: SelectSubset<T, UserBadgeUpdateArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserBadges.
     * @param {UserBadgeDeleteManyArgs} args - Arguments to filter UserBadges to delete.
     * @example
     * // Delete a few UserBadges
     * const { count } = await prisma.userBadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBadgeDeleteManyArgs>(args?: SelectSubset<T, UserBadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBadges
     * const userBadge = await prisma.userBadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBadgeUpdateManyArgs>(args: SelectSubset<T, UserBadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserBadge.
     * @param {UserBadgeUpsertArgs} args - Arguments to update or create a UserBadge.
     * @example
     * // Update or create a UserBadge
     * const userBadge = await prisma.userBadge.upsert({
     *   create: {
     *     // ... data to create a UserBadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBadge we want to update
     *   }
     * })
     */
    upsert<T extends UserBadgeUpsertArgs>(args: SelectSubset<T, UserBadgeUpsertArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeCountArgs} args - Arguments to filter UserBadges to count.
     * @example
     * // Count the number of UserBadges
     * const count = await prisma.userBadge.count({
     *   where: {
     *     // ... the filter for the UserBadges we want to count
     *   }
     * })
    **/
    count<T extends UserBadgeCountArgs>(
      args?: Subset<T, UserBadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBadgeAggregateArgs>(args: Subset<T, UserBadgeAggregateArgs>): Prisma.PrismaPromise<GetUserBadgeAggregateType<T>>

    /**
     * Group by UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBadgeGroupByArgs['orderBy'] }
        : { orderBy?: UserBadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBadge model
   */
  readonly fields: UserBadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badge<T extends BadgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BadgeDefaultArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBadge model
   */ 
  interface UserBadgeFieldRefs {
    readonly id: FieldRef<"UserBadge", 'String'>
    readonly userId: FieldRef<"UserBadge", 'String'>
    readonly badgeId: FieldRef<"UserBadge", 'String'>
    readonly awardedAt: FieldRef<"UserBadge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserBadge findUnique
   */
  export type UserBadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge findUniqueOrThrow
   */
  export type UserBadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge findFirst
   */
  export type UserBadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge findFirstOrThrow
   */
  export type UserBadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge findMany
   */
  export type UserBadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadges to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge create
   */
  export type UserBadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBadge.
     */
    data: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
  }

  /**
   * UserBadge createMany
   */
  export type UserBadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBadges.
     */
    data: UserBadgeCreateManyInput | UserBadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBadge createManyAndReturn
   */
  export type UserBadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserBadges.
     */
    data: UserBadgeCreateManyInput | UserBadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBadge update
   */
  export type UserBadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBadge.
     */
    data: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
    /**
     * Choose, which UserBadge to update.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge updateMany
   */
  export type UserBadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBadges.
     */
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyInput>
    /**
     * Filter which UserBadges to update
     */
    where?: UserBadgeWhereInput
  }

  /**
   * UserBadge upsert
   */
  export type UserBadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBadge to update in case it exists.
     */
    where: UserBadgeWhereUniqueInput
    /**
     * In case the UserBadge found by the `where` argument doesn't exist, create a new UserBadge with this data.
     */
    create: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
    /**
     * In case the UserBadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
  }

  /**
   * UserBadge delete
   */
  export type UserBadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter which UserBadge to delete.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge deleteMany
   */
  export type UserBadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadges to delete
     */
    where?: UserBadgeWhereInput
  }

  /**
   * UserBadge without action
   */
  export type UserBadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    payload: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    payload?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    payload: JsonValue | null
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    payload?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    payload?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    payload?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      payload: Prisma.JsonValue | null
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly payload: FieldRef<"Notification", 'Json'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    pseudo: 'pseudo',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    profileUrl: 'profileUrl',
    coachId: 'coachId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const GroupMemberScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    userId: 'userId',
    roleInGroup: 'roleInGroup',
    joinedAt: 'joinedAt'
  };

  export type GroupMemberScalarFieldEnum = (typeof GroupMemberScalarFieldEnum)[keyof typeof GroupMemberScalarFieldEnum]


  export const InvitationScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    fromCoachId: 'fromCoachId',
    toUserId: 'toUserId',
    status: 'status',
    createdAt: 'createdAt',
    respondedAt: 'respondedAt'
  };

  export type InvitationScalarFieldEnum = (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum]


  export const ExerciseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    meta: 'meta',
    scope: 'scope',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExerciseScalarFieldEnum = (typeof ExerciseScalarFieldEnum)[keyof typeof ExerciseScalarFieldEnum]


  export const ExerciseRatingScalarFieldEnum: {
    id: 'id',
    exerciseId: 'exerciseId',
    userId: 'userId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExerciseRatingScalarFieldEnum = (typeof ExerciseRatingScalarFieldEnum)[keyof typeof ExerciseRatingScalarFieldEnum]


  export const ExerciseHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    exerciseId: 'exerciseId',
    viewedAt: 'viewedAt'
  };

  export type ExerciseHistoryScalarFieldEnum = (typeof ExerciseHistoryScalarFieldEnum)[keyof typeof ExerciseHistoryScalarFieldEnum]


  export const FavoriteExerciseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    exerciseId: 'exerciseId',
    addedAt: 'addedAt'
  };

  export type FavoriteExerciseScalarFieldEnum = (typeof FavoriteExerciseScalarFieldEnum)[keyof typeof FavoriteExerciseScalarFieldEnum]


  export const WorkoutSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    startedAt: 'startedAt',
    startTime: 'startTime',
    endedAt: 'endedAt',
    endTime: 'endTime',
    duration: 'duration',
    notes: 'notes',
    restPeriodSeconds: 'restPeriodSeconds',
    formGuidanceEnabled: 'formGuidanceEnabled',
    exercisesCompleted: 'exercisesCompleted',
    totalExercises: 'totalExercises'
  };

  export type WorkoutSessionScalarFieldEnum = (typeof WorkoutSessionScalarFieldEnum)[keyof typeof WorkoutSessionScalarFieldEnum]


  export const ExerciseLogScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    exerciseId: 'exerciseId',
    userId: 'userId',
    reps: 'reps',
    sets: 'sets',
    setsCompleted: 'setsCompleted',
    weight: 'weight',
    duration: 'duration',
    formRating: 'formRating',
    skipped: 'skipped',
    notes: 'notes',
    loggedAt: 'loggedAt',
    completedAt: 'completedAt'
  };

  export type ExerciseLogScalarFieldEnum = (typeof ExerciseLogScalarFieldEnum)[keyof typeof ExerciseLogScalarFieldEnum]


  export const ProgramScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    coachId: 'coachId',
    ownerId: 'ownerId',
    isDraft: 'isDraft',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProgramScalarFieldEnum = (typeof ProgramScalarFieldEnum)[keyof typeof ProgramScalarFieldEnum]


  export const ProgramBlockScalarFieldEnum: {
    id: 'id',
    programId: 'programId',
    title: 'title',
    position: 'position',
    notes: 'notes'
  };

  export type ProgramBlockScalarFieldEnum = (typeof ProgramBlockScalarFieldEnum)[keyof typeof ProgramBlockScalarFieldEnum]


  export const WeekScalarFieldEnum: {
    id: 'id',
    blockId: 'blockId',
    weekNumber: 'weekNumber',
    position: 'position'
  };

  export type WeekScalarFieldEnum = (typeof WeekScalarFieldEnum)[keyof typeof WeekScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    weekId: 'weekId',
    title: 'title',
    notes: 'notes',
    date: 'date',
    position: 'position',
    data: 'data'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const SessionExerciseScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    exerciseId: 'exerciseId',
    config: 'config',
    position: 'position'
  };

  export type SessionExerciseScalarFieldEnum = (typeof SessionExerciseScalarFieldEnum)[keyof typeof SessionExerciseScalarFieldEnum]


  export const SessionProgressScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    studentId: 'studentId',
    exerciseInstanceId: 'exerciseInstanceId',
    progress: 'progress',
    notes: 'notes',
    videos: 'videos',
    savedAt: 'savedAt'
  };

  export type SessionProgressScalarFieldEnum = (typeof SessionProgressScalarFieldEnum)[keyof typeof SessionProgressScalarFieldEnum]


  export const ProgramAssignmentScalarFieldEnum: {
    id: 'id',
    programId: 'programId',
    studentId: 'studentId',
    assignedBy: 'assignedBy',
    assignedAt: 'assignedAt'
  };

  export type ProgramAssignmentScalarFieldEnum = (typeof ProgramAssignmentScalarFieldEnum)[keyof typeof ProgramAssignmentScalarFieldEnum]


  export const ProgramAuditScalarFieldEnum: {
    id: 'id',
    programId: 'programId',
    changedBy: 'changedBy',
    changeType: 'changeType',
    diff: 'diff',
    createdAt: 'createdAt'
  };

  export type ProgramAuditScalarFieldEnum = (typeof ProgramAuditScalarFieldEnum)[keyof typeof ProgramAuditScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    id: 'id',
    key: 'key',
    title: 'title',
    description: 'description',
    criteria: 'criteria'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const UserBadgeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    badgeId: 'badgeId',
    awardedAt: 'awardedAt'
  };

  export type UserBadgeScalarFieldEnum = (typeof UserBadgeScalarFieldEnum)[keyof typeof UserBadgeScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    payload: 'payload',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'InvitationStatus'
   */
  export type EnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus'>
    


  /**
   * Reference to a field of type 'InvitationStatus[]'
   */
  export type ListEnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus[]'>
    


  /**
   * Reference to a field of type 'ExerciseType'
   */
  export type EnumExerciseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExerciseType'>
    


  /**
   * Reference to a field of type 'ExerciseType[]'
   */
  export type ListEnumExerciseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExerciseType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Scope'
   */
  export type EnumScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Scope'>
    


  /**
   * Reference to a field of type 'Scope[]'
   */
  export type ListEnumScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Scope[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    pseudo?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    profileUrl?: StringNullableFilter<"User"> | string | null
    coachId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdExercises?: ExerciseListRelationFilter
    groupMemberships?: GroupMemberListRelationFilter
    ownedGroups?: GroupListRelationFilter
    sentInvitations?: InvitationListRelationFilter
    receivedInvitations?: InvitationListRelationFilter
    notifications?: NotificationListRelationFilter
    assignedBy?: ProgramAssignmentListRelationFilter
    assignedPrograms?: ProgramAssignmentListRelationFilter
    auditLogs?: ProgramAuditListRelationFilter
    createdPrograms?: ProgramListRelationFilter
    sessionProgress?: SessionProgressListRelationFilter
    badges?: UserBadgeListRelationFilter
    exerciseRatings?: ExerciseRatingListRelationFilter
    exerciseHistory?: ExerciseHistoryListRelationFilter
    favoriteExercises?: FavoriteExerciseListRelationFilter
    workoutSessions?: WorkoutSessionListRelationFilter
    coach?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    students?: UserListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    pseudo?: SortOrder
    password?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    role?: SortOrder
    profileUrl?: SortOrderInput | SortOrder
    coachId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdExercises?: ExerciseOrderByRelationAggregateInput
    groupMemberships?: GroupMemberOrderByRelationAggregateInput
    ownedGroups?: GroupOrderByRelationAggregateInput
    sentInvitations?: InvitationOrderByRelationAggregateInput
    receivedInvitations?: InvitationOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    assignedBy?: ProgramAssignmentOrderByRelationAggregateInput
    assignedPrograms?: ProgramAssignmentOrderByRelationAggregateInput
    auditLogs?: ProgramAuditOrderByRelationAggregateInput
    createdPrograms?: ProgramOrderByRelationAggregateInput
    sessionProgress?: SessionProgressOrderByRelationAggregateInput
    badges?: UserBadgeOrderByRelationAggregateInput
    exerciseRatings?: ExerciseRatingOrderByRelationAggregateInput
    exerciseHistory?: ExerciseHistoryOrderByRelationAggregateInput
    favoriteExercises?: FavoriteExerciseOrderByRelationAggregateInput
    workoutSessions?: WorkoutSessionOrderByRelationAggregateInput
    coach?: UserOrderByWithRelationInput
    students?: UserOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    pseudo?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    profileUrl?: StringNullableFilter<"User"> | string | null
    coachId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdExercises?: ExerciseListRelationFilter
    groupMemberships?: GroupMemberListRelationFilter
    ownedGroups?: GroupListRelationFilter
    sentInvitations?: InvitationListRelationFilter
    receivedInvitations?: InvitationListRelationFilter
    notifications?: NotificationListRelationFilter
    assignedBy?: ProgramAssignmentListRelationFilter
    assignedPrograms?: ProgramAssignmentListRelationFilter
    auditLogs?: ProgramAuditListRelationFilter
    createdPrograms?: ProgramListRelationFilter
    sessionProgress?: SessionProgressListRelationFilter
    badges?: UserBadgeListRelationFilter
    exerciseRatings?: ExerciseRatingListRelationFilter
    exerciseHistory?: ExerciseHistoryListRelationFilter
    favoriteExercises?: FavoriteExerciseListRelationFilter
    workoutSessions?: WorkoutSessionListRelationFilter
    coach?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    students?: UserListRelationFilter
  }, "id" | "email" | "pseudo">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    pseudo?: SortOrder
    password?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    role?: SortOrder
    profileUrl?: SortOrderInput | SortOrder
    coachId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    pseudo?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    profileUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    coachId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: StringFilter<"Group"> | string
    ownerId?: StringFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    members?: GroupMemberListRelationFilter
    owner?: XOR<UserRelationFilter, UserWhereInput>
    invitations?: InvitationListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: GroupMemberOrderByRelationAggregateInput
    owner?: UserOrderByWithRelationInput
    invitations?: InvitationOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    ownerId?: StringFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    members?: GroupMemberListRelationFilter
    owner?: XOR<UserRelationFilter, UserWhereInput>
    invitations?: InvitationListRelationFilter
  }, "id">

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Group"> | string
    ownerId?: StringWithAggregatesFilter<"Group"> | string
    name?: StringWithAggregatesFilter<"Group"> | string
    description?: StringNullableWithAggregatesFilter<"Group"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
  }

  export type GroupMemberWhereInput = {
    AND?: GroupMemberWhereInput | GroupMemberWhereInput[]
    OR?: GroupMemberWhereInput[]
    NOT?: GroupMemberWhereInput | GroupMemberWhereInput[]
    id?: StringFilter<"GroupMember"> | string
    groupId?: StringFilter<"GroupMember"> | string
    userId?: StringFilter<"GroupMember"> | string
    roleInGroup?: StringFilter<"GroupMember"> | string
    joinedAt?: DateTimeFilter<"GroupMember"> | Date | string
    group?: XOR<GroupRelationFilter, GroupWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type GroupMemberOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    roleInGroup?: SortOrder
    joinedAt?: SortOrder
    group?: GroupOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type GroupMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    groupId_userId?: GroupMemberGroupIdUserIdCompoundUniqueInput
    AND?: GroupMemberWhereInput | GroupMemberWhereInput[]
    OR?: GroupMemberWhereInput[]
    NOT?: GroupMemberWhereInput | GroupMemberWhereInput[]
    groupId?: StringFilter<"GroupMember"> | string
    userId?: StringFilter<"GroupMember"> | string
    roleInGroup?: StringFilter<"GroupMember"> | string
    joinedAt?: DateTimeFilter<"GroupMember"> | Date | string
    group?: XOR<GroupRelationFilter, GroupWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "groupId_userId">

  export type GroupMemberOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    roleInGroup?: SortOrder
    joinedAt?: SortOrder
    _count?: GroupMemberCountOrderByAggregateInput
    _max?: GroupMemberMaxOrderByAggregateInput
    _min?: GroupMemberMinOrderByAggregateInput
  }

  export type GroupMemberScalarWhereWithAggregatesInput = {
    AND?: GroupMemberScalarWhereWithAggregatesInput | GroupMemberScalarWhereWithAggregatesInput[]
    OR?: GroupMemberScalarWhereWithAggregatesInput[]
    NOT?: GroupMemberScalarWhereWithAggregatesInput | GroupMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GroupMember"> | string
    groupId?: StringWithAggregatesFilter<"GroupMember"> | string
    userId?: StringWithAggregatesFilter<"GroupMember"> | string
    roleInGroup?: StringWithAggregatesFilter<"GroupMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"GroupMember"> | Date | string
  }

  export type InvitationWhereInput = {
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    id?: StringFilter<"Invitation"> | string
    groupId?: StringFilter<"Invitation"> | string
    fromCoachId?: StringFilter<"Invitation"> | string
    toUserId?: StringFilter<"Invitation"> | string
    status?: EnumInvitationStatusFilter<"Invitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeFilter<"Invitation"> | Date | string
    respondedAt?: DateTimeNullableFilter<"Invitation"> | Date | string | null
    fromCoach?: XOR<UserRelationFilter, UserWhereInput>
    group?: XOR<GroupRelationFilter, GroupWhereInput>
    toUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type InvitationOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    fromCoachId?: SortOrder
    toUserId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    fromCoach?: UserOrderByWithRelationInput
    group?: GroupOrderByWithRelationInput
    toUser?: UserOrderByWithRelationInput
  }

  export type InvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    groupId_toUserId_status?: InvitationGroupIdToUserIdStatusCompoundUniqueInput
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    groupId?: StringFilter<"Invitation"> | string
    fromCoachId?: StringFilter<"Invitation"> | string
    toUserId?: StringFilter<"Invitation"> | string
    status?: EnumInvitationStatusFilter<"Invitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeFilter<"Invitation"> | Date | string
    respondedAt?: DateTimeNullableFilter<"Invitation"> | Date | string | null
    fromCoach?: XOR<UserRelationFilter, UserWhereInput>
    group?: XOR<GroupRelationFilter, GroupWhereInput>
    toUser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "groupId_toUserId_status">

  export type InvitationOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    fromCoachId?: SortOrder
    toUserId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    _count?: InvitationCountOrderByAggregateInput
    _max?: InvitationMaxOrderByAggregateInput
    _min?: InvitationMinOrderByAggregateInput
  }

  export type InvitationScalarWhereWithAggregatesInput = {
    AND?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    OR?: InvitationScalarWhereWithAggregatesInput[]
    NOT?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invitation"> | string
    groupId?: StringWithAggregatesFilter<"Invitation"> | string
    fromCoachId?: StringWithAggregatesFilter<"Invitation"> | string
    toUserId?: StringWithAggregatesFilter<"Invitation"> | string
    status?: EnumInvitationStatusWithAggregatesFilter<"Invitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeWithAggregatesFilter<"Invitation"> | Date | string
    respondedAt?: DateTimeNullableWithAggregatesFilter<"Invitation"> | Date | string | null
  }

  export type ExerciseWhereInput = {
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    id?: StringFilter<"Exercise"> | string
    name?: StringFilter<"Exercise"> | string
    description?: StringNullableFilter<"Exercise"> | string | null
    type?: EnumExerciseTypeFilter<"Exercise"> | $Enums.ExerciseType
    meta?: JsonNullableFilter<"Exercise">
    scope?: EnumScopeFilter<"Exercise"> | $Enums.Scope
    ownerId?: StringNullableFilter<"Exercise"> | string | null
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeFilter<"Exercise"> | Date | string
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    sessionExercises?: SessionExerciseListRelationFilter
    ratings?: ExerciseRatingListRelationFilter
    history?: ExerciseHistoryListRelationFilter
    favorites?: FavoriteExerciseListRelationFilter
    logs?: ExerciseLogListRelationFilter
  }

  export type ExerciseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    meta?: SortOrderInput | SortOrder
    scope?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    sessionExercises?: SessionExerciseOrderByRelationAggregateInput
    ratings?: ExerciseRatingOrderByRelationAggregateInput
    history?: ExerciseHistoryOrderByRelationAggregateInput
    favorites?: FavoriteExerciseOrderByRelationAggregateInput
    logs?: ExerciseLogOrderByRelationAggregateInput
  }

  export type ExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    name?: StringFilter<"Exercise"> | string
    description?: StringNullableFilter<"Exercise"> | string | null
    type?: EnumExerciseTypeFilter<"Exercise"> | $Enums.ExerciseType
    meta?: JsonNullableFilter<"Exercise">
    scope?: EnumScopeFilter<"Exercise"> | $Enums.Scope
    ownerId?: StringNullableFilter<"Exercise"> | string | null
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeFilter<"Exercise"> | Date | string
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    sessionExercises?: SessionExerciseListRelationFilter
    ratings?: ExerciseRatingListRelationFilter
    history?: ExerciseHistoryListRelationFilter
    favorites?: FavoriteExerciseListRelationFilter
    logs?: ExerciseLogListRelationFilter
  }, "id">

  export type ExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    meta?: SortOrderInput | SortOrder
    scope?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExerciseCountOrderByAggregateInput
    _max?: ExerciseMaxOrderByAggregateInput
    _min?: ExerciseMinOrderByAggregateInput
  }

  export type ExerciseScalarWhereWithAggregatesInput = {
    AND?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    OR?: ExerciseScalarWhereWithAggregatesInput[]
    NOT?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exercise"> | string
    name?: StringWithAggregatesFilter<"Exercise"> | string
    description?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    type?: EnumExerciseTypeWithAggregatesFilter<"Exercise"> | $Enums.ExerciseType
    meta?: JsonNullableWithAggregatesFilter<"Exercise">
    scope?: EnumScopeWithAggregatesFilter<"Exercise"> | $Enums.Scope
    ownerId?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exercise"> | Date | string
  }

  export type ExerciseRatingWhereInput = {
    AND?: ExerciseRatingWhereInput | ExerciseRatingWhereInput[]
    OR?: ExerciseRatingWhereInput[]
    NOT?: ExerciseRatingWhereInput | ExerciseRatingWhereInput[]
    id?: StringFilter<"ExerciseRating"> | string
    exerciseId?: StringFilter<"ExerciseRating"> | string
    userId?: StringFilter<"ExerciseRating"> | string
    rating?: IntFilter<"ExerciseRating"> | number
    comment?: StringNullableFilter<"ExerciseRating"> | string | null
    createdAt?: DateTimeFilter<"ExerciseRating"> | Date | string
    updatedAt?: DateTimeFilter<"ExerciseRating"> | Date | string
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ExerciseRatingOrderByWithRelationInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    exercise?: ExerciseOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ExerciseRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    exerciseId_userId?: ExerciseRatingExerciseIdUserIdCompoundUniqueInput
    AND?: ExerciseRatingWhereInput | ExerciseRatingWhereInput[]
    OR?: ExerciseRatingWhereInput[]
    NOT?: ExerciseRatingWhereInput | ExerciseRatingWhereInput[]
    exerciseId?: StringFilter<"ExerciseRating"> | string
    userId?: StringFilter<"ExerciseRating"> | string
    rating?: IntFilter<"ExerciseRating"> | number
    comment?: StringNullableFilter<"ExerciseRating"> | string | null
    createdAt?: DateTimeFilter<"ExerciseRating"> | Date | string
    updatedAt?: DateTimeFilter<"ExerciseRating"> | Date | string
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "exerciseId_userId">

  export type ExerciseRatingOrderByWithAggregationInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExerciseRatingCountOrderByAggregateInput
    _avg?: ExerciseRatingAvgOrderByAggregateInput
    _max?: ExerciseRatingMaxOrderByAggregateInput
    _min?: ExerciseRatingMinOrderByAggregateInput
    _sum?: ExerciseRatingSumOrderByAggregateInput
  }

  export type ExerciseRatingScalarWhereWithAggregatesInput = {
    AND?: ExerciseRatingScalarWhereWithAggregatesInput | ExerciseRatingScalarWhereWithAggregatesInput[]
    OR?: ExerciseRatingScalarWhereWithAggregatesInput[]
    NOT?: ExerciseRatingScalarWhereWithAggregatesInput | ExerciseRatingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExerciseRating"> | string
    exerciseId?: StringWithAggregatesFilter<"ExerciseRating"> | string
    userId?: StringWithAggregatesFilter<"ExerciseRating"> | string
    rating?: IntWithAggregatesFilter<"ExerciseRating"> | number
    comment?: StringNullableWithAggregatesFilter<"ExerciseRating"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ExerciseRating"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExerciseRating"> | Date | string
  }

  export type ExerciseHistoryWhereInput = {
    AND?: ExerciseHistoryWhereInput | ExerciseHistoryWhereInput[]
    OR?: ExerciseHistoryWhereInput[]
    NOT?: ExerciseHistoryWhereInput | ExerciseHistoryWhereInput[]
    id?: StringFilter<"ExerciseHistory"> | string
    userId?: StringFilter<"ExerciseHistory"> | string
    exerciseId?: StringFilter<"ExerciseHistory"> | string
    viewedAt?: DateTimeFilter<"ExerciseHistory"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
  }

  export type ExerciseHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseId?: SortOrder
    viewedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    exercise?: ExerciseOrderByWithRelationInput
  }

  export type ExerciseHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExerciseHistoryWhereInput | ExerciseHistoryWhereInput[]
    OR?: ExerciseHistoryWhereInput[]
    NOT?: ExerciseHistoryWhereInput | ExerciseHistoryWhereInput[]
    userId?: StringFilter<"ExerciseHistory"> | string
    exerciseId?: StringFilter<"ExerciseHistory"> | string
    viewedAt?: DateTimeFilter<"ExerciseHistory"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
  }, "id">

  export type ExerciseHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseId?: SortOrder
    viewedAt?: SortOrder
    _count?: ExerciseHistoryCountOrderByAggregateInput
    _max?: ExerciseHistoryMaxOrderByAggregateInput
    _min?: ExerciseHistoryMinOrderByAggregateInput
  }

  export type ExerciseHistoryScalarWhereWithAggregatesInput = {
    AND?: ExerciseHistoryScalarWhereWithAggregatesInput | ExerciseHistoryScalarWhereWithAggregatesInput[]
    OR?: ExerciseHistoryScalarWhereWithAggregatesInput[]
    NOT?: ExerciseHistoryScalarWhereWithAggregatesInput | ExerciseHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExerciseHistory"> | string
    userId?: StringWithAggregatesFilter<"ExerciseHistory"> | string
    exerciseId?: StringWithAggregatesFilter<"ExerciseHistory"> | string
    viewedAt?: DateTimeWithAggregatesFilter<"ExerciseHistory"> | Date | string
  }

  export type FavoriteExerciseWhereInput = {
    AND?: FavoriteExerciseWhereInput | FavoriteExerciseWhereInput[]
    OR?: FavoriteExerciseWhereInput[]
    NOT?: FavoriteExerciseWhereInput | FavoriteExerciseWhereInput[]
    id?: StringFilter<"FavoriteExercise"> | string
    userId?: StringFilter<"FavoriteExercise"> | string
    exerciseId?: StringFilter<"FavoriteExercise"> | string
    addedAt?: DateTimeFilter<"FavoriteExercise"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
  }

  export type FavoriteExerciseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseId?: SortOrder
    addedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    exercise?: ExerciseOrderByWithRelationInput
  }

  export type FavoriteExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_exerciseId?: FavoriteExerciseUserIdExerciseIdCompoundUniqueInput
    AND?: FavoriteExerciseWhereInput | FavoriteExerciseWhereInput[]
    OR?: FavoriteExerciseWhereInput[]
    NOT?: FavoriteExerciseWhereInput | FavoriteExerciseWhereInput[]
    userId?: StringFilter<"FavoriteExercise"> | string
    exerciseId?: StringFilter<"FavoriteExercise"> | string
    addedAt?: DateTimeFilter<"FavoriteExercise"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
  }, "id" | "userId_exerciseId">

  export type FavoriteExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseId?: SortOrder
    addedAt?: SortOrder
    _count?: FavoriteExerciseCountOrderByAggregateInput
    _max?: FavoriteExerciseMaxOrderByAggregateInput
    _min?: FavoriteExerciseMinOrderByAggregateInput
  }

  export type FavoriteExerciseScalarWhereWithAggregatesInput = {
    AND?: FavoriteExerciseScalarWhereWithAggregatesInput | FavoriteExerciseScalarWhereWithAggregatesInput[]
    OR?: FavoriteExerciseScalarWhereWithAggregatesInput[]
    NOT?: FavoriteExerciseScalarWhereWithAggregatesInput | FavoriteExerciseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FavoriteExercise"> | string
    userId?: StringWithAggregatesFilter<"FavoriteExercise"> | string
    exerciseId?: StringWithAggregatesFilter<"FavoriteExercise"> | string
    addedAt?: DateTimeWithAggregatesFilter<"FavoriteExercise"> | Date | string
  }

  export type WorkoutSessionWhereInput = {
    AND?: WorkoutSessionWhereInput | WorkoutSessionWhereInput[]
    OR?: WorkoutSessionWhereInput[]
    NOT?: WorkoutSessionWhereInput | WorkoutSessionWhereInput[]
    id?: StringFilter<"WorkoutSession"> | string
    userId?: StringFilter<"WorkoutSession"> | string
    title?: StringNullableFilter<"WorkoutSession"> | string | null
    startedAt?: DateTimeFilter<"WorkoutSession"> | Date | string
    startTime?: DateTimeNullableFilter<"WorkoutSession"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"WorkoutSession"> | Date | string | null
    endTime?: DateTimeNullableFilter<"WorkoutSession"> | Date | string | null
    duration?: IntNullableFilter<"WorkoutSession"> | number | null
    notes?: StringNullableFilter<"WorkoutSession"> | string | null
    restPeriodSeconds?: IntNullableFilter<"WorkoutSession"> | number | null
    formGuidanceEnabled?: BoolNullableFilter<"WorkoutSession"> | boolean | null
    exercisesCompleted?: IntNullableFilter<"WorkoutSession"> | number | null
    totalExercises?: IntNullableFilter<"WorkoutSession"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    logs?: ExerciseLogListRelationFilter
  }

  export type WorkoutSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    restPeriodSeconds?: SortOrderInput | SortOrder
    formGuidanceEnabled?: SortOrderInput | SortOrder
    exercisesCompleted?: SortOrderInput | SortOrder
    totalExercises?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    logs?: ExerciseLogOrderByRelationAggregateInput
  }

  export type WorkoutSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkoutSessionWhereInput | WorkoutSessionWhereInput[]
    OR?: WorkoutSessionWhereInput[]
    NOT?: WorkoutSessionWhereInput | WorkoutSessionWhereInput[]
    userId?: StringFilter<"WorkoutSession"> | string
    title?: StringNullableFilter<"WorkoutSession"> | string | null
    startedAt?: DateTimeFilter<"WorkoutSession"> | Date | string
    startTime?: DateTimeNullableFilter<"WorkoutSession"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"WorkoutSession"> | Date | string | null
    endTime?: DateTimeNullableFilter<"WorkoutSession"> | Date | string | null
    duration?: IntNullableFilter<"WorkoutSession"> | number | null
    notes?: StringNullableFilter<"WorkoutSession"> | string | null
    restPeriodSeconds?: IntNullableFilter<"WorkoutSession"> | number | null
    formGuidanceEnabled?: BoolNullableFilter<"WorkoutSession"> | boolean | null
    exercisesCompleted?: IntNullableFilter<"WorkoutSession"> | number | null
    totalExercises?: IntNullableFilter<"WorkoutSession"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    logs?: ExerciseLogListRelationFilter
  }, "id">

  export type WorkoutSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    restPeriodSeconds?: SortOrderInput | SortOrder
    formGuidanceEnabled?: SortOrderInput | SortOrder
    exercisesCompleted?: SortOrderInput | SortOrder
    totalExercises?: SortOrderInput | SortOrder
    _count?: WorkoutSessionCountOrderByAggregateInput
    _avg?: WorkoutSessionAvgOrderByAggregateInput
    _max?: WorkoutSessionMaxOrderByAggregateInput
    _min?: WorkoutSessionMinOrderByAggregateInput
    _sum?: WorkoutSessionSumOrderByAggregateInput
  }

  export type WorkoutSessionScalarWhereWithAggregatesInput = {
    AND?: WorkoutSessionScalarWhereWithAggregatesInput | WorkoutSessionScalarWhereWithAggregatesInput[]
    OR?: WorkoutSessionScalarWhereWithAggregatesInput[]
    NOT?: WorkoutSessionScalarWhereWithAggregatesInput | WorkoutSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkoutSession"> | string
    userId?: StringWithAggregatesFilter<"WorkoutSession"> | string
    title?: StringNullableWithAggregatesFilter<"WorkoutSession"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"WorkoutSession"> | Date | string
    startTime?: DateTimeNullableWithAggregatesFilter<"WorkoutSession"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"WorkoutSession"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"WorkoutSession"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"WorkoutSession"> | number | null
    notes?: StringNullableWithAggregatesFilter<"WorkoutSession"> | string | null
    restPeriodSeconds?: IntNullableWithAggregatesFilter<"WorkoutSession"> | number | null
    formGuidanceEnabled?: BoolNullableWithAggregatesFilter<"WorkoutSession"> | boolean | null
    exercisesCompleted?: IntNullableWithAggregatesFilter<"WorkoutSession"> | number | null
    totalExercises?: IntNullableWithAggregatesFilter<"WorkoutSession"> | number | null
  }

  export type ExerciseLogWhereInput = {
    AND?: ExerciseLogWhereInput | ExerciseLogWhereInput[]
    OR?: ExerciseLogWhereInput[]
    NOT?: ExerciseLogWhereInput | ExerciseLogWhereInput[]
    id?: StringFilter<"ExerciseLog"> | string
    sessionId?: StringFilter<"ExerciseLog"> | string
    exerciseId?: StringFilter<"ExerciseLog"> | string
    userId?: StringNullableFilter<"ExerciseLog"> | string | null
    reps?: IntNullableFilter<"ExerciseLog"> | number | null
    sets?: IntNullableFilter<"ExerciseLog"> | number | null
    setsCompleted?: IntNullableFilter<"ExerciseLog"> | number | null
    weight?: FloatNullableFilter<"ExerciseLog"> | number | null
    duration?: IntNullableFilter<"ExerciseLog"> | number | null
    formRating?: IntNullableFilter<"ExerciseLog"> | number | null
    skipped?: BoolNullableFilter<"ExerciseLog"> | boolean | null
    notes?: StringNullableFilter<"ExerciseLog"> | string | null
    loggedAt?: DateTimeFilter<"ExerciseLog"> | Date | string
    completedAt?: DateTimeNullableFilter<"ExerciseLog"> | Date | string | null
    session?: XOR<WorkoutSessionRelationFilter, WorkoutSessionWhereInput>
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
  }

  export type ExerciseLogOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    exerciseId?: SortOrder
    userId?: SortOrderInput | SortOrder
    reps?: SortOrderInput | SortOrder
    sets?: SortOrderInput | SortOrder
    setsCompleted?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    formRating?: SortOrderInput | SortOrder
    skipped?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    loggedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    session?: WorkoutSessionOrderByWithRelationInput
    exercise?: ExerciseOrderByWithRelationInput
  }

  export type ExerciseLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExerciseLogWhereInput | ExerciseLogWhereInput[]
    OR?: ExerciseLogWhereInput[]
    NOT?: ExerciseLogWhereInput | ExerciseLogWhereInput[]
    sessionId?: StringFilter<"ExerciseLog"> | string
    exerciseId?: StringFilter<"ExerciseLog"> | string
    userId?: StringNullableFilter<"ExerciseLog"> | string | null
    reps?: IntNullableFilter<"ExerciseLog"> | number | null
    sets?: IntNullableFilter<"ExerciseLog"> | number | null
    setsCompleted?: IntNullableFilter<"ExerciseLog"> | number | null
    weight?: FloatNullableFilter<"ExerciseLog"> | number | null
    duration?: IntNullableFilter<"ExerciseLog"> | number | null
    formRating?: IntNullableFilter<"ExerciseLog"> | number | null
    skipped?: BoolNullableFilter<"ExerciseLog"> | boolean | null
    notes?: StringNullableFilter<"ExerciseLog"> | string | null
    loggedAt?: DateTimeFilter<"ExerciseLog"> | Date | string
    completedAt?: DateTimeNullableFilter<"ExerciseLog"> | Date | string | null
    session?: XOR<WorkoutSessionRelationFilter, WorkoutSessionWhereInput>
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
  }, "id">

  export type ExerciseLogOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    exerciseId?: SortOrder
    userId?: SortOrderInput | SortOrder
    reps?: SortOrderInput | SortOrder
    sets?: SortOrderInput | SortOrder
    setsCompleted?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    formRating?: SortOrderInput | SortOrder
    skipped?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    loggedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: ExerciseLogCountOrderByAggregateInput
    _avg?: ExerciseLogAvgOrderByAggregateInput
    _max?: ExerciseLogMaxOrderByAggregateInput
    _min?: ExerciseLogMinOrderByAggregateInput
    _sum?: ExerciseLogSumOrderByAggregateInput
  }

  export type ExerciseLogScalarWhereWithAggregatesInput = {
    AND?: ExerciseLogScalarWhereWithAggregatesInput | ExerciseLogScalarWhereWithAggregatesInput[]
    OR?: ExerciseLogScalarWhereWithAggregatesInput[]
    NOT?: ExerciseLogScalarWhereWithAggregatesInput | ExerciseLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExerciseLog"> | string
    sessionId?: StringWithAggregatesFilter<"ExerciseLog"> | string
    exerciseId?: StringWithAggregatesFilter<"ExerciseLog"> | string
    userId?: StringNullableWithAggregatesFilter<"ExerciseLog"> | string | null
    reps?: IntNullableWithAggregatesFilter<"ExerciseLog"> | number | null
    sets?: IntNullableWithAggregatesFilter<"ExerciseLog"> | number | null
    setsCompleted?: IntNullableWithAggregatesFilter<"ExerciseLog"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"ExerciseLog"> | number | null
    duration?: IntNullableWithAggregatesFilter<"ExerciseLog"> | number | null
    formRating?: IntNullableWithAggregatesFilter<"ExerciseLog"> | number | null
    skipped?: BoolNullableWithAggregatesFilter<"ExerciseLog"> | boolean | null
    notes?: StringNullableWithAggregatesFilter<"ExerciseLog"> | string | null
    loggedAt?: DateTimeWithAggregatesFilter<"ExerciseLog"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"ExerciseLog"> | Date | string | null
  }

  export type ProgramWhereInput = {
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    id?: StringFilter<"Program"> | string
    title?: StringFilter<"Program"> | string
    description?: StringNullableFilter<"Program"> | string | null
    coachId?: StringFilter<"Program"> | string
    ownerId?: StringNullableFilter<"Program"> | string | null
    isDraft?: BoolFilter<"Program"> | boolean
    data?: JsonNullableFilter<"Program">
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
    assignments?: ProgramAssignmentListRelationFilter
    auditLogs?: ProgramAuditListRelationFilter
    blocks?: ProgramBlockListRelationFilter
    coach?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProgramOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    coachId?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    isDraft?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignments?: ProgramAssignmentOrderByRelationAggregateInput
    auditLogs?: ProgramAuditOrderByRelationAggregateInput
    blocks?: ProgramBlockOrderByRelationAggregateInput
    coach?: UserOrderByWithRelationInput
  }

  export type ProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    title?: StringFilter<"Program"> | string
    description?: StringNullableFilter<"Program"> | string | null
    coachId?: StringFilter<"Program"> | string
    ownerId?: StringNullableFilter<"Program"> | string | null
    isDraft?: BoolFilter<"Program"> | boolean
    data?: JsonNullableFilter<"Program">
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
    assignments?: ProgramAssignmentListRelationFilter
    auditLogs?: ProgramAuditListRelationFilter
    blocks?: ProgramBlockListRelationFilter
    coach?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ProgramOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    coachId?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    isDraft?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProgramCountOrderByAggregateInput
    _max?: ProgramMaxOrderByAggregateInput
    _min?: ProgramMinOrderByAggregateInput
  }

  export type ProgramScalarWhereWithAggregatesInput = {
    AND?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    OR?: ProgramScalarWhereWithAggregatesInput[]
    NOT?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Program"> | string
    title?: StringWithAggregatesFilter<"Program"> | string
    description?: StringNullableWithAggregatesFilter<"Program"> | string | null
    coachId?: StringWithAggregatesFilter<"Program"> | string
    ownerId?: StringNullableWithAggregatesFilter<"Program"> | string | null
    isDraft?: BoolWithAggregatesFilter<"Program"> | boolean
    data?: JsonNullableWithAggregatesFilter<"Program">
    createdAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
  }

  export type ProgramBlockWhereInput = {
    AND?: ProgramBlockWhereInput | ProgramBlockWhereInput[]
    OR?: ProgramBlockWhereInput[]
    NOT?: ProgramBlockWhereInput | ProgramBlockWhereInput[]
    id?: StringFilter<"ProgramBlock"> | string
    programId?: StringFilter<"ProgramBlock"> | string
    title?: StringNullableFilter<"ProgramBlock"> | string | null
    position?: IntFilter<"ProgramBlock"> | number
    notes?: StringNullableFilter<"ProgramBlock"> | string | null
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    weeks?: WeekListRelationFilter
  }

  export type ProgramBlockOrderByWithRelationInput = {
    id?: SortOrder
    programId?: SortOrder
    title?: SortOrderInput | SortOrder
    position?: SortOrder
    notes?: SortOrderInput | SortOrder
    program?: ProgramOrderByWithRelationInput
    weeks?: WeekOrderByRelationAggregateInput
  }

  export type ProgramBlockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProgramBlockWhereInput | ProgramBlockWhereInput[]
    OR?: ProgramBlockWhereInput[]
    NOT?: ProgramBlockWhereInput | ProgramBlockWhereInput[]
    programId?: StringFilter<"ProgramBlock"> | string
    title?: StringNullableFilter<"ProgramBlock"> | string | null
    position?: IntFilter<"ProgramBlock"> | number
    notes?: StringNullableFilter<"ProgramBlock"> | string | null
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    weeks?: WeekListRelationFilter
  }, "id">

  export type ProgramBlockOrderByWithAggregationInput = {
    id?: SortOrder
    programId?: SortOrder
    title?: SortOrderInput | SortOrder
    position?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: ProgramBlockCountOrderByAggregateInput
    _avg?: ProgramBlockAvgOrderByAggregateInput
    _max?: ProgramBlockMaxOrderByAggregateInput
    _min?: ProgramBlockMinOrderByAggregateInput
    _sum?: ProgramBlockSumOrderByAggregateInput
  }

  export type ProgramBlockScalarWhereWithAggregatesInput = {
    AND?: ProgramBlockScalarWhereWithAggregatesInput | ProgramBlockScalarWhereWithAggregatesInput[]
    OR?: ProgramBlockScalarWhereWithAggregatesInput[]
    NOT?: ProgramBlockScalarWhereWithAggregatesInput | ProgramBlockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProgramBlock"> | string
    programId?: StringWithAggregatesFilter<"ProgramBlock"> | string
    title?: StringNullableWithAggregatesFilter<"ProgramBlock"> | string | null
    position?: IntWithAggregatesFilter<"ProgramBlock"> | number
    notes?: StringNullableWithAggregatesFilter<"ProgramBlock"> | string | null
  }

  export type WeekWhereInput = {
    AND?: WeekWhereInput | WeekWhereInput[]
    OR?: WeekWhereInput[]
    NOT?: WeekWhereInput | WeekWhereInput[]
    id?: StringFilter<"Week"> | string
    blockId?: StringFilter<"Week"> | string
    weekNumber?: IntFilter<"Week"> | number
    position?: IntFilter<"Week"> | number
    sessions?: SessionListRelationFilter
    block?: XOR<ProgramBlockRelationFilter, ProgramBlockWhereInput>
  }

  export type WeekOrderByWithRelationInput = {
    id?: SortOrder
    blockId?: SortOrder
    weekNumber?: SortOrder
    position?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    block?: ProgramBlockOrderByWithRelationInput
  }

  export type WeekWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WeekWhereInput | WeekWhereInput[]
    OR?: WeekWhereInput[]
    NOT?: WeekWhereInput | WeekWhereInput[]
    blockId?: StringFilter<"Week"> | string
    weekNumber?: IntFilter<"Week"> | number
    position?: IntFilter<"Week"> | number
    sessions?: SessionListRelationFilter
    block?: XOR<ProgramBlockRelationFilter, ProgramBlockWhereInput>
  }, "id">

  export type WeekOrderByWithAggregationInput = {
    id?: SortOrder
    blockId?: SortOrder
    weekNumber?: SortOrder
    position?: SortOrder
    _count?: WeekCountOrderByAggregateInput
    _avg?: WeekAvgOrderByAggregateInput
    _max?: WeekMaxOrderByAggregateInput
    _min?: WeekMinOrderByAggregateInput
    _sum?: WeekSumOrderByAggregateInput
  }

  export type WeekScalarWhereWithAggregatesInput = {
    AND?: WeekScalarWhereWithAggregatesInput | WeekScalarWhereWithAggregatesInput[]
    OR?: WeekScalarWhereWithAggregatesInput[]
    NOT?: WeekScalarWhereWithAggregatesInput | WeekScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Week"> | string
    blockId?: StringWithAggregatesFilter<"Week"> | string
    weekNumber?: IntWithAggregatesFilter<"Week"> | number
    position?: IntWithAggregatesFilter<"Week"> | number
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    weekId?: StringFilter<"Session"> | string
    title?: StringNullableFilter<"Session"> | string | null
    notes?: StringNullableFilter<"Session"> | string | null
    date?: DateTimeNullableFilter<"Session"> | Date | string | null
    position?: IntFilter<"Session"> | number
    data?: JsonNullableFilter<"Session">
    exercises?: SessionExerciseListRelationFilter
    progress?: SessionProgressListRelationFilter
    week?: XOR<WeekRelationFilter, WeekWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    weekId?: SortOrder
    title?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    position?: SortOrder
    data?: SortOrderInput | SortOrder
    exercises?: SessionExerciseOrderByRelationAggregateInput
    progress?: SessionProgressOrderByRelationAggregateInput
    week?: WeekOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    weekId?: StringFilter<"Session"> | string
    title?: StringNullableFilter<"Session"> | string | null
    notes?: StringNullableFilter<"Session"> | string | null
    date?: DateTimeNullableFilter<"Session"> | Date | string | null
    position?: IntFilter<"Session"> | number
    data?: JsonNullableFilter<"Session">
    exercises?: SessionExerciseListRelationFilter
    progress?: SessionProgressListRelationFilter
    week?: XOR<WeekRelationFilter, WeekWhereInput>
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    weekId?: SortOrder
    title?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    position?: SortOrder
    data?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    weekId?: StringWithAggregatesFilter<"Session"> | string
    title?: StringNullableWithAggregatesFilter<"Session"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Session"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    position?: IntWithAggregatesFilter<"Session"> | number
    data?: JsonNullableWithAggregatesFilter<"Session">
  }

  export type SessionExerciseWhereInput = {
    AND?: SessionExerciseWhereInput | SessionExerciseWhereInput[]
    OR?: SessionExerciseWhereInput[]
    NOT?: SessionExerciseWhereInput | SessionExerciseWhereInput[]
    id?: StringFilter<"SessionExercise"> | string
    sessionId?: StringFilter<"SessionExercise"> | string
    exerciseId?: StringFilter<"SessionExercise"> | string
    config?: JsonNullableFilter<"SessionExercise">
    position?: IntFilter<"SessionExercise"> | number
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
    session?: XOR<SessionRelationFilter, SessionWhereInput>
    progressInstances?: SessionProgressListRelationFilter
  }

  export type SessionExerciseOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    exerciseId?: SortOrder
    config?: SortOrderInput | SortOrder
    position?: SortOrder
    exercise?: ExerciseOrderByWithRelationInput
    session?: SessionOrderByWithRelationInput
    progressInstances?: SessionProgressOrderByRelationAggregateInput
  }

  export type SessionExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionExerciseWhereInput | SessionExerciseWhereInput[]
    OR?: SessionExerciseWhereInput[]
    NOT?: SessionExerciseWhereInput | SessionExerciseWhereInput[]
    sessionId?: StringFilter<"SessionExercise"> | string
    exerciseId?: StringFilter<"SessionExercise"> | string
    config?: JsonNullableFilter<"SessionExercise">
    position?: IntFilter<"SessionExercise"> | number
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
    session?: XOR<SessionRelationFilter, SessionWhereInput>
    progressInstances?: SessionProgressListRelationFilter
  }, "id">

  export type SessionExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    exerciseId?: SortOrder
    config?: SortOrderInput | SortOrder
    position?: SortOrder
    _count?: SessionExerciseCountOrderByAggregateInput
    _avg?: SessionExerciseAvgOrderByAggregateInput
    _max?: SessionExerciseMaxOrderByAggregateInput
    _min?: SessionExerciseMinOrderByAggregateInput
    _sum?: SessionExerciseSumOrderByAggregateInput
  }

  export type SessionExerciseScalarWhereWithAggregatesInput = {
    AND?: SessionExerciseScalarWhereWithAggregatesInput | SessionExerciseScalarWhereWithAggregatesInput[]
    OR?: SessionExerciseScalarWhereWithAggregatesInput[]
    NOT?: SessionExerciseScalarWhereWithAggregatesInput | SessionExerciseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SessionExercise"> | string
    sessionId?: StringWithAggregatesFilter<"SessionExercise"> | string
    exerciseId?: StringWithAggregatesFilter<"SessionExercise"> | string
    config?: JsonNullableWithAggregatesFilter<"SessionExercise">
    position?: IntWithAggregatesFilter<"SessionExercise"> | number
  }

  export type SessionProgressWhereInput = {
    AND?: SessionProgressWhereInput | SessionProgressWhereInput[]
    OR?: SessionProgressWhereInput[]
    NOT?: SessionProgressWhereInput | SessionProgressWhereInput[]
    id?: StringFilter<"SessionProgress"> | string
    sessionId?: StringFilter<"SessionProgress"> | string
    studentId?: StringFilter<"SessionProgress"> | string
    exerciseInstanceId?: StringNullableFilter<"SessionProgress"> | string | null
    progress?: JsonNullableFilter<"SessionProgress">
    notes?: StringNullableFilter<"SessionProgress"> | string | null
    videos?: StringNullableListFilter<"SessionProgress">
    savedAt?: DateTimeFilter<"SessionProgress"> | Date | string
    exerciseInstance?: XOR<SessionExerciseNullableRelationFilter, SessionExerciseWhereInput> | null
    session?: XOR<SessionRelationFilter, SessionWhereInput>
    student?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionProgressOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    exerciseInstanceId?: SortOrderInput | SortOrder
    progress?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    videos?: SortOrder
    savedAt?: SortOrder
    exerciseInstance?: SessionExerciseOrderByWithRelationInput
    session?: SessionOrderByWithRelationInput
    student?: UserOrderByWithRelationInput
  }

  export type SessionProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionProgressWhereInput | SessionProgressWhereInput[]
    OR?: SessionProgressWhereInput[]
    NOT?: SessionProgressWhereInput | SessionProgressWhereInput[]
    sessionId?: StringFilter<"SessionProgress"> | string
    studentId?: StringFilter<"SessionProgress"> | string
    exerciseInstanceId?: StringNullableFilter<"SessionProgress"> | string | null
    progress?: JsonNullableFilter<"SessionProgress">
    notes?: StringNullableFilter<"SessionProgress"> | string | null
    videos?: StringNullableListFilter<"SessionProgress">
    savedAt?: DateTimeFilter<"SessionProgress"> | Date | string
    exerciseInstance?: XOR<SessionExerciseNullableRelationFilter, SessionExerciseWhereInput> | null
    session?: XOR<SessionRelationFilter, SessionWhereInput>
    student?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SessionProgressOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    exerciseInstanceId?: SortOrderInput | SortOrder
    progress?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    videos?: SortOrder
    savedAt?: SortOrder
    _count?: SessionProgressCountOrderByAggregateInput
    _max?: SessionProgressMaxOrderByAggregateInput
    _min?: SessionProgressMinOrderByAggregateInput
  }

  export type SessionProgressScalarWhereWithAggregatesInput = {
    AND?: SessionProgressScalarWhereWithAggregatesInput | SessionProgressScalarWhereWithAggregatesInput[]
    OR?: SessionProgressScalarWhereWithAggregatesInput[]
    NOT?: SessionProgressScalarWhereWithAggregatesInput | SessionProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SessionProgress"> | string
    sessionId?: StringWithAggregatesFilter<"SessionProgress"> | string
    studentId?: StringWithAggregatesFilter<"SessionProgress"> | string
    exerciseInstanceId?: StringNullableWithAggregatesFilter<"SessionProgress"> | string | null
    progress?: JsonNullableWithAggregatesFilter<"SessionProgress">
    notes?: StringNullableWithAggregatesFilter<"SessionProgress"> | string | null
    videos?: StringNullableListFilter<"SessionProgress">
    savedAt?: DateTimeWithAggregatesFilter<"SessionProgress"> | Date | string
  }

  export type ProgramAssignmentWhereInput = {
    AND?: ProgramAssignmentWhereInput | ProgramAssignmentWhereInput[]
    OR?: ProgramAssignmentWhereInput[]
    NOT?: ProgramAssignmentWhereInput | ProgramAssignmentWhereInput[]
    id?: StringFilter<"ProgramAssignment"> | string
    programId?: StringFilter<"ProgramAssignment"> | string
    studentId?: StringFilter<"ProgramAssignment"> | string
    assignedBy?: StringNullableFilter<"ProgramAssignment"> | string | null
    assignedAt?: DateTimeFilter<"ProgramAssignment"> | Date | string
    assigner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    student?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProgramAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    programId?: SortOrder
    studentId?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    assignedAt?: SortOrder
    assigner?: UserOrderByWithRelationInput
    program?: ProgramOrderByWithRelationInput
    student?: UserOrderByWithRelationInput
  }

  export type ProgramAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProgramAssignmentWhereInput | ProgramAssignmentWhereInput[]
    OR?: ProgramAssignmentWhereInput[]
    NOT?: ProgramAssignmentWhereInput | ProgramAssignmentWhereInput[]
    programId?: StringFilter<"ProgramAssignment"> | string
    studentId?: StringFilter<"ProgramAssignment"> | string
    assignedBy?: StringNullableFilter<"ProgramAssignment"> | string | null
    assignedAt?: DateTimeFilter<"ProgramAssignment"> | Date | string
    assigner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    student?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ProgramAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    programId?: SortOrder
    studentId?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    assignedAt?: SortOrder
    _count?: ProgramAssignmentCountOrderByAggregateInput
    _max?: ProgramAssignmentMaxOrderByAggregateInput
    _min?: ProgramAssignmentMinOrderByAggregateInput
  }

  export type ProgramAssignmentScalarWhereWithAggregatesInput = {
    AND?: ProgramAssignmentScalarWhereWithAggregatesInput | ProgramAssignmentScalarWhereWithAggregatesInput[]
    OR?: ProgramAssignmentScalarWhereWithAggregatesInput[]
    NOT?: ProgramAssignmentScalarWhereWithAggregatesInput | ProgramAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProgramAssignment"> | string
    programId?: StringWithAggregatesFilter<"ProgramAssignment"> | string
    studentId?: StringWithAggregatesFilter<"ProgramAssignment"> | string
    assignedBy?: StringNullableWithAggregatesFilter<"ProgramAssignment"> | string | null
    assignedAt?: DateTimeWithAggregatesFilter<"ProgramAssignment"> | Date | string
  }

  export type ProgramAuditWhereInput = {
    AND?: ProgramAuditWhereInput | ProgramAuditWhereInput[]
    OR?: ProgramAuditWhereInput[]
    NOT?: ProgramAuditWhereInput | ProgramAuditWhereInput[]
    id?: StringFilter<"ProgramAudit"> | string
    programId?: StringFilter<"ProgramAudit"> | string
    changedBy?: StringFilter<"ProgramAudit"> | string
    changeType?: StringFilter<"ProgramAudit"> | string
    diff?: JsonNullableFilter<"ProgramAudit">
    createdAt?: DateTimeFilter<"ProgramAudit"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
  }

  export type ProgramAuditOrderByWithRelationInput = {
    id?: SortOrder
    programId?: SortOrder
    changedBy?: SortOrder
    changeType?: SortOrder
    diff?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    program?: ProgramOrderByWithRelationInput
  }

  export type ProgramAuditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProgramAuditWhereInput | ProgramAuditWhereInput[]
    OR?: ProgramAuditWhereInput[]
    NOT?: ProgramAuditWhereInput | ProgramAuditWhereInput[]
    programId?: StringFilter<"ProgramAudit"> | string
    changedBy?: StringFilter<"ProgramAudit"> | string
    changeType?: StringFilter<"ProgramAudit"> | string
    diff?: JsonNullableFilter<"ProgramAudit">
    createdAt?: DateTimeFilter<"ProgramAudit"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
  }, "id">

  export type ProgramAuditOrderByWithAggregationInput = {
    id?: SortOrder
    programId?: SortOrder
    changedBy?: SortOrder
    changeType?: SortOrder
    diff?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProgramAuditCountOrderByAggregateInput
    _max?: ProgramAuditMaxOrderByAggregateInput
    _min?: ProgramAuditMinOrderByAggregateInput
  }

  export type ProgramAuditScalarWhereWithAggregatesInput = {
    AND?: ProgramAuditScalarWhereWithAggregatesInput | ProgramAuditScalarWhereWithAggregatesInput[]
    OR?: ProgramAuditScalarWhereWithAggregatesInput[]
    NOT?: ProgramAuditScalarWhereWithAggregatesInput | ProgramAuditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProgramAudit"> | string
    programId?: StringWithAggregatesFilter<"ProgramAudit"> | string
    changedBy?: StringWithAggregatesFilter<"ProgramAudit"> | string
    changeType?: StringWithAggregatesFilter<"ProgramAudit"> | string
    diff?: JsonNullableWithAggregatesFilter<"ProgramAudit">
    createdAt?: DateTimeWithAggregatesFilter<"ProgramAudit"> | Date | string
  }

  export type BadgeWhereInput = {
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    id?: StringFilter<"Badge"> | string
    key?: StringFilter<"Badge"> | string
    title?: JsonFilter<"Badge">
    description?: JsonFilter<"Badge">
    criteria?: JsonFilter<"Badge">
    userBadges?: UserBadgeListRelationFilter
  }

  export type BadgeOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    title?: SortOrder
    description?: SortOrder
    criteria?: SortOrder
    userBadges?: UserBadgeOrderByRelationAggregateInput
  }

  export type BadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    title?: JsonFilter<"Badge">
    description?: JsonFilter<"Badge">
    criteria?: JsonFilter<"Badge">
    userBadges?: UserBadgeListRelationFilter
  }, "id" | "key">

  export type BadgeOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    title?: SortOrder
    description?: SortOrder
    criteria?: SortOrder
    _count?: BadgeCountOrderByAggregateInput
    _max?: BadgeMaxOrderByAggregateInput
    _min?: BadgeMinOrderByAggregateInput
  }

  export type BadgeScalarWhereWithAggregatesInput = {
    AND?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    OR?: BadgeScalarWhereWithAggregatesInput[]
    NOT?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Badge"> | string
    key?: StringWithAggregatesFilter<"Badge"> | string
    title?: JsonWithAggregatesFilter<"Badge">
    description?: JsonWithAggregatesFilter<"Badge">
    criteria?: JsonWithAggregatesFilter<"Badge">
  }

  export type UserBadgeWhereInput = {
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    id?: StringFilter<"UserBadge"> | string
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: StringFilter<"UserBadge"> | string
    awardedAt?: DateTimeFilter<"UserBadge"> | Date | string
    badge?: XOR<BadgeRelationFilter, BadgeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserBadgeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    awardedAt?: SortOrder
    badge?: BadgeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserBadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: StringFilter<"UserBadge"> | string
    awardedAt?: DateTimeFilter<"UserBadge"> | Date | string
    badge?: XOR<BadgeRelationFilter, BadgeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type UserBadgeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    awardedAt?: SortOrder
    _count?: UserBadgeCountOrderByAggregateInput
    _max?: UserBadgeMaxOrderByAggregateInput
    _min?: UserBadgeMinOrderByAggregateInput
  }

  export type UserBadgeScalarWhereWithAggregatesInput = {
    AND?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    OR?: UserBadgeScalarWhereWithAggregatesInput[]
    NOT?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserBadge"> | string
    userId?: StringWithAggregatesFilter<"UserBadge"> | string
    badgeId?: StringWithAggregatesFilter<"UserBadge"> | string
    awardedAt?: DateTimeWithAggregatesFilter<"UserBadge"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    payload?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    payload?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    payload?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    payload?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    payload?: JsonNullableWithAggregatesFilter<"Notification">
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressCreateNestedManyWithoutStudentInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutUserInput
    coach?: UserCreateNestedOneWithoutStudentsInput
    students?: UserCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    coachId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentUncheckedCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentUncheckedCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressUncheckedCreateNestedManyWithoutStudentInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingUncheckedCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryUncheckedCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseUncheckedCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutUserInput
    students?: UserUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutUserNestedInput
    coach?: UserUpdateOneWithoutStudentsNestedInput
    students?: UserUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUncheckedUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUncheckedUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUncheckedUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUncheckedUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUncheckedUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUncheckedUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutUserNestedInput
    students?: UserUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    coachId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    owner: UserCreateNestedOneWithoutOwnedGroupsInput
    invitations?: InvitationCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateInput = {
    id?: string
    ownerId: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedGroupsNestedInput
    invitations?: InvitationUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateManyInput = {
    id?: string
    ownerId: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateInput = {
    id?: string
    roleInGroup?: string
    joinedAt?: Date | string
    group: GroupCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutGroupMembershipsInput
  }

  export type GroupMemberUncheckedCreateInput = {
    id?: string
    groupId: string
    userId: string
    roleInGroup?: string
    joinedAt?: Date | string
  }

  export type GroupMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleInGroup?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutGroupMembershipsNestedInput
  }

  export type GroupMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleInGroup?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateManyInput = {
    id?: string
    groupId: string
    userId: string
    roleInGroup?: string
    joinedAt?: Date | string
  }

  export type GroupMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleInGroup?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleInGroup?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationCreateInput = {
    id?: string
    status: $Enums.InvitationStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
    fromCoach: UserCreateNestedOneWithoutSentInvitationsInput
    group: GroupCreateNestedOneWithoutInvitationsInput
    toUser: UserCreateNestedOneWithoutReceivedInvitationsInput
  }

  export type InvitationUncheckedCreateInput = {
    id?: string
    groupId: string
    fromCoachId: string
    toUserId: string
    status: $Enums.InvitationStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type InvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fromCoach?: UserUpdateOneRequiredWithoutSentInvitationsNestedInput
    group?: GroupUpdateOneRequiredWithoutInvitationsNestedInput
    toUser?: UserUpdateOneRequiredWithoutReceivedInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    fromCoachId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvitationCreateManyInput = {
    id?: string
    groupId: string
    fromCoachId: string
    toUserId: string
    status: $Enums.InvitationStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type InvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    fromCoachId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExerciseCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope: $Enums.Scope
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutCreatedExercisesInput
    sessionExercises?: SessionExerciseCreateNestedManyWithoutExerciseInput
    ratings?: ExerciseRatingCreateNestedManyWithoutExerciseInput
    history?: ExerciseHistoryCreateNestedManyWithoutExerciseInput
    favorites?: FavoriteExerciseCreateNestedManyWithoutExerciseInput
    logs?: ExerciseLogCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope: $Enums.Scope
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionExercises?: SessionExerciseUncheckedCreateNestedManyWithoutExerciseInput
    ratings?: ExerciseRatingUncheckedCreateNestedManyWithoutExerciseInput
    history?: ExerciseHistoryUncheckedCreateNestedManyWithoutExerciseInput
    favorites?: FavoriteExerciseUncheckedCreateNestedManyWithoutExerciseInput
    logs?: ExerciseLogUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope?: EnumScopeFieldUpdateOperationsInput | $Enums.Scope
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutCreatedExercisesNestedInput
    sessionExercises?: SessionExerciseUpdateManyWithoutExerciseNestedInput
    ratings?: ExerciseRatingUpdateManyWithoutExerciseNestedInput
    history?: ExerciseHistoryUpdateManyWithoutExerciseNestedInput
    favorites?: FavoriteExerciseUpdateManyWithoutExerciseNestedInput
    logs?: ExerciseLogUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope?: EnumScopeFieldUpdateOperationsInput | $Enums.Scope
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionExercises?: SessionExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    ratings?: ExerciseRatingUncheckedUpdateManyWithoutExerciseNestedInput
    history?: ExerciseHistoryUncheckedUpdateManyWithoutExerciseNestedInput
    favorites?: FavoriteExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    logs?: ExerciseLogUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope: $Enums.Scope
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope?: EnumScopeFieldUpdateOperationsInput | $Enums.Scope
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope?: EnumScopeFieldUpdateOperationsInput | $Enums.Scope
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseRatingCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exercise: ExerciseCreateNestedOneWithoutRatingsInput
    user: UserCreateNestedOneWithoutExerciseRatingsInput
  }

  export type ExerciseRatingUncheckedCreateInput = {
    id?: string
    exerciseId: string
    userId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseRatingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercise?: ExerciseUpdateOneRequiredWithoutRatingsNestedInput
    user?: UserUpdateOneRequiredWithoutExerciseRatingsNestedInput
  }

  export type ExerciseRatingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseRatingCreateManyInput = {
    id?: string
    exerciseId: string
    userId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseRatingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseRatingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseHistoryCreateInput = {
    id?: string
    viewedAt?: Date | string
    user: UserCreateNestedOneWithoutExerciseHistoryInput
    exercise: ExerciseCreateNestedOneWithoutHistoryInput
  }

  export type ExerciseHistoryUncheckedCreateInput = {
    id?: string
    userId: string
    exerciseId: string
    viewedAt?: Date | string
  }

  export type ExerciseHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExerciseHistoryNestedInput
    exercise?: ExerciseUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type ExerciseHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseHistoryCreateManyInput = {
    id?: string
    userId: string
    exerciseId: string
    viewedAt?: Date | string
  }

  export type ExerciseHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteExerciseCreateInput = {
    id?: string
    addedAt?: Date | string
    user: UserCreateNestedOneWithoutFavoriteExercisesInput
    exercise: ExerciseCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteExerciseUncheckedCreateInput = {
    id?: string
    userId: string
    exerciseId: string
    addedAt?: Date | string
  }

  export type FavoriteExerciseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoriteExercisesNestedInput
    exercise?: ExerciseUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteExerciseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteExerciseCreateManyInput = {
    id?: string
    userId: string
    exerciseId: string
    addedAt?: Date | string
  }

  export type FavoriteExerciseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteExerciseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutSessionCreateInput = {
    id?: string
    title?: string | null
    startedAt?: Date | string
    startTime?: Date | string | null
    endedAt?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    notes?: string | null
    restPeriodSeconds?: number | null
    formGuidanceEnabled?: boolean | null
    exercisesCompleted?: number | null
    totalExercises?: number | null
    user: UserCreateNestedOneWithoutWorkoutSessionsInput
    logs?: ExerciseLogCreateNestedManyWithoutSessionInput
  }

  export type WorkoutSessionUncheckedCreateInput = {
    id?: string
    userId: string
    title?: string | null
    startedAt?: Date | string
    startTime?: Date | string | null
    endedAt?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    notes?: string | null
    restPeriodSeconds?: number | null
    formGuidanceEnabled?: boolean | null
    exercisesCompleted?: number | null
    totalExercises?: number | null
    logs?: ExerciseLogUncheckedCreateNestedManyWithoutSessionInput
  }

  export type WorkoutSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    restPeriodSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    formGuidanceEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exercisesCompleted?: NullableIntFieldUpdateOperationsInput | number | null
    totalExercises?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutWorkoutSessionsNestedInput
    logs?: ExerciseLogUpdateManyWithoutSessionNestedInput
  }

  export type WorkoutSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    restPeriodSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    formGuidanceEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exercisesCompleted?: NullableIntFieldUpdateOperationsInput | number | null
    totalExercises?: NullableIntFieldUpdateOperationsInput | number | null
    logs?: ExerciseLogUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type WorkoutSessionCreateManyInput = {
    id?: string
    userId: string
    title?: string | null
    startedAt?: Date | string
    startTime?: Date | string | null
    endedAt?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    notes?: string | null
    restPeriodSeconds?: number | null
    formGuidanceEnabled?: boolean | null
    exercisesCompleted?: number | null
    totalExercises?: number | null
  }

  export type WorkoutSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    restPeriodSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    formGuidanceEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exercisesCompleted?: NullableIntFieldUpdateOperationsInput | number | null
    totalExercises?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WorkoutSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    restPeriodSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    formGuidanceEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exercisesCompleted?: NullableIntFieldUpdateOperationsInput | number | null
    totalExercises?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExerciseLogCreateInput = {
    id?: string
    userId?: string | null
    reps?: number | null
    sets?: number | null
    setsCompleted?: number | null
    weight?: number | null
    duration?: number | null
    formRating?: number | null
    skipped?: boolean | null
    notes?: string | null
    loggedAt?: Date | string
    completedAt?: Date | string | null
    session: WorkoutSessionCreateNestedOneWithoutLogsInput
    exercise: ExerciseCreateNestedOneWithoutLogsInput
  }

  export type ExerciseLogUncheckedCreateInput = {
    id?: string
    sessionId: string
    exerciseId: string
    userId?: string | null
    reps?: number | null
    sets?: number | null
    setsCompleted?: number | null
    weight?: number | null
    duration?: number | null
    formRating?: number | null
    skipped?: boolean | null
    notes?: string | null
    loggedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ExerciseLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    setsCompleted?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    formRating?: NullableIntFieldUpdateOperationsInput | number | null
    skipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    loggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session?: WorkoutSessionUpdateOneRequiredWithoutLogsNestedInput
    exercise?: ExerciseUpdateOneRequiredWithoutLogsNestedInput
  }

  export type ExerciseLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    setsCompleted?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    formRating?: NullableIntFieldUpdateOperationsInput | number | null
    skipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    loggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExerciseLogCreateManyInput = {
    id?: string
    sessionId: string
    exerciseId: string
    userId?: string | null
    reps?: number | null
    sets?: number | null
    setsCompleted?: number | null
    weight?: number | null
    duration?: number | null
    formRating?: number | null
    skipped?: boolean | null
    notes?: string | null
    loggedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ExerciseLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    setsCompleted?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    formRating?: NullableIntFieldUpdateOperationsInput | number | null
    skipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    loggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExerciseLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    setsCompleted?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    formRating?: NullableIntFieldUpdateOperationsInput | number | null
    skipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    loggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProgramCreateInput = {
    id?: string
    title: string
    description?: string | null
    ownerId?: string | null
    isDraft?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: ProgramAssignmentCreateNestedManyWithoutProgramInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutProgramInput
    blocks?: ProgramBlockCreateNestedManyWithoutProgramInput
    coach: UserCreateNestedOneWithoutCreatedProgramsInput
  }

  export type ProgramUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    coachId: string
    ownerId?: string | null
    isDraft?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: ProgramAssignmentUncheckedCreateNestedManyWithoutProgramInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutProgramInput
    blocks?: ProgramBlockUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: ProgramAssignmentUpdateManyWithoutProgramNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutProgramNestedInput
    blocks?: ProgramBlockUpdateManyWithoutProgramNestedInput
    coach?: UserUpdateOneRequiredWithoutCreatedProgramsNestedInput
  }

  export type ProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: ProgramAssignmentUncheckedUpdateManyWithoutProgramNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutProgramNestedInput
    blocks?: ProgramBlockUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    coachId: string
    ownerId?: string | null
    isDraft?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramBlockCreateInput = {
    id?: string
    title?: string | null
    position: number
    notes?: string | null
    program: ProgramCreateNestedOneWithoutBlocksInput
    weeks?: WeekCreateNestedManyWithoutBlockInput
  }

  export type ProgramBlockUncheckedCreateInput = {
    id?: string
    programId: string
    title?: string | null
    position: number
    notes?: string | null
    weeks?: WeekUncheckedCreateNestedManyWithoutBlockInput
  }

  export type ProgramBlockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    program?: ProgramUpdateOneRequiredWithoutBlocksNestedInput
    weeks?: WeekUpdateManyWithoutBlockNestedInput
  }

  export type ProgramBlockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weeks?: WeekUncheckedUpdateManyWithoutBlockNestedInput
  }

  export type ProgramBlockCreateManyInput = {
    id?: string
    programId: string
    title?: string | null
    position: number
    notes?: string | null
  }

  export type ProgramBlockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProgramBlockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeekCreateInput = {
    id?: string
    weekNumber: number
    position: number
    sessions?: SessionCreateNestedManyWithoutWeekInput
    block: ProgramBlockCreateNestedOneWithoutWeeksInput
  }

  export type WeekUncheckedCreateInput = {
    id?: string
    blockId: string
    weekNumber: number
    position: number
    sessions?: SessionUncheckedCreateNestedManyWithoutWeekInput
  }

  export type WeekUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    sessions?: SessionUpdateManyWithoutWeekNestedInput
    block?: ProgramBlockUpdateOneRequiredWithoutWeeksNestedInput
  }

  export type WeekUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockId?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    sessions?: SessionUncheckedUpdateManyWithoutWeekNestedInput
  }

  export type WeekCreateManyInput = {
    id?: string
    blockId: string
    weekNumber: number
    position: number
  }

  export type WeekUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type WeekUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockId?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type SessionCreateInput = {
    id?: string
    title?: string | null
    notes?: string | null
    date?: Date | string | null
    position: number
    data?: NullableJsonNullValueInput | InputJsonValue
    exercises?: SessionExerciseCreateNestedManyWithoutSessionInput
    progress?: SessionProgressCreateNestedManyWithoutSessionInput
    week: WeekCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    weekId: string
    title?: string | null
    notes?: string | null
    date?: Date | string | null
    position: number
    data?: NullableJsonNullValueInput | InputJsonValue
    exercises?: SessionExerciseUncheckedCreateNestedManyWithoutSessionInput
    progress?: SessionProgressUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: IntFieldUpdateOperationsInput | number
    data?: NullableJsonNullValueInput | InputJsonValue
    exercises?: SessionExerciseUpdateManyWithoutSessionNestedInput
    progress?: SessionProgressUpdateManyWithoutSessionNestedInput
    week?: WeekUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: IntFieldUpdateOperationsInput | number
    data?: NullableJsonNullValueInput | InputJsonValue
    exercises?: SessionExerciseUncheckedUpdateManyWithoutSessionNestedInput
    progress?: SessionProgressUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionCreateManyInput = {
    id?: string
    weekId: string
    title?: string | null
    notes?: string | null
    date?: Date | string | null
    position: number
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: IntFieldUpdateOperationsInput | number
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: IntFieldUpdateOperationsInput | number
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionExerciseCreateInput = {
    id?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    position: number
    exercise: ExerciseCreateNestedOneWithoutSessionExercisesInput
    session: SessionCreateNestedOneWithoutExercisesInput
    progressInstances?: SessionProgressCreateNestedManyWithoutExerciseInstanceInput
  }

  export type SessionExerciseUncheckedCreateInput = {
    id?: string
    sessionId: string
    exerciseId: string
    config?: NullableJsonNullValueInput | InputJsonValue
    position: number
    progressInstances?: SessionProgressUncheckedCreateNestedManyWithoutExerciseInstanceInput
  }

  export type SessionExerciseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
    exercise?: ExerciseUpdateOneRequiredWithoutSessionExercisesNestedInput
    session?: SessionUpdateOneRequiredWithoutExercisesNestedInput
    progressInstances?: SessionProgressUpdateManyWithoutExerciseInstanceNestedInput
  }

  export type SessionExerciseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
    progressInstances?: SessionProgressUncheckedUpdateManyWithoutExerciseInstanceNestedInput
  }

  export type SessionExerciseCreateManyInput = {
    id?: string
    sessionId: string
    exerciseId: string
    config?: NullableJsonNullValueInput | InputJsonValue
    position: number
  }

  export type SessionExerciseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
  }

  export type SessionExerciseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
  }

  export type SessionProgressCreateInput = {
    id?: string
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    videos?: SessionProgressCreatevideosInput | string[]
    savedAt?: Date | string
    exerciseInstance?: SessionExerciseCreateNestedOneWithoutProgressInstancesInput
    session: SessionCreateNestedOneWithoutProgressInput
    student: UserCreateNestedOneWithoutSessionProgressInput
  }

  export type SessionProgressUncheckedCreateInput = {
    id?: string
    sessionId: string
    studentId: string
    exerciseInstanceId?: string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    videos?: SessionProgressCreatevideosInput | string[]
    savedAt?: Date | string
  }

  export type SessionProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: SessionProgressUpdatevideosInput | string[]
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseInstance?: SessionExerciseUpdateOneWithoutProgressInstancesNestedInput
    session?: SessionUpdateOneRequiredWithoutProgressNestedInput
    student?: UserUpdateOneRequiredWithoutSessionProgressNestedInput
  }

  export type SessionProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    exerciseInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: SessionProgressUpdatevideosInput | string[]
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionProgressCreateManyInput = {
    id?: string
    sessionId: string
    studentId: string
    exerciseInstanceId?: string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    videos?: SessionProgressCreatevideosInput | string[]
    savedAt?: Date | string
  }

  export type SessionProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: SessionProgressUpdatevideosInput | string[]
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    exerciseInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: SessionProgressUpdatevideosInput | string[]
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramAssignmentCreateInput = {
    id?: string
    assignedAt?: Date | string
    assigner?: UserCreateNestedOneWithoutAssignedByInput
    program: ProgramCreateNestedOneWithoutAssignmentsInput
    student: UserCreateNestedOneWithoutAssignedProgramsInput
  }

  export type ProgramAssignmentUncheckedCreateInput = {
    id?: string
    programId: string
    studentId: string
    assignedBy?: string | null
    assignedAt?: Date | string
  }

  export type ProgramAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assigner?: UserUpdateOneWithoutAssignedByNestedInput
    program?: ProgramUpdateOneRequiredWithoutAssignmentsNestedInput
    student?: UserUpdateOneRequiredWithoutAssignedProgramsNestedInput
  }

  export type ProgramAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramAssignmentCreateManyInput = {
    id?: string
    programId: string
    studentId: string
    assignedBy?: string | null
    assignedAt?: Date | string
  }

  export type ProgramAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramAuditCreateInput = {
    id?: string
    changeType: string
    diff?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
    program: ProgramCreateNestedOneWithoutAuditLogsInput
  }

  export type ProgramAuditUncheckedCreateInput = {
    id?: string
    programId: string
    changedBy: string
    changeType: string
    diff?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ProgramAuditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    diff?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
    program?: ProgramUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type ProgramAuditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    diff?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramAuditCreateManyInput = {
    id?: string
    programId: string
    changedBy: string
    changeType: string
    diff?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ProgramAuditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    diff?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramAuditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    diff?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeCreateInput = {
    id?: string
    key: string
    title: JsonNullValueInput | InputJsonValue
    description: JsonNullValueInput | InputJsonValue
    criteria: JsonNullValueInput | InputJsonValue
    userBadges?: UserBadgeCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUncheckedCreateInput = {
    id?: string
    key: string
    title: JsonNullValueInput | InputJsonValue
    description: JsonNullValueInput | InputJsonValue
    criteria: JsonNullValueInput | InputJsonValue
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    description?: JsonNullValueInput | InputJsonValue
    criteria?: JsonNullValueInput | InputJsonValue
    userBadges?: UserBadgeUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    description?: JsonNullValueInput | InputJsonValue
    criteria?: JsonNullValueInput | InputJsonValue
    userBadges?: UserBadgeUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeCreateManyInput = {
    id?: string
    key: string
    title: JsonNullValueInput | InputJsonValue
    description: JsonNullValueInput | InputJsonValue
    criteria: JsonNullValueInput | InputJsonValue
  }

  export type BadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    description?: JsonNullValueInput | InputJsonValue
    criteria?: JsonNullValueInput | InputJsonValue
  }

  export type BadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    description?: JsonNullValueInput | InputJsonValue
    criteria?: JsonNullValueInput | InputJsonValue
  }

  export type UserBadgeCreateInput = {
    id?: string
    awardedAt?: Date | string
    badge: BadgeCreateNestedOneWithoutUserBadgesInput
    user: UserCreateNestedOneWithoutBadgesInput
  }

  export type UserBadgeUncheckedCreateInput = {
    id?: string
    userId: string
    badgeId: string
    awardedAt?: Date | string
  }

  export type UserBadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    badge?: BadgeUpdateOneRequiredWithoutUserBadgesNestedInput
    user?: UserUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type UserBadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateManyInput = {
    id?: string
    userId: string
    badgeId: string
    awardedAt?: Date | string
  }

  export type UserBadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ExerciseListRelationFilter = {
    every?: ExerciseWhereInput
    some?: ExerciseWhereInput
    none?: ExerciseWhereInput
  }

  export type GroupMemberListRelationFilter = {
    every?: GroupMemberWhereInput
    some?: GroupMemberWhereInput
    none?: GroupMemberWhereInput
  }

  export type GroupListRelationFilter = {
    every?: GroupWhereInput
    some?: GroupWhereInput
    none?: GroupWhereInput
  }

  export type InvitationListRelationFilter = {
    every?: InvitationWhereInput
    some?: InvitationWhereInput
    none?: InvitationWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ProgramAssignmentListRelationFilter = {
    every?: ProgramAssignmentWhereInput
    some?: ProgramAssignmentWhereInput
    none?: ProgramAssignmentWhereInput
  }

  export type ProgramAuditListRelationFilter = {
    every?: ProgramAuditWhereInput
    some?: ProgramAuditWhereInput
    none?: ProgramAuditWhereInput
  }

  export type ProgramListRelationFilter = {
    every?: ProgramWhereInput
    some?: ProgramWhereInput
    none?: ProgramWhereInput
  }

  export type SessionProgressListRelationFilter = {
    every?: SessionProgressWhereInput
    some?: SessionProgressWhereInput
    none?: SessionProgressWhereInput
  }

  export type UserBadgeListRelationFilter = {
    every?: UserBadgeWhereInput
    some?: UserBadgeWhereInput
    none?: UserBadgeWhereInput
  }

  export type ExerciseRatingListRelationFilter = {
    every?: ExerciseRatingWhereInput
    some?: ExerciseRatingWhereInput
    none?: ExerciseRatingWhereInput
  }

  export type ExerciseHistoryListRelationFilter = {
    every?: ExerciseHistoryWhereInput
    some?: ExerciseHistoryWhereInput
    none?: ExerciseHistoryWhereInput
  }

  export type FavoriteExerciseListRelationFilter = {
    every?: FavoriteExerciseWhereInput
    some?: FavoriteExerciseWhereInput
    none?: FavoriteExerciseWhereInput
  }

  export type WorkoutSessionListRelationFilter = {
    every?: WorkoutSessionWhereInput
    some?: WorkoutSessionWhereInput
    none?: WorkoutSessionWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramAuditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FavoriteExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkoutSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    pseudo?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    profileUrl?: SortOrder
    coachId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    pseudo?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    profileUrl?: SortOrder
    coachId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    pseudo?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    profileUrl?: SortOrder
    coachId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupRelationFilter = {
    is?: GroupWhereInput
    isNot?: GroupWhereInput
  }

  export type GroupMemberGroupIdUserIdCompoundUniqueInput = {
    groupId: string
    userId: string
  }

  export type GroupMemberCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    roleInGroup?: SortOrder
    joinedAt?: SortOrder
  }

  export type GroupMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    roleInGroup?: SortOrder
    joinedAt?: SortOrder
  }

  export type GroupMemberMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    roleInGroup?: SortOrder
    joinedAt?: SortOrder
  }

  export type EnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type InvitationGroupIdToUserIdStatusCompoundUniqueInput = {
    groupId: string
    toUserId: string
    status: $Enums.InvitationStatus
  }

  export type InvitationCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    fromCoachId?: SortOrder
    toUserId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    respondedAt?: SortOrder
  }

  export type InvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    fromCoachId?: SortOrder
    toUserId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    respondedAt?: SortOrder
  }

  export type InvitationMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    fromCoachId?: SortOrder
    toUserId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    respondedAt?: SortOrder
  }

  export type EnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumExerciseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseType | EnumExerciseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExerciseTypeFilter<$PrismaModel> | $Enums.ExerciseType
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.Scope | EnumScopeFieldRefInput<$PrismaModel>
    in?: $Enums.Scope[] | ListEnumScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Scope[] | ListEnumScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumScopeFilter<$PrismaModel> | $Enums.Scope
  }

  export type SessionExerciseListRelationFilter = {
    every?: SessionExerciseWhereInput
    some?: SessionExerciseWhereInput
    none?: SessionExerciseWhereInput
  }

  export type ExerciseLogListRelationFilter = {
    every?: ExerciseLogWhereInput
    some?: ExerciseLogWhereInput
    none?: ExerciseLogWhereInput
  }

  export type SessionExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    meta?: SortOrder
    scope?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    scope?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    scope?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumExerciseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseType | EnumExerciseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExerciseTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExerciseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExerciseTypeFilter<$PrismaModel>
    _max?: NestedEnumExerciseTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Scope | EnumScopeFieldRefInput<$PrismaModel>
    in?: $Enums.Scope[] | ListEnumScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Scope[] | ListEnumScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumScopeWithAggregatesFilter<$PrismaModel> | $Enums.Scope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScopeFilter<$PrismaModel>
    _max?: NestedEnumScopeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ExerciseRelationFilter = {
    is?: ExerciseWhereInput
    isNot?: ExerciseWhereInput
  }

  export type ExerciseRatingExerciseIdUserIdCompoundUniqueInput = {
    exerciseId: string
    userId: string
  }

  export type ExerciseRatingCountOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseRatingAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ExerciseRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseRatingMinOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseRatingSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ExerciseHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseId?: SortOrder
    viewedAt?: SortOrder
  }

  export type ExerciseHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseId?: SortOrder
    viewedAt?: SortOrder
  }

  export type ExerciseHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseId?: SortOrder
    viewedAt?: SortOrder
  }

  export type FavoriteExerciseUserIdExerciseIdCompoundUniqueInput = {
    userId: string
    exerciseId: string
  }

  export type FavoriteExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseId?: SortOrder
    addedAt?: SortOrder
  }

  export type FavoriteExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseId?: SortOrder
    addedAt?: SortOrder
  }

  export type FavoriteExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseId?: SortOrder
    addedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type WorkoutSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    startedAt?: SortOrder
    startTime?: SortOrder
    endedAt?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
    restPeriodSeconds?: SortOrder
    formGuidanceEnabled?: SortOrder
    exercisesCompleted?: SortOrder
    totalExercises?: SortOrder
  }

  export type WorkoutSessionAvgOrderByAggregateInput = {
    duration?: SortOrder
    restPeriodSeconds?: SortOrder
    exercisesCompleted?: SortOrder
    totalExercises?: SortOrder
  }

  export type WorkoutSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    startedAt?: SortOrder
    startTime?: SortOrder
    endedAt?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
    restPeriodSeconds?: SortOrder
    formGuidanceEnabled?: SortOrder
    exercisesCompleted?: SortOrder
    totalExercises?: SortOrder
  }

  export type WorkoutSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    startedAt?: SortOrder
    startTime?: SortOrder
    endedAt?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
    restPeriodSeconds?: SortOrder
    formGuidanceEnabled?: SortOrder
    exercisesCompleted?: SortOrder
    totalExercises?: SortOrder
  }

  export type WorkoutSessionSumOrderByAggregateInput = {
    duration?: SortOrder
    restPeriodSeconds?: SortOrder
    exercisesCompleted?: SortOrder
    totalExercises?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type WorkoutSessionRelationFilter = {
    is?: WorkoutSessionWhereInput
    isNot?: WorkoutSessionWhereInput
  }

  export type ExerciseLogCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    exerciseId?: SortOrder
    userId?: SortOrder
    reps?: SortOrder
    sets?: SortOrder
    setsCompleted?: SortOrder
    weight?: SortOrder
    duration?: SortOrder
    formRating?: SortOrder
    skipped?: SortOrder
    notes?: SortOrder
    loggedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ExerciseLogAvgOrderByAggregateInput = {
    reps?: SortOrder
    sets?: SortOrder
    setsCompleted?: SortOrder
    weight?: SortOrder
    duration?: SortOrder
    formRating?: SortOrder
  }

  export type ExerciseLogMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    exerciseId?: SortOrder
    userId?: SortOrder
    reps?: SortOrder
    sets?: SortOrder
    setsCompleted?: SortOrder
    weight?: SortOrder
    duration?: SortOrder
    formRating?: SortOrder
    skipped?: SortOrder
    notes?: SortOrder
    loggedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ExerciseLogMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    exerciseId?: SortOrder
    userId?: SortOrder
    reps?: SortOrder
    sets?: SortOrder
    setsCompleted?: SortOrder
    weight?: SortOrder
    duration?: SortOrder
    formRating?: SortOrder
    skipped?: SortOrder
    notes?: SortOrder
    loggedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ExerciseLogSumOrderByAggregateInput = {
    reps?: SortOrder
    sets?: SortOrder
    setsCompleted?: SortOrder
    weight?: SortOrder
    duration?: SortOrder
    formRating?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ProgramBlockListRelationFilter = {
    every?: ProgramBlockWhereInput
    some?: ProgramBlockWhereInput
    none?: ProgramBlockWhereInput
  }

  export type ProgramBlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    coachId?: SortOrder
    ownerId?: SortOrder
    isDraft?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    coachId?: SortOrder
    ownerId?: SortOrder
    isDraft?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    coachId?: SortOrder
    ownerId?: SortOrder
    isDraft?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ProgramRelationFilter = {
    is?: ProgramWhereInput
    isNot?: ProgramWhereInput
  }

  export type WeekListRelationFilter = {
    every?: WeekWhereInput
    some?: WeekWhereInput
    none?: WeekWhereInput
  }

  export type WeekOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramBlockCountOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    title?: SortOrder
    position?: SortOrder
    notes?: SortOrder
  }

  export type ProgramBlockAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type ProgramBlockMaxOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    title?: SortOrder
    position?: SortOrder
    notes?: SortOrder
  }

  export type ProgramBlockMinOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    title?: SortOrder
    position?: SortOrder
    notes?: SortOrder
  }

  export type ProgramBlockSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type ProgramBlockRelationFilter = {
    is?: ProgramBlockWhereInput
    isNot?: ProgramBlockWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeekCountOrderByAggregateInput = {
    id?: SortOrder
    blockId?: SortOrder
    weekNumber?: SortOrder
    position?: SortOrder
  }

  export type WeekAvgOrderByAggregateInput = {
    weekNumber?: SortOrder
    position?: SortOrder
  }

  export type WeekMaxOrderByAggregateInput = {
    id?: SortOrder
    blockId?: SortOrder
    weekNumber?: SortOrder
    position?: SortOrder
  }

  export type WeekMinOrderByAggregateInput = {
    id?: SortOrder
    blockId?: SortOrder
    weekNumber?: SortOrder
    position?: SortOrder
  }

  export type WeekSumOrderByAggregateInput = {
    weekNumber?: SortOrder
    position?: SortOrder
  }

  export type WeekRelationFilter = {
    is?: WeekWhereInput
    isNot?: WeekWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    weekId?: SortOrder
    title?: SortOrder
    notes?: SortOrder
    date?: SortOrder
    position?: SortOrder
    data?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    weekId?: SortOrder
    title?: SortOrder
    notes?: SortOrder
    date?: SortOrder
    position?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    weekId?: SortOrder
    title?: SortOrder
    notes?: SortOrder
    date?: SortOrder
    position?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type SessionRelationFilter = {
    is?: SessionWhereInput
    isNot?: SessionWhereInput
  }

  export type SessionExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    exerciseId?: SortOrder
    config?: SortOrder
    position?: SortOrder
  }

  export type SessionExerciseAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type SessionExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    exerciseId?: SortOrder
    position?: SortOrder
  }

  export type SessionExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    exerciseId?: SortOrder
    position?: SortOrder
  }

  export type SessionExerciseSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type SessionExerciseNullableRelationFilter = {
    is?: SessionExerciseWhereInput | null
    isNot?: SessionExerciseWhereInput | null
  }

  export type SessionProgressCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    exerciseInstanceId?: SortOrder
    progress?: SortOrder
    notes?: SortOrder
    videos?: SortOrder
    savedAt?: SortOrder
  }

  export type SessionProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    exerciseInstanceId?: SortOrder
    notes?: SortOrder
    savedAt?: SortOrder
  }

  export type SessionProgressMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    exerciseInstanceId?: SortOrder
    notes?: SortOrder
    savedAt?: SortOrder
  }

  export type ProgramAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    studentId?: SortOrder
    assignedBy?: SortOrder
    assignedAt?: SortOrder
  }

  export type ProgramAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    studentId?: SortOrder
    assignedBy?: SortOrder
    assignedAt?: SortOrder
  }

  export type ProgramAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    studentId?: SortOrder
    assignedBy?: SortOrder
    assignedAt?: SortOrder
  }

  export type ProgramAuditCountOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    changedBy?: SortOrder
    changeType?: SortOrder
    diff?: SortOrder
    createdAt?: SortOrder
  }

  export type ProgramAuditMaxOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    changedBy?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
  }

  export type ProgramAuditMinOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    changedBy?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BadgeCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    title?: SortOrder
    description?: SortOrder
    criteria?: SortOrder
  }

  export type BadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
  }

  export type BadgeMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BadgeRelationFilter = {
    is?: BadgeWhereInput
    isNot?: BadgeWhereInput
  }

  export type UserBadgeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    awardedAt?: SortOrder
  }

  export type UserBadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    awardedAt?: SortOrder
  }

  export type UserBadgeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    awardedAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type ExerciseCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ExerciseCreateWithoutOwnerInput, ExerciseUncheckedCreateWithoutOwnerInput> | ExerciseCreateWithoutOwnerInput[] | ExerciseUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutOwnerInput | ExerciseCreateOrConnectWithoutOwnerInput[]
    createMany?: ExerciseCreateManyOwnerInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type GroupMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type GroupCreateNestedManyWithoutOwnerInput = {
    create?: XOR<GroupCreateWithoutOwnerInput, GroupUncheckedCreateWithoutOwnerInput> | GroupCreateWithoutOwnerInput[] | GroupUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutOwnerInput | GroupCreateOrConnectWithoutOwnerInput[]
    createMany?: GroupCreateManyOwnerInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type InvitationCreateNestedManyWithoutFromCoachInput = {
    create?: XOR<InvitationCreateWithoutFromCoachInput, InvitationUncheckedCreateWithoutFromCoachInput> | InvitationCreateWithoutFromCoachInput[] | InvitationUncheckedCreateWithoutFromCoachInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutFromCoachInput | InvitationCreateOrConnectWithoutFromCoachInput[]
    createMany?: InvitationCreateManyFromCoachInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type InvitationCreateNestedManyWithoutToUserInput = {
    create?: XOR<InvitationCreateWithoutToUserInput, InvitationUncheckedCreateWithoutToUserInput> | InvitationCreateWithoutToUserInput[] | InvitationUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutToUserInput | InvitationCreateOrConnectWithoutToUserInput[]
    createMany?: InvitationCreateManyToUserInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ProgramAssignmentCreateNestedManyWithoutAssignerInput = {
    create?: XOR<ProgramAssignmentCreateWithoutAssignerInput, ProgramAssignmentUncheckedCreateWithoutAssignerInput> | ProgramAssignmentCreateWithoutAssignerInput[] | ProgramAssignmentUncheckedCreateWithoutAssignerInput[]
    connectOrCreate?: ProgramAssignmentCreateOrConnectWithoutAssignerInput | ProgramAssignmentCreateOrConnectWithoutAssignerInput[]
    createMany?: ProgramAssignmentCreateManyAssignerInputEnvelope
    connect?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
  }

  export type ProgramAssignmentCreateNestedManyWithoutStudentInput = {
    create?: XOR<ProgramAssignmentCreateWithoutStudentInput, ProgramAssignmentUncheckedCreateWithoutStudentInput> | ProgramAssignmentCreateWithoutStudentInput[] | ProgramAssignmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ProgramAssignmentCreateOrConnectWithoutStudentInput | ProgramAssignmentCreateOrConnectWithoutStudentInput[]
    createMany?: ProgramAssignmentCreateManyStudentInputEnvelope
    connect?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
  }

  export type ProgramAuditCreateNestedManyWithoutUserInput = {
    create?: XOR<ProgramAuditCreateWithoutUserInput, ProgramAuditUncheckedCreateWithoutUserInput> | ProgramAuditCreateWithoutUserInput[] | ProgramAuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgramAuditCreateOrConnectWithoutUserInput | ProgramAuditCreateOrConnectWithoutUserInput[]
    createMany?: ProgramAuditCreateManyUserInputEnvelope
    connect?: ProgramAuditWhereUniqueInput | ProgramAuditWhereUniqueInput[]
  }

  export type ProgramCreateNestedManyWithoutCoachInput = {
    create?: XOR<ProgramCreateWithoutCoachInput, ProgramUncheckedCreateWithoutCoachInput> | ProgramCreateWithoutCoachInput[] | ProgramUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutCoachInput | ProgramCreateOrConnectWithoutCoachInput[]
    createMany?: ProgramCreateManyCoachInputEnvelope
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
  }

  export type SessionProgressCreateNestedManyWithoutStudentInput = {
    create?: XOR<SessionProgressCreateWithoutStudentInput, SessionProgressUncheckedCreateWithoutStudentInput> | SessionProgressCreateWithoutStudentInput[] | SessionProgressUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SessionProgressCreateOrConnectWithoutStudentInput | SessionProgressCreateOrConnectWithoutStudentInput[]
    createMany?: SessionProgressCreateManyStudentInputEnvelope
    connect?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
  }

  export type UserBadgeCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type ExerciseRatingCreateNestedManyWithoutUserInput = {
    create?: XOR<ExerciseRatingCreateWithoutUserInput, ExerciseRatingUncheckedCreateWithoutUserInput> | ExerciseRatingCreateWithoutUserInput[] | ExerciseRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExerciseRatingCreateOrConnectWithoutUserInput | ExerciseRatingCreateOrConnectWithoutUserInput[]
    createMany?: ExerciseRatingCreateManyUserInputEnvelope
    connect?: ExerciseRatingWhereUniqueInput | ExerciseRatingWhereUniqueInput[]
  }

  export type ExerciseHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<ExerciseHistoryCreateWithoutUserInput, ExerciseHistoryUncheckedCreateWithoutUserInput> | ExerciseHistoryCreateWithoutUserInput[] | ExerciseHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExerciseHistoryCreateOrConnectWithoutUserInput | ExerciseHistoryCreateOrConnectWithoutUserInput[]
    createMany?: ExerciseHistoryCreateManyUserInputEnvelope
    connect?: ExerciseHistoryWhereUniqueInput | ExerciseHistoryWhereUniqueInput[]
  }

  export type FavoriteExerciseCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteExerciseCreateWithoutUserInput, FavoriteExerciseUncheckedCreateWithoutUserInput> | FavoriteExerciseCreateWithoutUserInput[] | FavoriteExerciseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteExerciseCreateOrConnectWithoutUserInput | FavoriteExerciseCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteExerciseCreateManyUserInputEnvelope
    connect?: FavoriteExerciseWhereUniqueInput | FavoriteExerciseWhereUniqueInput[]
  }

  export type WorkoutSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkoutSessionCreateWithoutUserInput, WorkoutSessionUncheckedCreateWithoutUserInput> | WorkoutSessionCreateWithoutUserInput[] | WorkoutSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkoutSessionCreateOrConnectWithoutUserInput | WorkoutSessionCreateOrConnectWithoutUserInput[]
    createMany?: WorkoutSessionCreateManyUserInputEnvelope
    connect?: WorkoutSessionWhereUniqueInput | WorkoutSessionWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutStudentsInput = {
    create?: XOR<UserCreateWithoutStudentsInput, UserUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCoachInput = {
    create?: XOR<UserCreateWithoutCoachInput, UserUncheckedCreateWithoutCoachInput> | UserCreateWithoutCoachInput[] | UserUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCoachInput | UserCreateOrConnectWithoutCoachInput[]
    createMany?: UserCreateManyCoachInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ExerciseUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ExerciseCreateWithoutOwnerInput, ExerciseUncheckedCreateWithoutOwnerInput> | ExerciseCreateWithoutOwnerInput[] | ExerciseUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutOwnerInput | ExerciseCreateOrConnectWithoutOwnerInput[]
    createMany?: ExerciseCreateManyOwnerInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type GroupMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<GroupCreateWithoutOwnerInput, GroupUncheckedCreateWithoutOwnerInput> | GroupCreateWithoutOwnerInput[] | GroupUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutOwnerInput | GroupCreateOrConnectWithoutOwnerInput[]
    createMany?: GroupCreateManyOwnerInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutFromCoachInput = {
    create?: XOR<InvitationCreateWithoutFromCoachInput, InvitationUncheckedCreateWithoutFromCoachInput> | InvitationCreateWithoutFromCoachInput[] | InvitationUncheckedCreateWithoutFromCoachInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutFromCoachInput | InvitationCreateOrConnectWithoutFromCoachInput[]
    createMany?: InvitationCreateManyFromCoachInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutToUserInput = {
    create?: XOR<InvitationCreateWithoutToUserInput, InvitationUncheckedCreateWithoutToUserInput> | InvitationCreateWithoutToUserInput[] | InvitationUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutToUserInput | InvitationCreateOrConnectWithoutToUserInput[]
    createMany?: InvitationCreateManyToUserInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ProgramAssignmentUncheckedCreateNestedManyWithoutAssignerInput = {
    create?: XOR<ProgramAssignmentCreateWithoutAssignerInput, ProgramAssignmentUncheckedCreateWithoutAssignerInput> | ProgramAssignmentCreateWithoutAssignerInput[] | ProgramAssignmentUncheckedCreateWithoutAssignerInput[]
    connectOrCreate?: ProgramAssignmentCreateOrConnectWithoutAssignerInput | ProgramAssignmentCreateOrConnectWithoutAssignerInput[]
    createMany?: ProgramAssignmentCreateManyAssignerInputEnvelope
    connect?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
  }

  export type ProgramAssignmentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ProgramAssignmentCreateWithoutStudentInput, ProgramAssignmentUncheckedCreateWithoutStudentInput> | ProgramAssignmentCreateWithoutStudentInput[] | ProgramAssignmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ProgramAssignmentCreateOrConnectWithoutStudentInput | ProgramAssignmentCreateOrConnectWithoutStudentInput[]
    createMany?: ProgramAssignmentCreateManyStudentInputEnvelope
    connect?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
  }

  export type ProgramAuditUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProgramAuditCreateWithoutUserInput, ProgramAuditUncheckedCreateWithoutUserInput> | ProgramAuditCreateWithoutUserInput[] | ProgramAuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgramAuditCreateOrConnectWithoutUserInput | ProgramAuditCreateOrConnectWithoutUserInput[]
    createMany?: ProgramAuditCreateManyUserInputEnvelope
    connect?: ProgramAuditWhereUniqueInput | ProgramAuditWhereUniqueInput[]
  }

  export type ProgramUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<ProgramCreateWithoutCoachInput, ProgramUncheckedCreateWithoutCoachInput> | ProgramCreateWithoutCoachInput[] | ProgramUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutCoachInput | ProgramCreateOrConnectWithoutCoachInput[]
    createMany?: ProgramCreateManyCoachInputEnvelope
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
  }

  export type SessionProgressUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<SessionProgressCreateWithoutStudentInput, SessionProgressUncheckedCreateWithoutStudentInput> | SessionProgressCreateWithoutStudentInput[] | SessionProgressUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SessionProgressCreateOrConnectWithoutStudentInput | SessionProgressCreateOrConnectWithoutStudentInput[]
    createMany?: SessionProgressCreateManyStudentInputEnvelope
    connect?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
  }

  export type UserBadgeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type ExerciseRatingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExerciseRatingCreateWithoutUserInput, ExerciseRatingUncheckedCreateWithoutUserInput> | ExerciseRatingCreateWithoutUserInput[] | ExerciseRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExerciseRatingCreateOrConnectWithoutUserInput | ExerciseRatingCreateOrConnectWithoutUserInput[]
    createMany?: ExerciseRatingCreateManyUserInputEnvelope
    connect?: ExerciseRatingWhereUniqueInput | ExerciseRatingWhereUniqueInput[]
  }

  export type ExerciseHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExerciseHistoryCreateWithoutUserInput, ExerciseHistoryUncheckedCreateWithoutUserInput> | ExerciseHistoryCreateWithoutUserInput[] | ExerciseHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExerciseHistoryCreateOrConnectWithoutUserInput | ExerciseHistoryCreateOrConnectWithoutUserInput[]
    createMany?: ExerciseHistoryCreateManyUserInputEnvelope
    connect?: ExerciseHistoryWhereUniqueInput | ExerciseHistoryWhereUniqueInput[]
  }

  export type FavoriteExerciseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteExerciseCreateWithoutUserInput, FavoriteExerciseUncheckedCreateWithoutUserInput> | FavoriteExerciseCreateWithoutUserInput[] | FavoriteExerciseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteExerciseCreateOrConnectWithoutUserInput | FavoriteExerciseCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteExerciseCreateManyUserInputEnvelope
    connect?: FavoriteExerciseWhereUniqueInput | FavoriteExerciseWhereUniqueInput[]
  }

  export type WorkoutSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkoutSessionCreateWithoutUserInput, WorkoutSessionUncheckedCreateWithoutUserInput> | WorkoutSessionCreateWithoutUserInput[] | WorkoutSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkoutSessionCreateOrConnectWithoutUserInput | WorkoutSessionCreateOrConnectWithoutUserInput[]
    createMany?: WorkoutSessionCreateManyUserInputEnvelope
    connect?: WorkoutSessionWhereUniqueInput | WorkoutSessionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<UserCreateWithoutCoachInput, UserUncheckedCreateWithoutCoachInput> | UserCreateWithoutCoachInput[] | UserUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCoachInput | UserCreateOrConnectWithoutCoachInput[]
    createMany?: UserCreateManyCoachInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ExerciseUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ExerciseCreateWithoutOwnerInput, ExerciseUncheckedCreateWithoutOwnerInput> | ExerciseCreateWithoutOwnerInput[] | ExerciseUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutOwnerInput | ExerciseCreateOrConnectWithoutOwnerInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutOwnerInput | ExerciseUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ExerciseCreateManyOwnerInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutOwnerInput | ExerciseUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutOwnerInput | ExerciseUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type GroupMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutUserInput | GroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutUserInput | GroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutUserInput | GroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type GroupUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<GroupCreateWithoutOwnerInput, GroupUncheckedCreateWithoutOwnerInput> | GroupCreateWithoutOwnerInput[] | GroupUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutOwnerInput | GroupCreateOrConnectWithoutOwnerInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutOwnerInput | GroupUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: GroupCreateManyOwnerInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutOwnerInput | GroupUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutOwnerInput | GroupUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type InvitationUpdateManyWithoutFromCoachNestedInput = {
    create?: XOR<InvitationCreateWithoutFromCoachInput, InvitationUncheckedCreateWithoutFromCoachInput> | InvitationCreateWithoutFromCoachInput[] | InvitationUncheckedCreateWithoutFromCoachInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutFromCoachInput | InvitationCreateOrConnectWithoutFromCoachInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutFromCoachInput | InvitationUpsertWithWhereUniqueWithoutFromCoachInput[]
    createMany?: InvitationCreateManyFromCoachInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutFromCoachInput | InvitationUpdateWithWhereUniqueWithoutFromCoachInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutFromCoachInput | InvitationUpdateManyWithWhereWithoutFromCoachInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type InvitationUpdateManyWithoutToUserNestedInput = {
    create?: XOR<InvitationCreateWithoutToUserInput, InvitationUncheckedCreateWithoutToUserInput> | InvitationCreateWithoutToUserInput[] | InvitationUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutToUserInput | InvitationCreateOrConnectWithoutToUserInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutToUserInput | InvitationUpsertWithWhereUniqueWithoutToUserInput[]
    createMany?: InvitationCreateManyToUserInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutToUserInput | InvitationUpdateWithWhereUniqueWithoutToUserInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutToUserInput | InvitationUpdateManyWithWhereWithoutToUserInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ProgramAssignmentUpdateManyWithoutAssignerNestedInput = {
    create?: XOR<ProgramAssignmentCreateWithoutAssignerInput, ProgramAssignmentUncheckedCreateWithoutAssignerInput> | ProgramAssignmentCreateWithoutAssignerInput[] | ProgramAssignmentUncheckedCreateWithoutAssignerInput[]
    connectOrCreate?: ProgramAssignmentCreateOrConnectWithoutAssignerInput | ProgramAssignmentCreateOrConnectWithoutAssignerInput[]
    upsert?: ProgramAssignmentUpsertWithWhereUniqueWithoutAssignerInput | ProgramAssignmentUpsertWithWhereUniqueWithoutAssignerInput[]
    createMany?: ProgramAssignmentCreateManyAssignerInputEnvelope
    set?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    disconnect?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    delete?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    connect?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    update?: ProgramAssignmentUpdateWithWhereUniqueWithoutAssignerInput | ProgramAssignmentUpdateWithWhereUniqueWithoutAssignerInput[]
    updateMany?: ProgramAssignmentUpdateManyWithWhereWithoutAssignerInput | ProgramAssignmentUpdateManyWithWhereWithoutAssignerInput[]
    deleteMany?: ProgramAssignmentScalarWhereInput | ProgramAssignmentScalarWhereInput[]
  }

  export type ProgramAssignmentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ProgramAssignmentCreateWithoutStudentInput, ProgramAssignmentUncheckedCreateWithoutStudentInput> | ProgramAssignmentCreateWithoutStudentInput[] | ProgramAssignmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ProgramAssignmentCreateOrConnectWithoutStudentInput | ProgramAssignmentCreateOrConnectWithoutStudentInput[]
    upsert?: ProgramAssignmentUpsertWithWhereUniqueWithoutStudentInput | ProgramAssignmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ProgramAssignmentCreateManyStudentInputEnvelope
    set?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    disconnect?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    delete?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    connect?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    update?: ProgramAssignmentUpdateWithWhereUniqueWithoutStudentInput | ProgramAssignmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ProgramAssignmentUpdateManyWithWhereWithoutStudentInput | ProgramAssignmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ProgramAssignmentScalarWhereInput | ProgramAssignmentScalarWhereInput[]
  }

  export type ProgramAuditUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProgramAuditCreateWithoutUserInput, ProgramAuditUncheckedCreateWithoutUserInput> | ProgramAuditCreateWithoutUserInput[] | ProgramAuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgramAuditCreateOrConnectWithoutUserInput | ProgramAuditCreateOrConnectWithoutUserInput[]
    upsert?: ProgramAuditUpsertWithWhereUniqueWithoutUserInput | ProgramAuditUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProgramAuditCreateManyUserInputEnvelope
    set?: ProgramAuditWhereUniqueInput | ProgramAuditWhereUniqueInput[]
    disconnect?: ProgramAuditWhereUniqueInput | ProgramAuditWhereUniqueInput[]
    delete?: ProgramAuditWhereUniqueInput | ProgramAuditWhereUniqueInput[]
    connect?: ProgramAuditWhereUniqueInput | ProgramAuditWhereUniqueInput[]
    update?: ProgramAuditUpdateWithWhereUniqueWithoutUserInput | ProgramAuditUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProgramAuditUpdateManyWithWhereWithoutUserInput | ProgramAuditUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProgramAuditScalarWhereInput | ProgramAuditScalarWhereInput[]
  }

  export type ProgramUpdateManyWithoutCoachNestedInput = {
    create?: XOR<ProgramCreateWithoutCoachInput, ProgramUncheckedCreateWithoutCoachInput> | ProgramCreateWithoutCoachInput[] | ProgramUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutCoachInput | ProgramCreateOrConnectWithoutCoachInput[]
    upsert?: ProgramUpsertWithWhereUniqueWithoutCoachInput | ProgramUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: ProgramCreateManyCoachInputEnvelope
    set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    update?: ProgramUpdateWithWhereUniqueWithoutCoachInput | ProgramUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: ProgramUpdateManyWithWhereWithoutCoachInput | ProgramUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
  }

  export type SessionProgressUpdateManyWithoutStudentNestedInput = {
    create?: XOR<SessionProgressCreateWithoutStudentInput, SessionProgressUncheckedCreateWithoutStudentInput> | SessionProgressCreateWithoutStudentInput[] | SessionProgressUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SessionProgressCreateOrConnectWithoutStudentInput | SessionProgressCreateOrConnectWithoutStudentInput[]
    upsert?: SessionProgressUpsertWithWhereUniqueWithoutStudentInput | SessionProgressUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: SessionProgressCreateManyStudentInputEnvelope
    set?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    disconnect?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    delete?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    connect?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    update?: SessionProgressUpdateWithWhereUniqueWithoutStudentInput | SessionProgressUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: SessionProgressUpdateManyWithWhereWithoutStudentInput | SessionProgressUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: SessionProgressScalarWhereInput | SessionProgressScalarWhereInput[]
  }

  export type UserBadgeUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutUserInput | UserBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutUserInput | UserBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutUserInput | UserBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type ExerciseRatingUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExerciseRatingCreateWithoutUserInput, ExerciseRatingUncheckedCreateWithoutUserInput> | ExerciseRatingCreateWithoutUserInput[] | ExerciseRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExerciseRatingCreateOrConnectWithoutUserInput | ExerciseRatingCreateOrConnectWithoutUserInput[]
    upsert?: ExerciseRatingUpsertWithWhereUniqueWithoutUserInput | ExerciseRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExerciseRatingCreateManyUserInputEnvelope
    set?: ExerciseRatingWhereUniqueInput | ExerciseRatingWhereUniqueInput[]
    disconnect?: ExerciseRatingWhereUniqueInput | ExerciseRatingWhereUniqueInput[]
    delete?: ExerciseRatingWhereUniqueInput | ExerciseRatingWhereUniqueInput[]
    connect?: ExerciseRatingWhereUniqueInput | ExerciseRatingWhereUniqueInput[]
    update?: ExerciseRatingUpdateWithWhereUniqueWithoutUserInput | ExerciseRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExerciseRatingUpdateManyWithWhereWithoutUserInput | ExerciseRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExerciseRatingScalarWhereInput | ExerciseRatingScalarWhereInput[]
  }

  export type ExerciseHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExerciseHistoryCreateWithoutUserInput, ExerciseHistoryUncheckedCreateWithoutUserInput> | ExerciseHistoryCreateWithoutUserInput[] | ExerciseHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExerciseHistoryCreateOrConnectWithoutUserInput | ExerciseHistoryCreateOrConnectWithoutUserInput[]
    upsert?: ExerciseHistoryUpsertWithWhereUniqueWithoutUserInput | ExerciseHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExerciseHistoryCreateManyUserInputEnvelope
    set?: ExerciseHistoryWhereUniqueInput | ExerciseHistoryWhereUniqueInput[]
    disconnect?: ExerciseHistoryWhereUniqueInput | ExerciseHistoryWhereUniqueInput[]
    delete?: ExerciseHistoryWhereUniqueInput | ExerciseHistoryWhereUniqueInput[]
    connect?: ExerciseHistoryWhereUniqueInput | ExerciseHistoryWhereUniqueInput[]
    update?: ExerciseHistoryUpdateWithWhereUniqueWithoutUserInput | ExerciseHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExerciseHistoryUpdateManyWithWhereWithoutUserInput | ExerciseHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExerciseHistoryScalarWhereInput | ExerciseHistoryScalarWhereInput[]
  }

  export type FavoriteExerciseUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteExerciseCreateWithoutUserInput, FavoriteExerciseUncheckedCreateWithoutUserInput> | FavoriteExerciseCreateWithoutUserInput[] | FavoriteExerciseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteExerciseCreateOrConnectWithoutUserInput | FavoriteExerciseCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteExerciseUpsertWithWhereUniqueWithoutUserInput | FavoriteExerciseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteExerciseCreateManyUserInputEnvelope
    set?: FavoriteExerciseWhereUniqueInput | FavoriteExerciseWhereUniqueInput[]
    disconnect?: FavoriteExerciseWhereUniqueInput | FavoriteExerciseWhereUniqueInput[]
    delete?: FavoriteExerciseWhereUniqueInput | FavoriteExerciseWhereUniqueInput[]
    connect?: FavoriteExerciseWhereUniqueInput | FavoriteExerciseWhereUniqueInput[]
    update?: FavoriteExerciseUpdateWithWhereUniqueWithoutUserInput | FavoriteExerciseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteExerciseUpdateManyWithWhereWithoutUserInput | FavoriteExerciseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteExerciseScalarWhereInput | FavoriteExerciseScalarWhereInput[]
  }

  export type WorkoutSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkoutSessionCreateWithoutUserInput, WorkoutSessionUncheckedCreateWithoutUserInput> | WorkoutSessionCreateWithoutUserInput[] | WorkoutSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkoutSessionCreateOrConnectWithoutUserInput | WorkoutSessionCreateOrConnectWithoutUserInput[]
    upsert?: WorkoutSessionUpsertWithWhereUniqueWithoutUserInput | WorkoutSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkoutSessionCreateManyUserInputEnvelope
    set?: WorkoutSessionWhereUniqueInput | WorkoutSessionWhereUniqueInput[]
    disconnect?: WorkoutSessionWhereUniqueInput | WorkoutSessionWhereUniqueInput[]
    delete?: WorkoutSessionWhereUniqueInput | WorkoutSessionWhereUniqueInput[]
    connect?: WorkoutSessionWhereUniqueInput | WorkoutSessionWhereUniqueInput[]
    update?: WorkoutSessionUpdateWithWhereUniqueWithoutUserInput | WorkoutSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkoutSessionUpdateManyWithWhereWithoutUserInput | WorkoutSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkoutSessionScalarWhereInput | WorkoutSessionScalarWhereInput[]
  }

  export type UserUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<UserCreateWithoutStudentsInput, UserUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentsInput
    upsert?: UserUpsertWithoutStudentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentsInput, UserUpdateWithoutStudentsInput>, UserUncheckedUpdateWithoutStudentsInput>
  }

  export type UserUpdateManyWithoutCoachNestedInput = {
    create?: XOR<UserCreateWithoutCoachInput, UserUncheckedCreateWithoutCoachInput> | UserCreateWithoutCoachInput[] | UserUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCoachInput | UserCreateOrConnectWithoutCoachInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCoachInput | UserUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: UserCreateManyCoachInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCoachInput | UserUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCoachInput | UserUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ExerciseUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ExerciseCreateWithoutOwnerInput, ExerciseUncheckedCreateWithoutOwnerInput> | ExerciseCreateWithoutOwnerInput[] | ExerciseUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutOwnerInput | ExerciseCreateOrConnectWithoutOwnerInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutOwnerInput | ExerciseUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ExerciseCreateManyOwnerInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutOwnerInput | ExerciseUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutOwnerInput | ExerciseUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type GroupMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutUserInput | GroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutUserInput | GroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutUserInput | GroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<GroupCreateWithoutOwnerInput, GroupUncheckedCreateWithoutOwnerInput> | GroupCreateWithoutOwnerInput[] | GroupUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutOwnerInput | GroupCreateOrConnectWithoutOwnerInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutOwnerInput | GroupUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: GroupCreateManyOwnerInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutOwnerInput | GroupUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutOwnerInput | GroupUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutFromCoachNestedInput = {
    create?: XOR<InvitationCreateWithoutFromCoachInput, InvitationUncheckedCreateWithoutFromCoachInput> | InvitationCreateWithoutFromCoachInput[] | InvitationUncheckedCreateWithoutFromCoachInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutFromCoachInput | InvitationCreateOrConnectWithoutFromCoachInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutFromCoachInput | InvitationUpsertWithWhereUniqueWithoutFromCoachInput[]
    createMany?: InvitationCreateManyFromCoachInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutFromCoachInput | InvitationUpdateWithWhereUniqueWithoutFromCoachInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutFromCoachInput | InvitationUpdateManyWithWhereWithoutFromCoachInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutToUserNestedInput = {
    create?: XOR<InvitationCreateWithoutToUserInput, InvitationUncheckedCreateWithoutToUserInput> | InvitationCreateWithoutToUserInput[] | InvitationUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutToUserInput | InvitationCreateOrConnectWithoutToUserInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutToUserInput | InvitationUpsertWithWhereUniqueWithoutToUserInput[]
    createMany?: InvitationCreateManyToUserInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutToUserInput | InvitationUpdateWithWhereUniqueWithoutToUserInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutToUserInput | InvitationUpdateManyWithWhereWithoutToUserInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ProgramAssignmentUncheckedUpdateManyWithoutAssignerNestedInput = {
    create?: XOR<ProgramAssignmentCreateWithoutAssignerInput, ProgramAssignmentUncheckedCreateWithoutAssignerInput> | ProgramAssignmentCreateWithoutAssignerInput[] | ProgramAssignmentUncheckedCreateWithoutAssignerInput[]
    connectOrCreate?: ProgramAssignmentCreateOrConnectWithoutAssignerInput | ProgramAssignmentCreateOrConnectWithoutAssignerInput[]
    upsert?: ProgramAssignmentUpsertWithWhereUniqueWithoutAssignerInput | ProgramAssignmentUpsertWithWhereUniqueWithoutAssignerInput[]
    createMany?: ProgramAssignmentCreateManyAssignerInputEnvelope
    set?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    disconnect?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    delete?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    connect?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    update?: ProgramAssignmentUpdateWithWhereUniqueWithoutAssignerInput | ProgramAssignmentUpdateWithWhereUniqueWithoutAssignerInput[]
    updateMany?: ProgramAssignmentUpdateManyWithWhereWithoutAssignerInput | ProgramAssignmentUpdateManyWithWhereWithoutAssignerInput[]
    deleteMany?: ProgramAssignmentScalarWhereInput | ProgramAssignmentScalarWhereInput[]
  }

  export type ProgramAssignmentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ProgramAssignmentCreateWithoutStudentInput, ProgramAssignmentUncheckedCreateWithoutStudentInput> | ProgramAssignmentCreateWithoutStudentInput[] | ProgramAssignmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ProgramAssignmentCreateOrConnectWithoutStudentInput | ProgramAssignmentCreateOrConnectWithoutStudentInput[]
    upsert?: ProgramAssignmentUpsertWithWhereUniqueWithoutStudentInput | ProgramAssignmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ProgramAssignmentCreateManyStudentInputEnvelope
    set?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    disconnect?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    delete?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    connect?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    update?: ProgramAssignmentUpdateWithWhereUniqueWithoutStudentInput | ProgramAssignmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ProgramAssignmentUpdateManyWithWhereWithoutStudentInput | ProgramAssignmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ProgramAssignmentScalarWhereInput | ProgramAssignmentScalarWhereInput[]
  }

  export type ProgramAuditUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProgramAuditCreateWithoutUserInput, ProgramAuditUncheckedCreateWithoutUserInput> | ProgramAuditCreateWithoutUserInput[] | ProgramAuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgramAuditCreateOrConnectWithoutUserInput | ProgramAuditCreateOrConnectWithoutUserInput[]
    upsert?: ProgramAuditUpsertWithWhereUniqueWithoutUserInput | ProgramAuditUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProgramAuditCreateManyUserInputEnvelope
    set?: ProgramAuditWhereUniqueInput | ProgramAuditWhereUniqueInput[]
    disconnect?: ProgramAuditWhereUniqueInput | ProgramAuditWhereUniqueInput[]
    delete?: ProgramAuditWhereUniqueInput | ProgramAuditWhereUniqueInput[]
    connect?: ProgramAuditWhereUniqueInput | ProgramAuditWhereUniqueInput[]
    update?: ProgramAuditUpdateWithWhereUniqueWithoutUserInput | ProgramAuditUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProgramAuditUpdateManyWithWhereWithoutUserInput | ProgramAuditUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProgramAuditScalarWhereInput | ProgramAuditScalarWhereInput[]
  }

  export type ProgramUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<ProgramCreateWithoutCoachInput, ProgramUncheckedCreateWithoutCoachInput> | ProgramCreateWithoutCoachInput[] | ProgramUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutCoachInput | ProgramCreateOrConnectWithoutCoachInput[]
    upsert?: ProgramUpsertWithWhereUniqueWithoutCoachInput | ProgramUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: ProgramCreateManyCoachInputEnvelope
    set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    update?: ProgramUpdateWithWhereUniqueWithoutCoachInput | ProgramUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: ProgramUpdateManyWithWhereWithoutCoachInput | ProgramUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
  }

  export type SessionProgressUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<SessionProgressCreateWithoutStudentInput, SessionProgressUncheckedCreateWithoutStudentInput> | SessionProgressCreateWithoutStudentInput[] | SessionProgressUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SessionProgressCreateOrConnectWithoutStudentInput | SessionProgressCreateOrConnectWithoutStudentInput[]
    upsert?: SessionProgressUpsertWithWhereUniqueWithoutStudentInput | SessionProgressUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: SessionProgressCreateManyStudentInputEnvelope
    set?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    disconnect?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    delete?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    connect?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    update?: SessionProgressUpdateWithWhereUniqueWithoutStudentInput | SessionProgressUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: SessionProgressUpdateManyWithWhereWithoutStudentInput | SessionProgressUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: SessionProgressScalarWhereInput | SessionProgressScalarWhereInput[]
  }

  export type UserBadgeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutUserInput | UserBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutUserInput | UserBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutUserInput | UserBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type ExerciseRatingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExerciseRatingCreateWithoutUserInput, ExerciseRatingUncheckedCreateWithoutUserInput> | ExerciseRatingCreateWithoutUserInput[] | ExerciseRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExerciseRatingCreateOrConnectWithoutUserInput | ExerciseRatingCreateOrConnectWithoutUserInput[]
    upsert?: ExerciseRatingUpsertWithWhereUniqueWithoutUserInput | ExerciseRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExerciseRatingCreateManyUserInputEnvelope
    set?: ExerciseRatingWhereUniqueInput | ExerciseRatingWhereUniqueInput[]
    disconnect?: ExerciseRatingWhereUniqueInput | ExerciseRatingWhereUniqueInput[]
    delete?: ExerciseRatingWhereUniqueInput | ExerciseRatingWhereUniqueInput[]
    connect?: ExerciseRatingWhereUniqueInput | ExerciseRatingWhereUniqueInput[]
    update?: ExerciseRatingUpdateWithWhereUniqueWithoutUserInput | ExerciseRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExerciseRatingUpdateManyWithWhereWithoutUserInput | ExerciseRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExerciseRatingScalarWhereInput | ExerciseRatingScalarWhereInput[]
  }

  export type ExerciseHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExerciseHistoryCreateWithoutUserInput, ExerciseHistoryUncheckedCreateWithoutUserInput> | ExerciseHistoryCreateWithoutUserInput[] | ExerciseHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExerciseHistoryCreateOrConnectWithoutUserInput | ExerciseHistoryCreateOrConnectWithoutUserInput[]
    upsert?: ExerciseHistoryUpsertWithWhereUniqueWithoutUserInput | ExerciseHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExerciseHistoryCreateManyUserInputEnvelope
    set?: ExerciseHistoryWhereUniqueInput | ExerciseHistoryWhereUniqueInput[]
    disconnect?: ExerciseHistoryWhereUniqueInput | ExerciseHistoryWhereUniqueInput[]
    delete?: ExerciseHistoryWhereUniqueInput | ExerciseHistoryWhereUniqueInput[]
    connect?: ExerciseHistoryWhereUniqueInput | ExerciseHistoryWhereUniqueInput[]
    update?: ExerciseHistoryUpdateWithWhereUniqueWithoutUserInput | ExerciseHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExerciseHistoryUpdateManyWithWhereWithoutUserInput | ExerciseHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExerciseHistoryScalarWhereInput | ExerciseHistoryScalarWhereInput[]
  }

  export type FavoriteExerciseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteExerciseCreateWithoutUserInput, FavoriteExerciseUncheckedCreateWithoutUserInput> | FavoriteExerciseCreateWithoutUserInput[] | FavoriteExerciseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteExerciseCreateOrConnectWithoutUserInput | FavoriteExerciseCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteExerciseUpsertWithWhereUniqueWithoutUserInput | FavoriteExerciseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteExerciseCreateManyUserInputEnvelope
    set?: FavoriteExerciseWhereUniqueInput | FavoriteExerciseWhereUniqueInput[]
    disconnect?: FavoriteExerciseWhereUniqueInput | FavoriteExerciseWhereUniqueInput[]
    delete?: FavoriteExerciseWhereUniqueInput | FavoriteExerciseWhereUniqueInput[]
    connect?: FavoriteExerciseWhereUniqueInput | FavoriteExerciseWhereUniqueInput[]
    update?: FavoriteExerciseUpdateWithWhereUniqueWithoutUserInput | FavoriteExerciseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteExerciseUpdateManyWithWhereWithoutUserInput | FavoriteExerciseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteExerciseScalarWhereInput | FavoriteExerciseScalarWhereInput[]
  }

  export type WorkoutSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkoutSessionCreateWithoutUserInput, WorkoutSessionUncheckedCreateWithoutUserInput> | WorkoutSessionCreateWithoutUserInput[] | WorkoutSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkoutSessionCreateOrConnectWithoutUserInput | WorkoutSessionCreateOrConnectWithoutUserInput[]
    upsert?: WorkoutSessionUpsertWithWhereUniqueWithoutUserInput | WorkoutSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkoutSessionCreateManyUserInputEnvelope
    set?: WorkoutSessionWhereUniqueInput | WorkoutSessionWhereUniqueInput[]
    disconnect?: WorkoutSessionWhereUniqueInput | WorkoutSessionWhereUniqueInput[]
    delete?: WorkoutSessionWhereUniqueInput | WorkoutSessionWhereUniqueInput[]
    connect?: WorkoutSessionWhereUniqueInput | WorkoutSessionWhereUniqueInput[]
    update?: WorkoutSessionUpdateWithWhereUniqueWithoutUserInput | WorkoutSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkoutSessionUpdateManyWithWhereWithoutUserInput | WorkoutSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkoutSessionScalarWhereInput | WorkoutSessionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<UserCreateWithoutCoachInput, UserUncheckedCreateWithoutCoachInput> | UserCreateWithoutCoachInput[] | UserUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCoachInput | UserCreateOrConnectWithoutCoachInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCoachInput | UserUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: UserCreateManyCoachInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCoachInput | UserUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCoachInput | UserUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type GroupMemberCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutOwnedGroupsInput = {
    create?: XOR<UserCreateWithoutOwnedGroupsInput, UserUncheckedCreateWithoutOwnedGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedGroupsInput
    connect?: UserWhereUniqueInput
  }

  export type InvitationCreateNestedManyWithoutGroupInput = {
    create?: XOR<InvitationCreateWithoutGroupInput, InvitationUncheckedCreateWithoutGroupInput> | InvitationCreateWithoutGroupInput[] | InvitationUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutGroupInput | InvitationCreateOrConnectWithoutGroupInput[]
    createMany?: InvitationCreateManyGroupInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type GroupMemberUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<InvitationCreateWithoutGroupInput, InvitationUncheckedCreateWithoutGroupInput> | InvitationCreateWithoutGroupInput[] | InvitationUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutGroupInput | InvitationCreateOrConnectWithoutGroupInput[]
    createMany?: InvitationCreateManyGroupInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type GroupMemberUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutGroupInput | GroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutGroupInput | GroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutGroupInput | GroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutOwnedGroupsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedGroupsInput, UserUncheckedCreateWithoutOwnedGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedGroupsInput
    upsert?: UserUpsertWithoutOwnedGroupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedGroupsInput, UserUpdateWithoutOwnedGroupsInput>, UserUncheckedUpdateWithoutOwnedGroupsInput>
  }

  export type InvitationUpdateManyWithoutGroupNestedInput = {
    create?: XOR<InvitationCreateWithoutGroupInput, InvitationUncheckedCreateWithoutGroupInput> | InvitationCreateWithoutGroupInput[] | InvitationUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutGroupInput | InvitationCreateOrConnectWithoutGroupInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutGroupInput | InvitationUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: InvitationCreateManyGroupInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutGroupInput | InvitationUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutGroupInput | InvitationUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type GroupMemberUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutGroupInput | GroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutGroupInput | GroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutGroupInput | GroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<InvitationCreateWithoutGroupInput, InvitationUncheckedCreateWithoutGroupInput> | InvitationCreateWithoutGroupInput[] | InvitationUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutGroupInput | InvitationCreateOrConnectWithoutGroupInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutGroupInput | InvitationUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: InvitationCreateManyGroupInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutGroupInput | InvitationUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutGroupInput | InvitationUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type GroupCreateNestedOneWithoutMembersInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput
    connect?: GroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGroupMembershipsInput = {
    create?: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type GroupUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput
    upsert?: GroupUpsertWithoutMembersInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutMembersInput, GroupUpdateWithoutMembersInput>, GroupUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutGroupMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMembershipsInput
    upsert?: UserUpsertWithoutGroupMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGroupMembershipsInput, UserUpdateWithoutGroupMembershipsInput>, UserUncheckedUpdateWithoutGroupMembershipsInput>
  }

  export type UserCreateNestedOneWithoutSentInvitationsInput = {
    create?: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type GroupCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<GroupCreateWithoutInvitationsInput, GroupUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutInvitationsInput
    connect?: GroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedInvitationsInput = {
    create?: XOR<UserCreateWithoutReceivedInvitationsInput, UserUncheckedCreateWithoutReceivedInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumInvitationStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvitationStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutSentInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitationsInput
    upsert?: UserUpsertWithoutSentInvitationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentInvitationsInput, UserUpdateWithoutSentInvitationsInput>, UserUncheckedUpdateWithoutSentInvitationsInput>
  }

  export type GroupUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<GroupCreateWithoutInvitationsInput, GroupUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutInvitationsInput
    upsert?: GroupUpsertWithoutInvitationsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutInvitationsInput, GroupUpdateWithoutInvitationsInput>, GroupUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedInvitationsInput, UserUncheckedCreateWithoutReceivedInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedInvitationsInput
    upsert?: UserUpsertWithoutReceivedInvitationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedInvitationsInput, UserUpdateWithoutReceivedInvitationsInput>, UserUncheckedUpdateWithoutReceivedInvitationsInput>
  }

  export type UserCreateNestedOneWithoutCreatedExercisesInput = {
    create?: XOR<UserCreateWithoutCreatedExercisesInput, UserUncheckedCreateWithoutCreatedExercisesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedExercisesInput
    connect?: UserWhereUniqueInput
  }

  export type SessionExerciseCreateNestedManyWithoutExerciseInput = {
    create?: XOR<SessionExerciseCreateWithoutExerciseInput, SessionExerciseUncheckedCreateWithoutExerciseInput> | SessionExerciseCreateWithoutExerciseInput[] | SessionExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: SessionExerciseCreateOrConnectWithoutExerciseInput | SessionExerciseCreateOrConnectWithoutExerciseInput[]
    createMany?: SessionExerciseCreateManyExerciseInputEnvelope
    connect?: SessionExerciseWhereUniqueInput | SessionExerciseWhereUniqueInput[]
  }

  export type ExerciseRatingCreateNestedManyWithoutExerciseInput = {
    create?: XOR<ExerciseRatingCreateWithoutExerciseInput, ExerciseRatingUncheckedCreateWithoutExerciseInput> | ExerciseRatingCreateWithoutExerciseInput[] | ExerciseRatingUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseRatingCreateOrConnectWithoutExerciseInput | ExerciseRatingCreateOrConnectWithoutExerciseInput[]
    createMany?: ExerciseRatingCreateManyExerciseInputEnvelope
    connect?: ExerciseRatingWhereUniqueInput | ExerciseRatingWhereUniqueInput[]
  }

  export type ExerciseHistoryCreateNestedManyWithoutExerciseInput = {
    create?: XOR<ExerciseHistoryCreateWithoutExerciseInput, ExerciseHistoryUncheckedCreateWithoutExerciseInput> | ExerciseHistoryCreateWithoutExerciseInput[] | ExerciseHistoryUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseHistoryCreateOrConnectWithoutExerciseInput | ExerciseHistoryCreateOrConnectWithoutExerciseInput[]
    createMany?: ExerciseHistoryCreateManyExerciseInputEnvelope
    connect?: ExerciseHistoryWhereUniqueInput | ExerciseHistoryWhereUniqueInput[]
  }

  export type FavoriteExerciseCreateNestedManyWithoutExerciseInput = {
    create?: XOR<FavoriteExerciseCreateWithoutExerciseInput, FavoriteExerciseUncheckedCreateWithoutExerciseInput> | FavoriteExerciseCreateWithoutExerciseInput[] | FavoriteExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: FavoriteExerciseCreateOrConnectWithoutExerciseInput | FavoriteExerciseCreateOrConnectWithoutExerciseInput[]
    createMany?: FavoriteExerciseCreateManyExerciseInputEnvelope
    connect?: FavoriteExerciseWhereUniqueInput | FavoriteExerciseWhereUniqueInput[]
  }

  export type ExerciseLogCreateNestedManyWithoutExerciseInput = {
    create?: XOR<ExerciseLogCreateWithoutExerciseInput, ExerciseLogUncheckedCreateWithoutExerciseInput> | ExerciseLogCreateWithoutExerciseInput[] | ExerciseLogUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseLogCreateOrConnectWithoutExerciseInput | ExerciseLogCreateOrConnectWithoutExerciseInput[]
    createMany?: ExerciseLogCreateManyExerciseInputEnvelope
    connect?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
  }

  export type SessionExerciseUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<SessionExerciseCreateWithoutExerciseInput, SessionExerciseUncheckedCreateWithoutExerciseInput> | SessionExerciseCreateWithoutExerciseInput[] | SessionExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: SessionExerciseCreateOrConnectWithoutExerciseInput | SessionExerciseCreateOrConnectWithoutExerciseInput[]
    createMany?: SessionExerciseCreateManyExerciseInputEnvelope
    connect?: SessionExerciseWhereUniqueInput | SessionExerciseWhereUniqueInput[]
  }

  export type ExerciseRatingUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<ExerciseRatingCreateWithoutExerciseInput, ExerciseRatingUncheckedCreateWithoutExerciseInput> | ExerciseRatingCreateWithoutExerciseInput[] | ExerciseRatingUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseRatingCreateOrConnectWithoutExerciseInput | ExerciseRatingCreateOrConnectWithoutExerciseInput[]
    createMany?: ExerciseRatingCreateManyExerciseInputEnvelope
    connect?: ExerciseRatingWhereUniqueInput | ExerciseRatingWhereUniqueInput[]
  }

  export type ExerciseHistoryUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<ExerciseHistoryCreateWithoutExerciseInput, ExerciseHistoryUncheckedCreateWithoutExerciseInput> | ExerciseHistoryCreateWithoutExerciseInput[] | ExerciseHistoryUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseHistoryCreateOrConnectWithoutExerciseInput | ExerciseHistoryCreateOrConnectWithoutExerciseInput[]
    createMany?: ExerciseHistoryCreateManyExerciseInputEnvelope
    connect?: ExerciseHistoryWhereUniqueInput | ExerciseHistoryWhereUniqueInput[]
  }

  export type FavoriteExerciseUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<FavoriteExerciseCreateWithoutExerciseInput, FavoriteExerciseUncheckedCreateWithoutExerciseInput> | FavoriteExerciseCreateWithoutExerciseInput[] | FavoriteExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: FavoriteExerciseCreateOrConnectWithoutExerciseInput | FavoriteExerciseCreateOrConnectWithoutExerciseInput[]
    createMany?: FavoriteExerciseCreateManyExerciseInputEnvelope
    connect?: FavoriteExerciseWhereUniqueInput | FavoriteExerciseWhereUniqueInput[]
  }

  export type ExerciseLogUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<ExerciseLogCreateWithoutExerciseInput, ExerciseLogUncheckedCreateWithoutExerciseInput> | ExerciseLogCreateWithoutExerciseInput[] | ExerciseLogUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseLogCreateOrConnectWithoutExerciseInput | ExerciseLogCreateOrConnectWithoutExerciseInput[]
    createMany?: ExerciseLogCreateManyExerciseInputEnvelope
    connect?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
  }

  export type EnumExerciseTypeFieldUpdateOperationsInput = {
    set?: $Enums.ExerciseType
  }

  export type EnumScopeFieldUpdateOperationsInput = {
    set?: $Enums.Scope
  }

  export type UserUpdateOneWithoutCreatedExercisesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedExercisesInput, UserUncheckedCreateWithoutCreatedExercisesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedExercisesInput
    upsert?: UserUpsertWithoutCreatedExercisesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedExercisesInput, UserUpdateWithoutCreatedExercisesInput>, UserUncheckedUpdateWithoutCreatedExercisesInput>
  }

  export type SessionExerciseUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<SessionExerciseCreateWithoutExerciseInput, SessionExerciseUncheckedCreateWithoutExerciseInput> | SessionExerciseCreateWithoutExerciseInput[] | SessionExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: SessionExerciseCreateOrConnectWithoutExerciseInput | SessionExerciseCreateOrConnectWithoutExerciseInput[]
    upsert?: SessionExerciseUpsertWithWhereUniqueWithoutExerciseInput | SessionExerciseUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: SessionExerciseCreateManyExerciseInputEnvelope
    set?: SessionExerciseWhereUniqueInput | SessionExerciseWhereUniqueInput[]
    disconnect?: SessionExerciseWhereUniqueInput | SessionExerciseWhereUniqueInput[]
    delete?: SessionExerciseWhereUniqueInput | SessionExerciseWhereUniqueInput[]
    connect?: SessionExerciseWhereUniqueInput | SessionExerciseWhereUniqueInput[]
    update?: SessionExerciseUpdateWithWhereUniqueWithoutExerciseInput | SessionExerciseUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: SessionExerciseUpdateManyWithWhereWithoutExerciseInput | SessionExerciseUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: SessionExerciseScalarWhereInput | SessionExerciseScalarWhereInput[]
  }

  export type ExerciseRatingUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<ExerciseRatingCreateWithoutExerciseInput, ExerciseRatingUncheckedCreateWithoutExerciseInput> | ExerciseRatingCreateWithoutExerciseInput[] | ExerciseRatingUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseRatingCreateOrConnectWithoutExerciseInput | ExerciseRatingCreateOrConnectWithoutExerciseInput[]
    upsert?: ExerciseRatingUpsertWithWhereUniqueWithoutExerciseInput | ExerciseRatingUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: ExerciseRatingCreateManyExerciseInputEnvelope
    set?: ExerciseRatingWhereUniqueInput | ExerciseRatingWhereUniqueInput[]
    disconnect?: ExerciseRatingWhereUniqueInput | ExerciseRatingWhereUniqueInput[]
    delete?: ExerciseRatingWhereUniqueInput | ExerciseRatingWhereUniqueInput[]
    connect?: ExerciseRatingWhereUniqueInput | ExerciseRatingWhereUniqueInput[]
    update?: ExerciseRatingUpdateWithWhereUniqueWithoutExerciseInput | ExerciseRatingUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: ExerciseRatingUpdateManyWithWhereWithoutExerciseInput | ExerciseRatingUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: ExerciseRatingScalarWhereInput | ExerciseRatingScalarWhereInput[]
  }

  export type ExerciseHistoryUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<ExerciseHistoryCreateWithoutExerciseInput, ExerciseHistoryUncheckedCreateWithoutExerciseInput> | ExerciseHistoryCreateWithoutExerciseInput[] | ExerciseHistoryUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseHistoryCreateOrConnectWithoutExerciseInput | ExerciseHistoryCreateOrConnectWithoutExerciseInput[]
    upsert?: ExerciseHistoryUpsertWithWhereUniqueWithoutExerciseInput | ExerciseHistoryUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: ExerciseHistoryCreateManyExerciseInputEnvelope
    set?: ExerciseHistoryWhereUniqueInput | ExerciseHistoryWhereUniqueInput[]
    disconnect?: ExerciseHistoryWhereUniqueInput | ExerciseHistoryWhereUniqueInput[]
    delete?: ExerciseHistoryWhereUniqueInput | ExerciseHistoryWhereUniqueInput[]
    connect?: ExerciseHistoryWhereUniqueInput | ExerciseHistoryWhereUniqueInput[]
    update?: ExerciseHistoryUpdateWithWhereUniqueWithoutExerciseInput | ExerciseHistoryUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: ExerciseHistoryUpdateManyWithWhereWithoutExerciseInput | ExerciseHistoryUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: ExerciseHistoryScalarWhereInput | ExerciseHistoryScalarWhereInput[]
  }

  export type FavoriteExerciseUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<FavoriteExerciseCreateWithoutExerciseInput, FavoriteExerciseUncheckedCreateWithoutExerciseInput> | FavoriteExerciseCreateWithoutExerciseInput[] | FavoriteExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: FavoriteExerciseCreateOrConnectWithoutExerciseInput | FavoriteExerciseCreateOrConnectWithoutExerciseInput[]
    upsert?: FavoriteExerciseUpsertWithWhereUniqueWithoutExerciseInput | FavoriteExerciseUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: FavoriteExerciseCreateManyExerciseInputEnvelope
    set?: FavoriteExerciseWhereUniqueInput | FavoriteExerciseWhereUniqueInput[]
    disconnect?: FavoriteExerciseWhereUniqueInput | FavoriteExerciseWhereUniqueInput[]
    delete?: FavoriteExerciseWhereUniqueInput | FavoriteExerciseWhereUniqueInput[]
    connect?: FavoriteExerciseWhereUniqueInput | FavoriteExerciseWhereUniqueInput[]
    update?: FavoriteExerciseUpdateWithWhereUniqueWithoutExerciseInput | FavoriteExerciseUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: FavoriteExerciseUpdateManyWithWhereWithoutExerciseInput | FavoriteExerciseUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: FavoriteExerciseScalarWhereInput | FavoriteExerciseScalarWhereInput[]
  }

  export type ExerciseLogUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<ExerciseLogCreateWithoutExerciseInput, ExerciseLogUncheckedCreateWithoutExerciseInput> | ExerciseLogCreateWithoutExerciseInput[] | ExerciseLogUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseLogCreateOrConnectWithoutExerciseInput | ExerciseLogCreateOrConnectWithoutExerciseInput[]
    upsert?: ExerciseLogUpsertWithWhereUniqueWithoutExerciseInput | ExerciseLogUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: ExerciseLogCreateManyExerciseInputEnvelope
    set?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    disconnect?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    delete?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    connect?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    update?: ExerciseLogUpdateWithWhereUniqueWithoutExerciseInput | ExerciseLogUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: ExerciseLogUpdateManyWithWhereWithoutExerciseInput | ExerciseLogUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: ExerciseLogScalarWhereInput | ExerciseLogScalarWhereInput[]
  }

  export type SessionExerciseUncheckedUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<SessionExerciseCreateWithoutExerciseInput, SessionExerciseUncheckedCreateWithoutExerciseInput> | SessionExerciseCreateWithoutExerciseInput[] | SessionExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: SessionExerciseCreateOrConnectWithoutExerciseInput | SessionExerciseCreateOrConnectWithoutExerciseInput[]
    upsert?: SessionExerciseUpsertWithWhereUniqueWithoutExerciseInput | SessionExerciseUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: SessionExerciseCreateManyExerciseInputEnvelope
    set?: SessionExerciseWhereUniqueInput | SessionExerciseWhereUniqueInput[]
    disconnect?: SessionExerciseWhereUniqueInput | SessionExerciseWhereUniqueInput[]
    delete?: SessionExerciseWhereUniqueInput | SessionExerciseWhereUniqueInput[]
    connect?: SessionExerciseWhereUniqueInput | SessionExerciseWhereUniqueInput[]
    update?: SessionExerciseUpdateWithWhereUniqueWithoutExerciseInput | SessionExerciseUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: SessionExerciseUpdateManyWithWhereWithoutExerciseInput | SessionExerciseUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: SessionExerciseScalarWhereInput | SessionExerciseScalarWhereInput[]
  }

  export type ExerciseRatingUncheckedUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<ExerciseRatingCreateWithoutExerciseInput, ExerciseRatingUncheckedCreateWithoutExerciseInput> | ExerciseRatingCreateWithoutExerciseInput[] | ExerciseRatingUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseRatingCreateOrConnectWithoutExerciseInput | ExerciseRatingCreateOrConnectWithoutExerciseInput[]
    upsert?: ExerciseRatingUpsertWithWhereUniqueWithoutExerciseInput | ExerciseRatingUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: ExerciseRatingCreateManyExerciseInputEnvelope
    set?: ExerciseRatingWhereUniqueInput | ExerciseRatingWhereUniqueInput[]
    disconnect?: ExerciseRatingWhereUniqueInput | ExerciseRatingWhereUniqueInput[]
    delete?: ExerciseRatingWhereUniqueInput | ExerciseRatingWhereUniqueInput[]
    connect?: ExerciseRatingWhereUniqueInput | ExerciseRatingWhereUniqueInput[]
    update?: ExerciseRatingUpdateWithWhereUniqueWithoutExerciseInput | ExerciseRatingUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: ExerciseRatingUpdateManyWithWhereWithoutExerciseInput | ExerciseRatingUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: ExerciseRatingScalarWhereInput | ExerciseRatingScalarWhereInput[]
  }

  export type ExerciseHistoryUncheckedUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<ExerciseHistoryCreateWithoutExerciseInput, ExerciseHistoryUncheckedCreateWithoutExerciseInput> | ExerciseHistoryCreateWithoutExerciseInput[] | ExerciseHistoryUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseHistoryCreateOrConnectWithoutExerciseInput | ExerciseHistoryCreateOrConnectWithoutExerciseInput[]
    upsert?: ExerciseHistoryUpsertWithWhereUniqueWithoutExerciseInput | ExerciseHistoryUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: ExerciseHistoryCreateManyExerciseInputEnvelope
    set?: ExerciseHistoryWhereUniqueInput | ExerciseHistoryWhereUniqueInput[]
    disconnect?: ExerciseHistoryWhereUniqueInput | ExerciseHistoryWhereUniqueInput[]
    delete?: ExerciseHistoryWhereUniqueInput | ExerciseHistoryWhereUniqueInput[]
    connect?: ExerciseHistoryWhereUniqueInput | ExerciseHistoryWhereUniqueInput[]
    update?: ExerciseHistoryUpdateWithWhereUniqueWithoutExerciseInput | ExerciseHistoryUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: ExerciseHistoryUpdateManyWithWhereWithoutExerciseInput | ExerciseHistoryUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: ExerciseHistoryScalarWhereInput | ExerciseHistoryScalarWhereInput[]
  }

  export type FavoriteExerciseUncheckedUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<FavoriteExerciseCreateWithoutExerciseInput, FavoriteExerciseUncheckedCreateWithoutExerciseInput> | FavoriteExerciseCreateWithoutExerciseInput[] | FavoriteExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: FavoriteExerciseCreateOrConnectWithoutExerciseInput | FavoriteExerciseCreateOrConnectWithoutExerciseInput[]
    upsert?: FavoriteExerciseUpsertWithWhereUniqueWithoutExerciseInput | FavoriteExerciseUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: FavoriteExerciseCreateManyExerciseInputEnvelope
    set?: FavoriteExerciseWhereUniqueInput | FavoriteExerciseWhereUniqueInput[]
    disconnect?: FavoriteExerciseWhereUniqueInput | FavoriteExerciseWhereUniqueInput[]
    delete?: FavoriteExerciseWhereUniqueInput | FavoriteExerciseWhereUniqueInput[]
    connect?: FavoriteExerciseWhereUniqueInput | FavoriteExerciseWhereUniqueInput[]
    update?: FavoriteExerciseUpdateWithWhereUniqueWithoutExerciseInput | FavoriteExerciseUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: FavoriteExerciseUpdateManyWithWhereWithoutExerciseInput | FavoriteExerciseUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: FavoriteExerciseScalarWhereInput | FavoriteExerciseScalarWhereInput[]
  }

  export type ExerciseLogUncheckedUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<ExerciseLogCreateWithoutExerciseInput, ExerciseLogUncheckedCreateWithoutExerciseInput> | ExerciseLogCreateWithoutExerciseInput[] | ExerciseLogUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseLogCreateOrConnectWithoutExerciseInput | ExerciseLogCreateOrConnectWithoutExerciseInput[]
    upsert?: ExerciseLogUpsertWithWhereUniqueWithoutExerciseInput | ExerciseLogUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: ExerciseLogCreateManyExerciseInputEnvelope
    set?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    disconnect?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    delete?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    connect?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    update?: ExerciseLogUpdateWithWhereUniqueWithoutExerciseInput | ExerciseLogUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: ExerciseLogUpdateManyWithWhereWithoutExerciseInput | ExerciseLogUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: ExerciseLogScalarWhereInput | ExerciseLogScalarWhereInput[]
  }

  export type ExerciseCreateNestedOneWithoutRatingsInput = {
    create?: XOR<ExerciseCreateWithoutRatingsInput, ExerciseUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutRatingsInput
    connect?: ExerciseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutExerciseRatingsInput = {
    create?: XOR<UserCreateWithoutExerciseRatingsInput, UserUncheckedCreateWithoutExerciseRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExerciseRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ExerciseUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<ExerciseCreateWithoutRatingsInput, ExerciseUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutRatingsInput
    upsert?: ExerciseUpsertWithoutRatingsInput
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutRatingsInput, ExerciseUpdateWithoutRatingsInput>, ExerciseUncheckedUpdateWithoutRatingsInput>
  }

  export type UserUpdateOneRequiredWithoutExerciseRatingsNestedInput = {
    create?: XOR<UserCreateWithoutExerciseRatingsInput, UserUncheckedCreateWithoutExerciseRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExerciseRatingsInput
    upsert?: UserUpsertWithoutExerciseRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExerciseRatingsInput, UserUpdateWithoutExerciseRatingsInput>, UserUncheckedUpdateWithoutExerciseRatingsInput>
  }

  export type UserCreateNestedOneWithoutExerciseHistoryInput = {
    create?: XOR<UserCreateWithoutExerciseHistoryInput, UserUncheckedCreateWithoutExerciseHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutExerciseHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type ExerciseCreateNestedOneWithoutHistoryInput = {
    create?: XOR<ExerciseCreateWithoutHistoryInput, ExerciseUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutHistoryInput
    connect?: ExerciseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutExerciseHistoryNestedInput = {
    create?: XOR<UserCreateWithoutExerciseHistoryInput, UserUncheckedCreateWithoutExerciseHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutExerciseHistoryInput
    upsert?: UserUpsertWithoutExerciseHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExerciseHistoryInput, UserUpdateWithoutExerciseHistoryInput>, UserUncheckedUpdateWithoutExerciseHistoryInput>
  }

  export type ExerciseUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<ExerciseCreateWithoutHistoryInput, ExerciseUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutHistoryInput
    upsert?: ExerciseUpsertWithoutHistoryInput
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutHistoryInput, ExerciseUpdateWithoutHistoryInput>, ExerciseUncheckedUpdateWithoutHistoryInput>
  }

  export type UserCreateNestedOneWithoutFavoriteExercisesInput = {
    create?: XOR<UserCreateWithoutFavoriteExercisesInput, UserUncheckedCreateWithoutFavoriteExercisesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoriteExercisesInput
    connect?: UserWhereUniqueInput
  }

  export type ExerciseCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<ExerciseCreateWithoutFavoritesInput, ExerciseUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutFavoritesInput
    connect?: ExerciseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFavoriteExercisesNestedInput = {
    create?: XOR<UserCreateWithoutFavoriteExercisesInput, UserUncheckedCreateWithoutFavoriteExercisesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoriteExercisesInput
    upsert?: UserUpsertWithoutFavoriteExercisesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavoriteExercisesInput, UserUpdateWithoutFavoriteExercisesInput>, UserUncheckedUpdateWithoutFavoriteExercisesInput>
  }

  export type ExerciseUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<ExerciseCreateWithoutFavoritesInput, ExerciseUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutFavoritesInput
    upsert?: ExerciseUpsertWithoutFavoritesInput
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutFavoritesInput, ExerciseUpdateWithoutFavoritesInput>, ExerciseUncheckedUpdateWithoutFavoritesInput>
  }

  export type UserCreateNestedOneWithoutWorkoutSessionsInput = {
    create?: XOR<UserCreateWithoutWorkoutSessionsInput, UserUncheckedCreateWithoutWorkoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type ExerciseLogCreateNestedManyWithoutSessionInput = {
    create?: XOR<ExerciseLogCreateWithoutSessionInput, ExerciseLogUncheckedCreateWithoutSessionInput> | ExerciseLogCreateWithoutSessionInput[] | ExerciseLogUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ExerciseLogCreateOrConnectWithoutSessionInput | ExerciseLogCreateOrConnectWithoutSessionInput[]
    createMany?: ExerciseLogCreateManySessionInputEnvelope
    connect?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
  }

  export type ExerciseLogUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ExerciseLogCreateWithoutSessionInput, ExerciseLogUncheckedCreateWithoutSessionInput> | ExerciseLogCreateWithoutSessionInput[] | ExerciseLogUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ExerciseLogCreateOrConnectWithoutSessionInput | ExerciseLogCreateOrConnectWithoutSessionInput[]
    createMany?: ExerciseLogCreateManySessionInputEnvelope
    connect?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneRequiredWithoutWorkoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutWorkoutSessionsInput, UserUncheckedCreateWithoutWorkoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkoutSessionsInput
    upsert?: UserUpsertWithoutWorkoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkoutSessionsInput, UserUpdateWithoutWorkoutSessionsInput>, UserUncheckedUpdateWithoutWorkoutSessionsInput>
  }

  export type ExerciseLogUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ExerciseLogCreateWithoutSessionInput, ExerciseLogUncheckedCreateWithoutSessionInput> | ExerciseLogCreateWithoutSessionInput[] | ExerciseLogUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ExerciseLogCreateOrConnectWithoutSessionInput | ExerciseLogCreateOrConnectWithoutSessionInput[]
    upsert?: ExerciseLogUpsertWithWhereUniqueWithoutSessionInput | ExerciseLogUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ExerciseLogCreateManySessionInputEnvelope
    set?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    disconnect?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    delete?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    connect?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    update?: ExerciseLogUpdateWithWhereUniqueWithoutSessionInput | ExerciseLogUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ExerciseLogUpdateManyWithWhereWithoutSessionInput | ExerciseLogUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ExerciseLogScalarWhereInput | ExerciseLogScalarWhereInput[]
  }

  export type ExerciseLogUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ExerciseLogCreateWithoutSessionInput, ExerciseLogUncheckedCreateWithoutSessionInput> | ExerciseLogCreateWithoutSessionInput[] | ExerciseLogUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ExerciseLogCreateOrConnectWithoutSessionInput | ExerciseLogCreateOrConnectWithoutSessionInput[]
    upsert?: ExerciseLogUpsertWithWhereUniqueWithoutSessionInput | ExerciseLogUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ExerciseLogCreateManySessionInputEnvelope
    set?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    disconnect?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    delete?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    connect?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    update?: ExerciseLogUpdateWithWhereUniqueWithoutSessionInput | ExerciseLogUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ExerciseLogUpdateManyWithWhereWithoutSessionInput | ExerciseLogUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ExerciseLogScalarWhereInput | ExerciseLogScalarWhereInput[]
  }

  export type WorkoutSessionCreateNestedOneWithoutLogsInput = {
    create?: XOR<WorkoutSessionCreateWithoutLogsInput, WorkoutSessionUncheckedCreateWithoutLogsInput>
    connectOrCreate?: WorkoutSessionCreateOrConnectWithoutLogsInput
    connect?: WorkoutSessionWhereUniqueInput
  }

  export type ExerciseCreateNestedOneWithoutLogsInput = {
    create?: XOR<ExerciseCreateWithoutLogsInput, ExerciseUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutLogsInput
    connect?: ExerciseWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkoutSessionUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<WorkoutSessionCreateWithoutLogsInput, WorkoutSessionUncheckedCreateWithoutLogsInput>
    connectOrCreate?: WorkoutSessionCreateOrConnectWithoutLogsInput
    upsert?: WorkoutSessionUpsertWithoutLogsInput
    connect?: WorkoutSessionWhereUniqueInput
    update?: XOR<XOR<WorkoutSessionUpdateToOneWithWhereWithoutLogsInput, WorkoutSessionUpdateWithoutLogsInput>, WorkoutSessionUncheckedUpdateWithoutLogsInput>
  }

  export type ExerciseUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<ExerciseCreateWithoutLogsInput, ExerciseUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutLogsInput
    upsert?: ExerciseUpsertWithoutLogsInput
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutLogsInput, ExerciseUpdateWithoutLogsInput>, ExerciseUncheckedUpdateWithoutLogsInput>
  }

  export type ProgramAssignmentCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProgramAssignmentCreateWithoutProgramInput, ProgramAssignmentUncheckedCreateWithoutProgramInput> | ProgramAssignmentCreateWithoutProgramInput[] | ProgramAssignmentUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramAssignmentCreateOrConnectWithoutProgramInput | ProgramAssignmentCreateOrConnectWithoutProgramInput[]
    createMany?: ProgramAssignmentCreateManyProgramInputEnvelope
    connect?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
  }

  export type ProgramAuditCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProgramAuditCreateWithoutProgramInput, ProgramAuditUncheckedCreateWithoutProgramInput> | ProgramAuditCreateWithoutProgramInput[] | ProgramAuditUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramAuditCreateOrConnectWithoutProgramInput | ProgramAuditCreateOrConnectWithoutProgramInput[]
    createMany?: ProgramAuditCreateManyProgramInputEnvelope
    connect?: ProgramAuditWhereUniqueInput | ProgramAuditWhereUniqueInput[]
  }

  export type ProgramBlockCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProgramBlockCreateWithoutProgramInput, ProgramBlockUncheckedCreateWithoutProgramInput> | ProgramBlockCreateWithoutProgramInput[] | ProgramBlockUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramBlockCreateOrConnectWithoutProgramInput | ProgramBlockCreateOrConnectWithoutProgramInput[]
    createMany?: ProgramBlockCreateManyProgramInputEnvelope
    connect?: ProgramBlockWhereUniqueInput | ProgramBlockWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedProgramsInput = {
    create?: XOR<UserCreateWithoutCreatedProgramsInput, UserUncheckedCreateWithoutCreatedProgramsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedProgramsInput
    connect?: UserWhereUniqueInput
  }

  export type ProgramAssignmentUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProgramAssignmentCreateWithoutProgramInput, ProgramAssignmentUncheckedCreateWithoutProgramInput> | ProgramAssignmentCreateWithoutProgramInput[] | ProgramAssignmentUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramAssignmentCreateOrConnectWithoutProgramInput | ProgramAssignmentCreateOrConnectWithoutProgramInput[]
    createMany?: ProgramAssignmentCreateManyProgramInputEnvelope
    connect?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
  }

  export type ProgramAuditUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProgramAuditCreateWithoutProgramInput, ProgramAuditUncheckedCreateWithoutProgramInput> | ProgramAuditCreateWithoutProgramInput[] | ProgramAuditUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramAuditCreateOrConnectWithoutProgramInput | ProgramAuditCreateOrConnectWithoutProgramInput[]
    createMany?: ProgramAuditCreateManyProgramInputEnvelope
    connect?: ProgramAuditWhereUniqueInput | ProgramAuditWhereUniqueInput[]
  }

  export type ProgramBlockUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProgramBlockCreateWithoutProgramInput, ProgramBlockUncheckedCreateWithoutProgramInput> | ProgramBlockCreateWithoutProgramInput[] | ProgramBlockUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramBlockCreateOrConnectWithoutProgramInput | ProgramBlockCreateOrConnectWithoutProgramInput[]
    createMany?: ProgramBlockCreateManyProgramInputEnvelope
    connect?: ProgramBlockWhereUniqueInput | ProgramBlockWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProgramAssignmentUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProgramAssignmentCreateWithoutProgramInput, ProgramAssignmentUncheckedCreateWithoutProgramInput> | ProgramAssignmentCreateWithoutProgramInput[] | ProgramAssignmentUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramAssignmentCreateOrConnectWithoutProgramInput | ProgramAssignmentCreateOrConnectWithoutProgramInput[]
    upsert?: ProgramAssignmentUpsertWithWhereUniqueWithoutProgramInput | ProgramAssignmentUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProgramAssignmentCreateManyProgramInputEnvelope
    set?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    disconnect?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    delete?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    connect?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    update?: ProgramAssignmentUpdateWithWhereUniqueWithoutProgramInput | ProgramAssignmentUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProgramAssignmentUpdateManyWithWhereWithoutProgramInput | ProgramAssignmentUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProgramAssignmentScalarWhereInput | ProgramAssignmentScalarWhereInput[]
  }

  export type ProgramAuditUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProgramAuditCreateWithoutProgramInput, ProgramAuditUncheckedCreateWithoutProgramInput> | ProgramAuditCreateWithoutProgramInput[] | ProgramAuditUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramAuditCreateOrConnectWithoutProgramInput | ProgramAuditCreateOrConnectWithoutProgramInput[]
    upsert?: ProgramAuditUpsertWithWhereUniqueWithoutProgramInput | ProgramAuditUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProgramAuditCreateManyProgramInputEnvelope
    set?: ProgramAuditWhereUniqueInput | ProgramAuditWhereUniqueInput[]
    disconnect?: ProgramAuditWhereUniqueInput | ProgramAuditWhereUniqueInput[]
    delete?: ProgramAuditWhereUniqueInput | ProgramAuditWhereUniqueInput[]
    connect?: ProgramAuditWhereUniqueInput | ProgramAuditWhereUniqueInput[]
    update?: ProgramAuditUpdateWithWhereUniqueWithoutProgramInput | ProgramAuditUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProgramAuditUpdateManyWithWhereWithoutProgramInput | ProgramAuditUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProgramAuditScalarWhereInput | ProgramAuditScalarWhereInput[]
  }

  export type ProgramBlockUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProgramBlockCreateWithoutProgramInput, ProgramBlockUncheckedCreateWithoutProgramInput> | ProgramBlockCreateWithoutProgramInput[] | ProgramBlockUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramBlockCreateOrConnectWithoutProgramInput | ProgramBlockCreateOrConnectWithoutProgramInput[]
    upsert?: ProgramBlockUpsertWithWhereUniqueWithoutProgramInput | ProgramBlockUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProgramBlockCreateManyProgramInputEnvelope
    set?: ProgramBlockWhereUniqueInput | ProgramBlockWhereUniqueInput[]
    disconnect?: ProgramBlockWhereUniqueInput | ProgramBlockWhereUniqueInput[]
    delete?: ProgramBlockWhereUniqueInput | ProgramBlockWhereUniqueInput[]
    connect?: ProgramBlockWhereUniqueInput | ProgramBlockWhereUniqueInput[]
    update?: ProgramBlockUpdateWithWhereUniqueWithoutProgramInput | ProgramBlockUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProgramBlockUpdateManyWithWhereWithoutProgramInput | ProgramBlockUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProgramBlockScalarWhereInput | ProgramBlockScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedProgramsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedProgramsInput, UserUncheckedCreateWithoutCreatedProgramsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedProgramsInput
    upsert?: UserUpsertWithoutCreatedProgramsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedProgramsInput, UserUpdateWithoutCreatedProgramsInput>, UserUncheckedUpdateWithoutCreatedProgramsInput>
  }

  export type ProgramAssignmentUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProgramAssignmentCreateWithoutProgramInput, ProgramAssignmentUncheckedCreateWithoutProgramInput> | ProgramAssignmentCreateWithoutProgramInput[] | ProgramAssignmentUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramAssignmentCreateOrConnectWithoutProgramInput | ProgramAssignmentCreateOrConnectWithoutProgramInput[]
    upsert?: ProgramAssignmentUpsertWithWhereUniqueWithoutProgramInput | ProgramAssignmentUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProgramAssignmentCreateManyProgramInputEnvelope
    set?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    disconnect?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    delete?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    connect?: ProgramAssignmentWhereUniqueInput | ProgramAssignmentWhereUniqueInput[]
    update?: ProgramAssignmentUpdateWithWhereUniqueWithoutProgramInput | ProgramAssignmentUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProgramAssignmentUpdateManyWithWhereWithoutProgramInput | ProgramAssignmentUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProgramAssignmentScalarWhereInput | ProgramAssignmentScalarWhereInput[]
  }

  export type ProgramAuditUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProgramAuditCreateWithoutProgramInput, ProgramAuditUncheckedCreateWithoutProgramInput> | ProgramAuditCreateWithoutProgramInput[] | ProgramAuditUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramAuditCreateOrConnectWithoutProgramInput | ProgramAuditCreateOrConnectWithoutProgramInput[]
    upsert?: ProgramAuditUpsertWithWhereUniqueWithoutProgramInput | ProgramAuditUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProgramAuditCreateManyProgramInputEnvelope
    set?: ProgramAuditWhereUniqueInput | ProgramAuditWhereUniqueInput[]
    disconnect?: ProgramAuditWhereUniqueInput | ProgramAuditWhereUniqueInput[]
    delete?: ProgramAuditWhereUniqueInput | ProgramAuditWhereUniqueInput[]
    connect?: ProgramAuditWhereUniqueInput | ProgramAuditWhereUniqueInput[]
    update?: ProgramAuditUpdateWithWhereUniqueWithoutProgramInput | ProgramAuditUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProgramAuditUpdateManyWithWhereWithoutProgramInput | ProgramAuditUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProgramAuditScalarWhereInput | ProgramAuditScalarWhereInput[]
  }

  export type ProgramBlockUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProgramBlockCreateWithoutProgramInput, ProgramBlockUncheckedCreateWithoutProgramInput> | ProgramBlockCreateWithoutProgramInput[] | ProgramBlockUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramBlockCreateOrConnectWithoutProgramInput | ProgramBlockCreateOrConnectWithoutProgramInput[]
    upsert?: ProgramBlockUpsertWithWhereUniqueWithoutProgramInput | ProgramBlockUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProgramBlockCreateManyProgramInputEnvelope
    set?: ProgramBlockWhereUniqueInput | ProgramBlockWhereUniqueInput[]
    disconnect?: ProgramBlockWhereUniqueInput | ProgramBlockWhereUniqueInput[]
    delete?: ProgramBlockWhereUniqueInput | ProgramBlockWhereUniqueInput[]
    connect?: ProgramBlockWhereUniqueInput | ProgramBlockWhereUniqueInput[]
    update?: ProgramBlockUpdateWithWhereUniqueWithoutProgramInput | ProgramBlockUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProgramBlockUpdateManyWithWhereWithoutProgramInput | ProgramBlockUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProgramBlockScalarWhereInput | ProgramBlockScalarWhereInput[]
  }

  export type ProgramCreateNestedOneWithoutBlocksInput = {
    create?: XOR<ProgramCreateWithoutBlocksInput, ProgramUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutBlocksInput
    connect?: ProgramWhereUniqueInput
  }

  export type WeekCreateNestedManyWithoutBlockInput = {
    create?: XOR<WeekCreateWithoutBlockInput, WeekUncheckedCreateWithoutBlockInput> | WeekCreateWithoutBlockInput[] | WeekUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: WeekCreateOrConnectWithoutBlockInput | WeekCreateOrConnectWithoutBlockInput[]
    createMany?: WeekCreateManyBlockInputEnvelope
    connect?: WeekWhereUniqueInput | WeekWhereUniqueInput[]
  }

  export type WeekUncheckedCreateNestedManyWithoutBlockInput = {
    create?: XOR<WeekCreateWithoutBlockInput, WeekUncheckedCreateWithoutBlockInput> | WeekCreateWithoutBlockInput[] | WeekUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: WeekCreateOrConnectWithoutBlockInput | WeekCreateOrConnectWithoutBlockInput[]
    createMany?: WeekCreateManyBlockInputEnvelope
    connect?: WeekWhereUniqueInput | WeekWhereUniqueInput[]
  }

  export type ProgramUpdateOneRequiredWithoutBlocksNestedInput = {
    create?: XOR<ProgramCreateWithoutBlocksInput, ProgramUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutBlocksInput
    upsert?: ProgramUpsertWithoutBlocksInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutBlocksInput, ProgramUpdateWithoutBlocksInput>, ProgramUncheckedUpdateWithoutBlocksInput>
  }

  export type WeekUpdateManyWithoutBlockNestedInput = {
    create?: XOR<WeekCreateWithoutBlockInput, WeekUncheckedCreateWithoutBlockInput> | WeekCreateWithoutBlockInput[] | WeekUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: WeekCreateOrConnectWithoutBlockInput | WeekCreateOrConnectWithoutBlockInput[]
    upsert?: WeekUpsertWithWhereUniqueWithoutBlockInput | WeekUpsertWithWhereUniqueWithoutBlockInput[]
    createMany?: WeekCreateManyBlockInputEnvelope
    set?: WeekWhereUniqueInput | WeekWhereUniqueInput[]
    disconnect?: WeekWhereUniqueInput | WeekWhereUniqueInput[]
    delete?: WeekWhereUniqueInput | WeekWhereUniqueInput[]
    connect?: WeekWhereUniqueInput | WeekWhereUniqueInput[]
    update?: WeekUpdateWithWhereUniqueWithoutBlockInput | WeekUpdateWithWhereUniqueWithoutBlockInput[]
    updateMany?: WeekUpdateManyWithWhereWithoutBlockInput | WeekUpdateManyWithWhereWithoutBlockInput[]
    deleteMany?: WeekScalarWhereInput | WeekScalarWhereInput[]
  }

  export type WeekUncheckedUpdateManyWithoutBlockNestedInput = {
    create?: XOR<WeekCreateWithoutBlockInput, WeekUncheckedCreateWithoutBlockInput> | WeekCreateWithoutBlockInput[] | WeekUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: WeekCreateOrConnectWithoutBlockInput | WeekCreateOrConnectWithoutBlockInput[]
    upsert?: WeekUpsertWithWhereUniqueWithoutBlockInput | WeekUpsertWithWhereUniqueWithoutBlockInput[]
    createMany?: WeekCreateManyBlockInputEnvelope
    set?: WeekWhereUniqueInput | WeekWhereUniqueInput[]
    disconnect?: WeekWhereUniqueInput | WeekWhereUniqueInput[]
    delete?: WeekWhereUniqueInput | WeekWhereUniqueInput[]
    connect?: WeekWhereUniqueInput | WeekWhereUniqueInput[]
    update?: WeekUpdateWithWhereUniqueWithoutBlockInput | WeekUpdateWithWhereUniqueWithoutBlockInput[]
    updateMany?: WeekUpdateManyWithWhereWithoutBlockInput | WeekUpdateManyWithWhereWithoutBlockInput[]
    deleteMany?: WeekScalarWhereInput | WeekScalarWhereInput[]
  }

  export type SessionCreateNestedManyWithoutWeekInput = {
    create?: XOR<SessionCreateWithoutWeekInput, SessionUncheckedCreateWithoutWeekInput> | SessionCreateWithoutWeekInput[] | SessionUncheckedCreateWithoutWeekInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutWeekInput | SessionCreateOrConnectWithoutWeekInput[]
    createMany?: SessionCreateManyWeekInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ProgramBlockCreateNestedOneWithoutWeeksInput = {
    create?: XOR<ProgramBlockCreateWithoutWeeksInput, ProgramBlockUncheckedCreateWithoutWeeksInput>
    connectOrCreate?: ProgramBlockCreateOrConnectWithoutWeeksInput
    connect?: ProgramBlockWhereUniqueInput
  }

  export type SessionUncheckedCreateNestedManyWithoutWeekInput = {
    create?: XOR<SessionCreateWithoutWeekInput, SessionUncheckedCreateWithoutWeekInput> | SessionCreateWithoutWeekInput[] | SessionUncheckedCreateWithoutWeekInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutWeekInput | SessionCreateOrConnectWithoutWeekInput[]
    createMany?: SessionCreateManyWeekInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SessionUpdateManyWithoutWeekNestedInput = {
    create?: XOR<SessionCreateWithoutWeekInput, SessionUncheckedCreateWithoutWeekInput> | SessionCreateWithoutWeekInput[] | SessionUncheckedCreateWithoutWeekInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutWeekInput | SessionCreateOrConnectWithoutWeekInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutWeekInput | SessionUpsertWithWhereUniqueWithoutWeekInput[]
    createMany?: SessionCreateManyWeekInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutWeekInput | SessionUpdateWithWhereUniqueWithoutWeekInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutWeekInput | SessionUpdateManyWithWhereWithoutWeekInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ProgramBlockUpdateOneRequiredWithoutWeeksNestedInput = {
    create?: XOR<ProgramBlockCreateWithoutWeeksInput, ProgramBlockUncheckedCreateWithoutWeeksInput>
    connectOrCreate?: ProgramBlockCreateOrConnectWithoutWeeksInput
    upsert?: ProgramBlockUpsertWithoutWeeksInput
    connect?: ProgramBlockWhereUniqueInput
    update?: XOR<XOR<ProgramBlockUpdateToOneWithWhereWithoutWeeksInput, ProgramBlockUpdateWithoutWeeksInput>, ProgramBlockUncheckedUpdateWithoutWeeksInput>
  }

  export type SessionUncheckedUpdateManyWithoutWeekNestedInput = {
    create?: XOR<SessionCreateWithoutWeekInput, SessionUncheckedCreateWithoutWeekInput> | SessionCreateWithoutWeekInput[] | SessionUncheckedCreateWithoutWeekInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutWeekInput | SessionCreateOrConnectWithoutWeekInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutWeekInput | SessionUpsertWithWhereUniqueWithoutWeekInput[]
    createMany?: SessionCreateManyWeekInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutWeekInput | SessionUpdateWithWhereUniqueWithoutWeekInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutWeekInput | SessionUpdateManyWithWhereWithoutWeekInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SessionExerciseCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionExerciseCreateWithoutSessionInput, SessionExerciseUncheckedCreateWithoutSessionInput> | SessionExerciseCreateWithoutSessionInput[] | SessionExerciseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionExerciseCreateOrConnectWithoutSessionInput | SessionExerciseCreateOrConnectWithoutSessionInput[]
    createMany?: SessionExerciseCreateManySessionInputEnvelope
    connect?: SessionExerciseWhereUniqueInput | SessionExerciseWhereUniqueInput[]
  }

  export type SessionProgressCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionProgressCreateWithoutSessionInput, SessionProgressUncheckedCreateWithoutSessionInput> | SessionProgressCreateWithoutSessionInput[] | SessionProgressUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionProgressCreateOrConnectWithoutSessionInput | SessionProgressCreateOrConnectWithoutSessionInput[]
    createMany?: SessionProgressCreateManySessionInputEnvelope
    connect?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
  }

  export type WeekCreateNestedOneWithoutSessionsInput = {
    create?: XOR<WeekCreateWithoutSessionsInput, WeekUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: WeekCreateOrConnectWithoutSessionsInput
    connect?: WeekWhereUniqueInput
  }

  export type SessionExerciseUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionExerciseCreateWithoutSessionInput, SessionExerciseUncheckedCreateWithoutSessionInput> | SessionExerciseCreateWithoutSessionInput[] | SessionExerciseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionExerciseCreateOrConnectWithoutSessionInput | SessionExerciseCreateOrConnectWithoutSessionInput[]
    createMany?: SessionExerciseCreateManySessionInputEnvelope
    connect?: SessionExerciseWhereUniqueInput | SessionExerciseWhereUniqueInput[]
  }

  export type SessionProgressUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionProgressCreateWithoutSessionInput, SessionProgressUncheckedCreateWithoutSessionInput> | SessionProgressCreateWithoutSessionInput[] | SessionProgressUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionProgressCreateOrConnectWithoutSessionInput | SessionProgressCreateOrConnectWithoutSessionInput[]
    createMany?: SessionProgressCreateManySessionInputEnvelope
    connect?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
  }

  export type SessionExerciseUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionExerciseCreateWithoutSessionInput, SessionExerciseUncheckedCreateWithoutSessionInput> | SessionExerciseCreateWithoutSessionInput[] | SessionExerciseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionExerciseCreateOrConnectWithoutSessionInput | SessionExerciseCreateOrConnectWithoutSessionInput[]
    upsert?: SessionExerciseUpsertWithWhereUniqueWithoutSessionInput | SessionExerciseUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionExerciseCreateManySessionInputEnvelope
    set?: SessionExerciseWhereUniqueInput | SessionExerciseWhereUniqueInput[]
    disconnect?: SessionExerciseWhereUniqueInput | SessionExerciseWhereUniqueInput[]
    delete?: SessionExerciseWhereUniqueInput | SessionExerciseWhereUniqueInput[]
    connect?: SessionExerciseWhereUniqueInput | SessionExerciseWhereUniqueInput[]
    update?: SessionExerciseUpdateWithWhereUniqueWithoutSessionInput | SessionExerciseUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionExerciseUpdateManyWithWhereWithoutSessionInput | SessionExerciseUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionExerciseScalarWhereInput | SessionExerciseScalarWhereInput[]
  }

  export type SessionProgressUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionProgressCreateWithoutSessionInput, SessionProgressUncheckedCreateWithoutSessionInput> | SessionProgressCreateWithoutSessionInput[] | SessionProgressUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionProgressCreateOrConnectWithoutSessionInput | SessionProgressCreateOrConnectWithoutSessionInput[]
    upsert?: SessionProgressUpsertWithWhereUniqueWithoutSessionInput | SessionProgressUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionProgressCreateManySessionInputEnvelope
    set?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    disconnect?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    delete?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    connect?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    update?: SessionProgressUpdateWithWhereUniqueWithoutSessionInput | SessionProgressUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionProgressUpdateManyWithWhereWithoutSessionInput | SessionProgressUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionProgressScalarWhereInput | SessionProgressScalarWhereInput[]
  }

  export type WeekUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<WeekCreateWithoutSessionsInput, WeekUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: WeekCreateOrConnectWithoutSessionsInput
    upsert?: WeekUpsertWithoutSessionsInput
    connect?: WeekWhereUniqueInput
    update?: XOR<XOR<WeekUpdateToOneWithWhereWithoutSessionsInput, WeekUpdateWithoutSessionsInput>, WeekUncheckedUpdateWithoutSessionsInput>
  }

  export type SessionExerciseUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionExerciseCreateWithoutSessionInput, SessionExerciseUncheckedCreateWithoutSessionInput> | SessionExerciseCreateWithoutSessionInput[] | SessionExerciseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionExerciseCreateOrConnectWithoutSessionInput | SessionExerciseCreateOrConnectWithoutSessionInput[]
    upsert?: SessionExerciseUpsertWithWhereUniqueWithoutSessionInput | SessionExerciseUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionExerciseCreateManySessionInputEnvelope
    set?: SessionExerciseWhereUniqueInput | SessionExerciseWhereUniqueInput[]
    disconnect?: SessionExerciseWhereUniqueInput | SessionExerciseWhereUniqueInput[]
    delete?: SessionExerciseWhereUniqueInput | SessionExerciseWhereUniqueInput[]
    connect?: SessionExerciseWhereUniqueInput | SessionExerciseWhereUniqueInput[]
    update?: SessionExerciseUpdateWithWhereUniqueWithoutSessionInput | SessionExerciseUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionExerciseUpdateManyWithWhereWithoutSessionInput | SessionExerciseUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionExerciseScalarWhereInput | SessionExerciseScalarWhereInput[]
  }

  export type SessionProgressUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionProgressCreateWithoutSessionInput, SessionProgressUncheckedCreateWithoutSessionInput> | SessionProgressCreateWithoutSessionInput[] | SessionProgressUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionProgressCreateOrConnectWithoutSessionInput | SessionProgressCreateOrConnectWithoutSessionInput[]
    upsert?: SessionProgressUpsertWithWhereUniqueWithoutSessionInput | SessionProgressUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionProgressCreateManySessionInputEnvelope
    set?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    disconnect?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    delete?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    connect?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    update?: SessionProgressUpdateWithWhereUniqueWithoutSessionInput | SessionProgressUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionProgressUpdateManyWithWhereWithoutSessionInput | SessionProgressUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionProgressScalarWhereInput | SessionProgressScalarWhereInput[]
  }

  export type ExerciseCreateNestedOneWithoutSessionExercisesInput = {
    create?: XOR<ExerciseCreateWithoutSessionExercisesInput, ExerciseUncheckedCreateWithoutSessionExercisesInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutSessionExercisesInput
    connect?: ExerciseWhereUniqueInput
  }

  export type SessionCreateNestedOneWithoutExercisesInput = {
    create?: XOR<SessionCreateWithoutExercisesInput, SessionUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutExercisesInput
    connect?: SessionWhereUniqueInput
  }

  export type SessionProgressCreateNestedManyWithoutExerciseInstanceInput = {
    create?: XOR<SessionProgressCreateWithoutExerciseInstanceInput, SessionProgressUncheckedCreateWithoutExerciseInstanceInput> | SessionProgressCreateWithoutExerciseInstanceInput[] | SessionProgressUncheckedCreateWithoutExerciseInstanceInput[]
    connectOrCreate?: SessionProgressCreateOrConnectWithoutExerciseInstanceInput | SessionProgressCreateOrConnectWithoutExerciseInstanceInput[]
    createMany?: SessionProgressCreateManyExerciseInstanceInputEnvelope
    connect?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
  }

  export type SessionProgressUncheckedCreateNestedManyWithoutExerciseInstanceInput = {
    create?: XOR<SessionProgressCreateWithoutExerciseInstanceInput, SessionProgressUncheckedCreateWithoutExerciseInstanceInput> | SessionProgressCreateWithoutExerciseInstanceInput[] | SessionProgressUncheckedCreateWithoutExerciseInstanceInput[]
    connectOrCreate?: SessionProgressCreateOrConnectWithoutExerciseInstanceInput | SessionProgressCreateOrConnectWithoutExerciseInstanceInput[]
    createMany?: SessionProgressCreateManyExerciseInstanceInputEnvelope
    connect?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
  }

  export type ExerciseUpdateOneRequiredWithoutSessionExercisesNestedInput = {
    create?: XOR<ExerciseCreateWithoutSessionExercisesInput, ExerciseUncheckedCreateWithoutSessionExercisesInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutSessionExercisesInput
    upsert?: ExerciseUpsertWithoutSessionExercisesInput
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutSessionExercisesInput, ExerciseUpdateWithoutSessionExercisesInput>, ExerciseUncheckedUpdateWithoutSessionExercisesInput>
  }

  export type SessionUpdateOneRequiredWithoutExercisesNestedInput = {
    create?: XOR<SessionCreateWithoutExercisesInput, SessionUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutExercisesInput
    upsert?: SessionUpsertWithoutExercisesInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutExercisesInput, SessionUpdateWithoutExercisesInput>, SessionUncheckedUpdateWithoutExercisesInput>
  }

  export type SessionProgressUpdateManyWithoutExerciseInstanceNestedInput = {
    create?: XOR<SessionProgressCreateWithoutExerciseInstanceInput, SessionProgressUncheckedCreateWithoutExerciseInstanceInput> | SessionProgressCreateWithoutExerciseInstanceInput[] | SessionProgressUncheckedCreateWithoutExerciseInstanceInput[]
    connectOrCreate?: SessionProgressCreateOrConnectWithoutExerciseInstanceInput | SessionProgressCreateOrConnectWithoutExerciseInstanceInput[]
    upsert?: SessionProgressUpsertWithWhereUniqueWithoutExerciseInstanceInput | SessionProgressUpsertWithWhereUniqueWithoutExerciseInstanceInput[]
    createMany?: SessionProgressCreateManyExerciseInstanceInputEnvelope
    set?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    disconnect?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    delete?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    connect?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    update?: SessionProgressUpdateWithWhereUniqueWithoutExerciseInstanceInput | SessionProgressUpdateWithWhereUniqueWithoutExerciseInstanceInput[]
    updateMany?: SessionProgressUpdateManyWithWhereWithoutExerciseInstanceInput | SessionProgressUpdateManyWithWhereWithoutExerciseInstanceInput[]
    deleteMany?: SessionProgressScalarWhereInput | SessionProgressScalarWhereInput[]
  }

  export type SessionProgressUncheckedUpdateManyWithoutExerciseInstanceNestedInput = {
    create?: XOR<SessionProgressCreateWithoutExerciseInstanceInput, SessionProgressUncheckedCreateWithoutExerciseInstanceInput> | SessionProgressCreateWithoutExerciseInstanceInput[] | SessionProgressUncheckedCreateWithoutExerciseInstanceInput[]
    connectOrCreate?: SessionProgressCreateOrConnectWithoutExerciseInstanceInput | SessionProgressCreateOrConnectWithoutExerciseInstanceInput[]
    upsert?: SessionProgressUpsertWithWhereUniqueWithoutExerciseInstanceInput | SessionProgressUpsertWithWhereUniqueWithoutExerciseInstanceInput[]
    createMany?: SessionProgressCreateManyExerciseInstanceInputEnvelope
    set?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    disconnect?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    delete?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    connect?: SessionProgressWhereUniqueInput | SessionProgressWhereUniqueInput[]
    update?: SessionProgressUpdateWithWhereUniqueWithoutExerciseInstanceInput | SessionProgressUpdateWithWhereUniqueWithoutExerciseInstanceInput[]
    updateMany?: SessionProgressUpdateManyWithWhereWithoutExerciseInstanceInput | SessionProgressUpdateManyWithWhereWithoutExerciseInstanceInput[]
    deleteMany?: SessionProgressScalarWhereInput | SessionProgressScalarWhereInput[]
  }

  export type SessionProgressCreatevideosInput = {
    set: string[]
  }

  export type SessionExerciseCreateNestedOneWithoutProgressInstancesInput = {
    create?: XOR<SessionExerciseCreateWithoutProgressInstancesInput, SessionExerciseUncheckedCreateWithoutProgressInstancesInput>
    connectOrCreate?: SessionExerciseCreateOrConnectWithoutProgressInstancesInput
    connect?: SessionExerciseWhereUniqueInput
  }

  export type SessionCreateNestedOneWithoutProgressInput = {
    create?: XOR<SessionCreateWithoutProgressInput, SessionUncheckedCreateWithoutProgressInput>
    connectOrCreate?: SessionCreateOrConnectWithoutProgressInput
    connect?: SessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSessionProgressInput = {
    create?: XOR<UserCreateWithoutSessionProgressInput, UserUncheckedCreateWithoutSessionProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionProgressInput
    connect?: UserWhereUniqueInput
  }

  export type SessionProgressUpdatevideosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SessionExerciseUpdateOneWithoutProgressInstancesNestedInput = {
    create?: XOR<SessionExerciseCreateWithoutProgressInstancesInput, SessionExerciseUncheckedCreateWithoutProgressInstancesInput>
    connectOrCreate?: SessionExerciseCreateOrConnectWithoutProgressInstancesInput
    upsert?: SessionExerciseUpsertWithoutProgressInstancesInput
    disconnect?: SessionExerciseWhereInput | boolean
    delete?: SessionExerciseWhereInput | boolean
    connect?: SessionExerciseWhereUniqueInput
    update?: XOR<XOR<SessionExerciseUpdateToOneWithWhereWithoutProgressInstancesInput, SessionExerciseUpdateWithoutProgressInstancesInput>, SessionExerciseUncheckedUpdateWithoutProgressInstancesInput>
  }

  export type SessionUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<SessionCreateWithoutProgressInput, SessionUncheckedCreateWithoutProgressInput>
    connectOrCreate?: SessionCreateOrConnectWithoutProgressInput
    upsert?: SessionUpsertWithoutProgressInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutProgressInput, SessionUpdateWithoutProgressInput>, SessionUncheckedUpdateWithoutProgressInput>
  }

  export type UserUpdateOneRequiredWithoutSessionProgressNestedInput = {
    create?: XOR<UserCreateWithoutSessionProgressInput, UserUncheckedCreateWithoutSessionProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionProgressInput
    upsert?: UserUpsertWithoutSessionProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionProgressInput, UserUpdateWithoutSessionProgressInput>, UserUncheckedUpdateWithoutSessionProgressInput>
  }

  export type UserCreateNestedOneWithoutAssignedByInput = {
    create?: XOR<UserCreateWithoutAssignedByInput, UserUncheckedCreateWithoutAssignedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedByInput
    connect?: UserWhereUniqueInput
  }

  export type ProgramCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<ProgramCreateWithoutAssignmentsInput, ProgramUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutAssignmentsInput
    connect?: ProgramWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedProgramsInput = {
    create?: XOR<UserCreateWithoutAssignedProgramsInput, UserUncheckedCreateWithoutAssignedProgramsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedProgramsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAssignedByNestedInput = {
    create?: XOR<UserCreateWithoutAssignedByInput, UserUncheckedCreateWithoutAssignedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedByInput
    upsert?: UserUpsertWithoutAssignedByInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedByInput, UserUpdateWithoutAssignedByInput>, UserUncheckedUpdateWithoutAssignedByInput>
  }

  export type ProgramUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<ProgramCreateWithoutAssignmentsInput, ProgramUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutAssignmentsInput
    upsert?: ProgramUpsertWithoutAssignmentsInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutAssignmentsInput, ProgramUpdateWithoutAssignmentsInput>, ProgramUncheckedUpdateWithoutAssignmentsInput>
  }

  export type UserUpdateOneRequiredWithoutAssignedProgramsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedProgramsInput, UserUncheckedCreateWithoutAssignedProgramsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedProgramsInput
    upsert?: UserUpsertWithoutAssignedProgramsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedProgramsInput, UserUpdateWithoutAssignedProgramsInput>, UserUncheckedUpdateWithoutAssignedProgramsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type ProgramCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<ProgramCreateWithoutAuditLogsInput, ProgramUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutAuditLogsInput
    connect?: ProgramWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ProgramUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<ProgramCreateWithoutAuditLogsInput, ProgramUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutAuditLogsInput
    upsert?: ProgramUpsertWithoutAuditLogsInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutAuditLogsInput, ProgramUpdateWithoutAuditLogsInput>, ProgramUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserBadgeCreateNestedManyWithoutBadgeInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserBadgeUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserBadgeUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutBadgeInput | UserBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutBadgeInput | UserBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutBadgeInput | UserBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserBadgeUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutBadgeInput | UserBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutBadgeInput | UserBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutBadgeInput | UserBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type BadgeCreateNestedOneWithoutUserBadgesInput = {
    create?: XOR<BadgeCreateWithoutUserBadgesInput, BadgeUncheckedCreateWithoutUserBadgesInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutUserBadgesInput
    connect?: BadgeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBadgesInput = {
    create?: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBadgesInput
    connect?: UserWhereUniqueInput
  }

  export type BadgeUpdateOneRequiredWithoutUserBadgesNestedInput = {
    create?: XOR<BadgeCreateWithoutUserBadgesInput, BadgeUncheckedCreateWithoutUserBadgesInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutUserBadgesInput
    upsert?: BadgeUpsertWithoutUserBadgesInput
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutUserBadgesInput, BadgeUpdateWithoutUserBadgesInput>, BadgeUncheckedUpdateWithoutUserBadgesInput>
  }

  export type UserUpdateOneRequiredWithoutBadgesNestedInput = {
    create?: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBadgesInput
    upsert?: UserUpsertWithoutBadgesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBadgesInput, UserUpdateWithoutBadgesInput>, UserUncheckedUpdateWithoutBadgesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumExerciseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseType | EnumExerciseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExerciseTypeFilter<$PrismaModel> | $Enums.ExerciseType
  }

  export type NestedEnumScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.Scope | EnumScopeFieldRefInput<$PrismaModel>
    in?: $Enums.Scope[] | ListEnumScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Scope[] | ListEnumScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumScopeFilter<$PrismaModel> | $Enums.Scope
  }

  export type NestedEnumExerciseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseType | EnumExerciseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExerciseTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExerciseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExerciseTypeFilter<$PrismaModel>
    _max?: NestedEnumExerciseTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Scope | EnumScopeFieldRefInput<$PrismaModel>
    in?: $Enums.Scope[] | ListEnumScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Scope[] | ListEnumScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumScopeWithAggregatesFilter<$PrismaModel> | $Enums.Scope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScopeFilter<$PrismaModel>
    _max?: NestedEnumScopeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ExerciseCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope: $Enums.Scope
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionExercises?: SessionExerciseCreateNestedManyWithoutExerciseInput
    ratings?: ExerciseRatingCreateNestedManyWithoutExerciseInput
    history?: ExerciseHistoryCreateNestedManyWithoutExerciseInput
    favorites?: FavoriteExerciseCreateNestedManyWithoutExerciseInput
    logs?: ExerciseLogCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope: $Enums.Scope
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionExercises?: SessionExerciseUncheckedCreateNestedManyWithoutExerciseInput
    ratings?: ExerciseRatingUncheckedCreateNestedManyWithoutExerciseInput
    history?: ExerciseHistoryUncheckedCreateNestedManyWithoutExerciseInput
    favorites?: FavoriteExerciseUncheckedCreateNestedManyWithoutExerciseInput
    logs?: ExerciseLogUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutOwnerInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutOwnerInput, ExerciseUncheckedCreateWithoutOwnerInput>
  }

  export type ExerciseCreateManyOwnerInputEnvelope = {
    data: ExerciseCreateManyOwnerInput | ExerciseCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type GroupMemberCreateWithoutUserInput = {
    id?: string
    roleInGroup?: string
    joinedAt?: Date | string
    group: GroupCreateNestedOneWithoutMembersInput
  }

  export type GroupMemberUncheckedCreateWithoutUserInput = {
    id?: string
    groupId: string
    roleInGroup?: string
    joinedAt?: Date | string
  }

  export type GroupMemberCreateOrConnectWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    create: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput>
  }

  export type GroupMemberCreateManyUserInputEnvelope = {
    data: GroupMemberCreateManyUserInput | GroupMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GroupCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    invitations?: InvitationCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutOwnerInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutOwnerInput, GroupUncheckedCreateWithoutOwnerInput>
  }

  export type GroupCreateManyOwnerInputEnvelope = {
    data: GroupCreateManyOwnerInput | GroupCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type InvitationCreateWithoutFromCoachInput = {
    id?: string
    status: $Enums.InvitationStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
    group: GroupCreateNestedOneWithoutInvitationsInput
    toUser: UserCreateNestedOneWithoutReceivedInvitationsInput
  }

  export type InvitationUncheckedCreateWithoutFromCoachInput = {
    id?: string
    groupId: string
    toUserId: string
    status: $Enums.InvitationStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type InvitationCreateOrConnectWithoutFromCoachInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutFromCoachInput, InvitationUncheckedCreateWithoutFromCoachInput>
  }

  export type InvitationCreateManyFromCoachInputEnvelope = {
    data: InvitationCreateManyFromCoachInput | InvitationCreateManyFromCoachInput[]
    skipDuplicates?: boolean
  }

  export type InvitationCreateWithoutToUserInput = {
    id?: string
    status: $Enums.InvitationStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
    fromCoach: UserCreateNestedOneWithoutSentInvitationsInput
    group: GroupCreateNestedOneWithoutInvitationsInput
  }

  export type InvitationUncheckedCreateWithoutToUserInput = {
    id?: string
    groupId: string
    fromCoachId: string
    status: $Enums.InvitationStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type InvitationCreateOrConnectWithoutToUserInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutToUserInput, InvitationUncheckedCreateWithoutToUserInput>
  }

  export type InvitationCreateManyToUserInputEnvelope = {
    data: InvitationCreateManyToUserInput | InvitationCreateManyToUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProgramAssignmentCreateWithoutAssignerInput = {
    id?: string
    assignedAt?: Date | string
    program: ProgramCreateNestedOneWithoutAssignmentsInput
    student: UserCreateNestedOneWithoutAssignedProgramsInput
  }

  export type ProgramAssignmentUncheckedCreateWithoutAssignerInput = {
    id?: string
    programId: string
    studentId: string
    assignedAt?: Date | string
  }

  export type ProgramAssignmentCreateOrConnectWithoutAssignerInput = {
    where: ProgramAssignmentWhereUniqueInput
    create: XOR<ProgramAssignmentCreateWithoutAssignerInput, ProgramAssignmentUncheckedCreateWithoutAssignerInput>
  }

  export type ProgramAssignmentCreateManyAssignerInputEnvelope = {
    data: ProgramAssignmentCreateManyAssignerInput | ProgramAssignmentCreateManyAssignerInput[]
    skipDuplicates?: boolean
  }

  export type ProgramAssignmentCreateWithoutStudentInput = {
    id?: string
    assignedAt?: Date | string
    assigner?: UserCreateNestedOneWithoutAssignedByInput
    program: ProgramCreateNestedOneWithoutAssignmentsInput
  }

  export type ProgramAssignmentUncheckedCreateWithoutStudentInput = {
    id?: string
    programId: string
    assignedBy?: string | null
    assignedAt?: Date | string
  }

  export type ProgramAssignmentCreateOrConnectWithoutStudentInput = {
    where: ProgramAssignmentWhereUniqueInput
    create: XOR<ProgramAssignmentCreateWithoutStudentInput, ProgramAssignmentUncheckedCreateWithoutStudentInput>
  }

  export type ProgramAssignmentCreateManyStudentInputEnvelope = {
    data: ProgramAssignmentCreateManyStudentInput | ProgramAssignmentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type ProgramAuditCreateWithoutUserInput = {
    id?: string
    changeType: string
    diff?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    program: ProgramCreateNestedOneWithoutAuditLogsInput
  }

  export type ProgramAuditUncheckedCreateWithoutUserInput = {
    id?: string
    programId: string
    changeType: string
    diff?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ProgramAuditCreateOrConnectWithoutUserInput = {
    where: ProgramAuditWhereUniqueInput
    create: XOR<ProgramAuditCreateWithoutUserInput, ProgramAuditUncheckedCreateWithoutUserInput>
  }

  export type ProgramAuditCreateManyUserInputEnvelope = {
    data: ProgramAuditCreateManyUserInput | ProgramAuditCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProgramCreateWithoutCoachInput = {
    id?: string
    title: string
    description?: string | null
    ownerId?: string | null
    isDraft?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: ProgramAssignmentCreateNestedManyWithoutProgramInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutProgramInput
    blocks?: ProgramBlockCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutCoachInput = {
    id?: string
    title: string
    description?: string | null
    ownerId?: string | null
    isDraft?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: ProgramAssignmentUncheckedCreateNestedManyWithoutProgramInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutProgramInput
    blocks?: ProgramBlockUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutCoachInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutCoachInput, ProgramUncheckedCreateWithoutCoachInput>
  }

  export type ProgramCreateManyCoachInputEnvelope = {
    data: ProgramCreateManyCoachInput | ProgramCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type SessionProgressCreateWithoutStudentInput = {
    id?: string
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    videos?: SessionProgressCreatevideosInput | string[]
    savedAt?: Date | string
    exerciseInstance?: SessionExerciseCreateNestedOneWithoutProgressInstancesInput
    session: SessionCreateNestedOneWithoutProgressInput
  }

  export type SessionProgressUncheckedCreateWithoutStudentInput = {
    id?: string
    sessionId: string
    exerciseInstanceId?: string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    videos?: SessionProgressCreatevideosInput | string[]
    savedAt?: Date | string
  }

  export type SessionProgressCreateOrConnectWithoutStudentInput = {
    where: SessionProgressWhereUniqueInput
    create: XOR<SessionProgressCreateWithoutStudentInput, SessionProgressUncheckedCreateWithoutStudentInput>
  }

  export type SessionProgressCreateManyStudentInputEnvelope = {
    data: SessionProgressCreateManyStudentInput | SessionProgressCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type UserBadgeCreateWithoutUserInput = {
    id?: string
    awardedAt?: Date | string
    badge: BadgeCreateNestedOneWithoutUserBadgesInput
  }

  export type UserBadgeUncheckedCreateWithoutUserInput = {
    id?: string
    badgeId: string
    awardedAt?: Date | string
  }

  export type UserBadgeCreateOrConnectWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    create: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput>
  }

  export type UserBadgeCreateManyUserInputEnvelope = {
    data: UserBadgeCreateManyUserInput | UserBadgeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseRatingCreateWithoutUserInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exercise: ExerciseCreateNestedOneWithoutRatingsInput
  }

  export type ExerciseRatingUncheckedCreateWithoutUserInput = {
    id?: string
    exerciseId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseRatingCreateOrConnectWithoutUserInput = {
    where: ExerciseRatingWhereUniqueInput
    create: XOR<ExerciseRatingCreateWithoutUserInput, ExerciseRatingUncheckedCreateWithoutUserInput>
  }

  export type ExerciseRatingCreateManyUserInputEnvelope = {
    data: ExerciseRatingCreateManyUserInput | ExerciseRatingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseHistoryCreateWithoutUserInput = {
    id?: string
    viewedAt?: Date | string
    exercise: ExerciseCreateNestedOneWithoutHistoryInput
  }

  export type ExerciseHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    exerciseId: string
    viewedAt?: Date | string
  }

  export type ExerciseHistoryCreateOrConnectWithoutUserInput = {
    where: ExerciseHistoryWhereUniqueInput
    create: XOR<ExerciseHistoryCreateWithoutUserInput, ExerciseHistoryUncheckedCreateWithoutUserInput>
  }

  export type ExerciseHistoryCreateManyUserInputEnvelope = {
    data: ExerciseHistoryCreateManyUserInput | ExerciseHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteExerciseCreateWithoutUserInput = {
    id?: string
    addedAt?: Date | string
    exercise: ExerciseCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteExerciseUncheckedCreateWithoutUserInput = {
    id?: string
    exerciseId: string
    addedAt?: Date | string
  }

  export type FavoriteExerciseCreateOrConnectWithoutUserInput = {
    where: FavoriteExerciseWhereUniqueInput
    create: XOR<FavoriteExerciseCreateWithoutUserInput, FavoriteExerciseUncheckedCreateWithoutUserInput>
  }

  export type FavoriteExerciseCreateManyUserInputEnvelope = {
    data: FavoriteExerciseCreateManyUserInput | FavoriteExerciseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkoutSessionCreateWithoutUserInput = {
    id?: string
    title?: string | null
    startedAt?: Date | string
    startTime?: Date | string | null
    endedAt?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    notes?: string | null
    restPeriodSeconds?: number | null
    formGuidanceEnabled?: boolean | null
    exercisesCompleted?: number | null
    totalExercises?: number | null
    logs?: ExerciseLogCreateNestedManyWithoutSessionInput
  }

  export type WorkoutSessionUncheckedCreateWithoutUserInput = {
    id?: string
    title?: string | null
    startedAt?: Date | string
    startTime?: Date | string | null
    endedAt?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    notes?: string | null
    restPeriodSeconds?: number | null
    formGuidanceEnabled?: boolean | null
    exercisesCompleted?: number | null
    totalExercises?: number | null
    logs?: ExerciseLogUncheckedCreateNestedManyWithoutSessionInput
  }

  export type WorkoutSessionCreateOrConnectWithoutUserInput = {
    where: WorkoutSessionWhereUniqueInput
    create: XOR<WorkoutSessionCreateWithoutUserInput, WorkoutSessionUncheckedCreateWithoutUserInput>
  }

  export type WorkoutSessionCreateManyUserInputEnvelope = {
    data: WorkoutSessionCreateManyUserInput | WorkoutSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutStudentsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressCreateNestedManyWithoutStudentInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutUserInput
    coach?: UserCreateNestedOneWithoutStudentsInput
  }

  export type UserUncheckedCreateWithoutStudentsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    coachId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentUncheckedCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentUncheckedCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressUncheckedCreateNestedManyWithoutStudentInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingUncheckedCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryUncheckedCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseUncheckedCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentsInput, UserUncheckedCreateWithoutStudentsInput>
  }

  export type UserCreateWithoutCoachInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressCreateNestedManyWithoutStudentInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutUserInput
    students?: UserCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutCoachInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentUncheckedCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentUncheckedCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressUncheckedCreateNestedManyWithoutStudentInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingUncheckedCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryUncheckedCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseUncheckedCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutUserInput
    students?: UserUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutCoachInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoachInput, UserUncheckedCreateWithoutCoachInput>
  }

  export type UserCreateManyCoachInputEnvelope = {
    data: UserCreateManyCoachInput | UserCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ExerciseWhereUniqueInput
    update: XOR<ExerciseUpdateWithoutOwnerInput, ExerciseUncheckedUpdateWithoutOwnerInput>
    create: XOR<ExerciseCreateWithoutOwnerInput, ExerciseUncheckedCreateWithoutOwnerInput>
  }

  export type ExerciseUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ExerciseWhereUniqueInput
    data: XOR<ExerciseUpdateWithoutOwnerInput, ExerciseUncheckedUpdateWithoutOwnerInput>
  }

  export type ExerciseUpdateManyWithWhereWithoutOwnerInput = {
    where: ExerciseScalarWhereInput
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ExerciseScalarWhereInput = {
    AND?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
    OR?: ExerciseScalarWhereInput[]
    NOT?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
    id?: StringFilter<"Exercise"> | string
    name?: StringFilter<"Exercise"> | string
    description?: StringNullableFilter<"Exercise"> | string | null
    type?: EnumExerciseTypeFilter<"Exercise"> | $Enums.ExerciseType
    meta?: JsonNullableFilter<"Exercise">
    scope?: EnumScopeFilter<"Exercise"> | $Enums.Scope
    ownerId?: StringNullableFilter<"Exercise"> | string | null
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeFilter<"Exercise"> | Date | string
  }

  export type GroupMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    update: XOR<GroupMemberUpdateWithoutUserInput, GroupMemberUncheckedUpdateWithoutUserInput>
    create: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput>
  }

  export type GroupMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    data: XOR<GroupMemberUpdateWithoutUserInput, GroupMemberUncheckedUpdateWithoutUserInput>
  }

  export type GroupMemberUpdateManyWithWhereWithoutUserInput = {
    where: GroupMemberScalarWhereInput
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type GroupMemberScalarWhereInput = {
    AND?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
    OR?: GroupMemberScalarWhereInput[]
    NOT?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
    id?: StringFilter<"GroupMember"> | string
    groupId?: StringFilter<"GroupMember"> | string
    userId?: StringFilter<"GroupMember"> | string
    roleInGroup?: StringFilter<"GroupMember"> | string
    joinedAt?: DateTimeFilter<"GroupMember"> | Date | string
  }

  export type GroupUpsertWithWhereUniqueWithoutOwnerInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutOwnerInput, GroupUncheckedUpdateWithoutOwnerInput>
    create: XOR<GroupCreateWithoutOwnerInput, GroupUncheckedCreateWithoutOwnerInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutOwnerInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutOwnerInput, GroupUncheckedUpdateWithoutOwnerInput>
  }

  export type GroupUpdateManyWithWhereWithoutOwnerInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutOwnerInput>
  }

  export type GroupScalarWhereInput = {
    AND?: GroupScalarWhereInput | GroupScalarWhereInput[]
    OR?: GroupScalarWhereInput[]
    NOT?: GroupScalarWhereInput | GroupScalarWhereInput[]
    id?: StringFilter<"Group"> | string
    ownerId?: StringFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
  }

  export type InvitationUpsertWithWhereUniqueWithoutFromCoachInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutFromCoachInput, InvitationUncheckedUpdateWithoutFromCoachInput>
    create: XOR<InvitationCreateWithoutFromCoachInput, InvitationUncheckedCreateWithoutFromCoachInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutFromCoachInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutFromCoachInput, InvitationUncheckedUpdateWithoutFromCoachInput>
  }

  export type InvitationUpdateManyWithWhereWithoutFromCoachInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutFromCoachInput>
  }

  export type InvitationScalarWhereInput = {
    AND?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    OR?: InvitationScalarWhereInput[]
    NOT?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    id?: StringFilter<"Invitation"> | string
    groupId?: StringFilter<"Invitation"> | string
    fromCoachId?: StringFilter<"Invitation"> | string
    toUserId?: StringFilter<"Invitation"> | string
    status?: EnumInvitationStatusFilter<"Invitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeFilter<"Invitation"> | Date | string
    respondedAt?: DateTimeNullableFilter<"Invitation"> | Date | string | null
  }

  export type InvitationUpsertWithWhereUniqueWithoutToUserInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutToUserInput, InvitationUncheckedUpdateWithoutToUserInput>
    create: XOR<InvitationCreateWithoutToUserInput, InvitationUncheckedCreateWithoutToUserInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutToUserInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutToUserInput, InvitationUncheckedUpdateWithoutToUserInput>
  }

  export type InvitationUpdateManyWithWhereWithoutToUserInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutToUserInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    payload?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type ProgramAssignmentUpsertWithWhereUniqueWithoutAssignerInput = {
    where: ProgramAssignmentWhereUniqueInput
    update: XOR<ProgramAssignmentUpdateWithoutAssignerInput, ProgramAssignmentUncheckedUpdateWithoutAssignerInput>
    create: XOR<ProgramAssignmentCreateWithoutAssignerInput, ProgramAssignmentUncheckedCreateWithoutAssignerInput>
  }

  export type ProgramAssignmentUpdateWithWhereUniqueWithoutAssignerInput = {
    where: ProgramAssignmentWhereUniqueInput
    data: XOR<ProgramAssignmentUpdateWithoutAssignerInput, ProgramAssignmentUncheckedUpdateWithoutAssignerInput>
  }

  export type ProgramAssignmentUpdateManyWithWhereWithoutAssignerInput = {
    where: ProgramAssignmentScalarWhereInput
    data: XOR<ProgramAssignmentUpdateManyMutationInput, ProgramAssignmentUncheckedUpdateManyWithoutAssignerInput>
  }

  export type ProgramAssignmentScalarWhereInput = {
    AND?: ProgramAssignmentScalarWhereInput | ProgramAssignmentScalarWhereInput[]
    OR?: ProgramAssignmentScalarWhereInput[]
    NOT?: ProgramAssignmentScalarWhereInput | ProgramAssignmentScalarWhereInput[]
    id?: StringFilter<"ProgramAssignment"> | string
    programId?: StringFilter<"ProgramAssignment"> | string
    studentId?: StringFilter<"ProgramAssignment"> | string
    assignedBy?: StringNullableFilter<"ProgramAssignment"> | string | null
    assignedAt?: DateTimeFilter<"ProgramAssignment"> | Date | string
  }

  export type ProgramAssignmentUpsertWithWhereUniqueWithoutStudentInput = {
    where: ProgramAssignmentWhereUniqueInput
    update: XOR<ProgramAssignmentUpdateWithoutStudentInput, ProgramAssignmentUncheckedUpdateWithoutStudentInput>
    create: XOR<ProgramAssignmentCreateWithoutStudentInput, ProgramAssignmentUncheckedCreateWithoutStudentInput>
  }

  export type ProgramAssignmentUpdateWithWhereUniqueWithoutStudentInput = {
    where: ProgramAssignmentWhereUniqueInput
    data: XOR<ProgramAssignmentUpdateWithoutStudentInput, ProgramAssignmentUncheckedUpdateWithoutStudentInput>
  }

  export type ProgramAssignmentUpdateManyWithWhereWithoutStudentInput = {
    where: ProgramAssignmentScalarWhereInput
    data: XOR<ProgramAssignmentUpdateManyMutationInput, ProgramAssignmentUncheckedUpdateManyWithoutStudentInput>
  }

  export type ProgramAuditUpsertWithWhereUniqueWithoutUserInput = {
    where: ProgramAuditWhereUniqueInput
    update: XOR<ProgramAuditUpdateWithoutUserInput, ProgramAuditUncheckedUpdateWithoutUserInput>
    create: XOR<ProgramAuditCreateWithoutUserInput, ProgramAuditUncheckedCreateWithoutUserInput>
  }

  export type ProgramAuditUpdateWithWhereUniqueWithoutUserInput = {
    where: ProgramAuditWhereUniqueInput
    data: XOR<ProgramAuditUpdateWithoutUserInput, ProgramAuditUncheckedUpdateWithoutUserInput>
  }

  export type ProgramAuditUpdateManyWithWhereWithoutUserInput = {
    where: ProgramAuditScalarWhereInput
    data: XOR<ProgramAuditUpdateManyMutationInput, ProgramAuditUncheckedUpdateManyWithoutUserInput>
  }

  export type ProgramAuditScalarWhereInput = {
    AND?: ProgramAuditScalarWhereInput | ProgramAuditScalarWhereInput[]
    OR?: ProgramAuditScalarWhereInput[]
    NOT?: ProgramAuditScalarWhereInput | ProgramAuditScalarWhereInput[]
    id?: StringFilter<"ProgramAudit"> | string
    programId?: StringFilter<"ProgramAudit"> | string
    changedBy?: StringFilter<"ProgramAudit"> | string
    changeType?: StringFilter<"ProgramAudit"> | string
    diff?: JsonNullableFilter<"ProgramAudit">
    createdAt?: DateTimeFilter<"ProgramAudit"> | Date | string
  }

  export type ProgramUpsertWithWhereUniqueWithoutCoachInput = {
    where: ProgramWhereUniqueInput
    update: XOR<ProgramUpdateWithoutCoachInput, ProgramUncheckedUpdateWithoutCoachInput>
    create: XOR<ProgramCreateWithoutCoachInput, ProgramUncheckedCreateWithoutCoachInput>
  }

  export type ProgramUpdateWithWhereUniqueWithoutCoachInput = {
    where: ProgramWhereUniqueInput
    data: XOR<ProgramUpdateWithoutCoachInput, ProgramUncheckedUpdateWithoutCoachInput>
  }

  export type ProgramUpdateManyWithWhereWithoutCoachInput = {
    where: ProgramScalarWhereInput
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyWithoutCoachInput>
  }

  export type ProgramScalarWhereInput = {
    AND?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
    OR?: ProgramScalarWhereInput[]
    NOT?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
    id?: StringFilter<"Program"> | string
    title?: StringFilter<"Program"> | string
    description?: StringNullableFilter<"Program"> | string | null
    coachId?: StringFilter<"Program"> | string
    ownerId?: StringNullableFilter<"Program"> | string | null
    isDraft?: BoolFilter<"Program"> | boolean
    data?: JsonNullableFilter<"Program">
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
  }

  export type SessionProgressUpsertWithWhereUniqueWithoutStudentInput = {
    where: SessionProgressWhereUniqueInput
    update: XOR<SessionProgressUpdateWithoutStudentInput, SessionProgressUncheckedUpdateWithoutStudentInput>
    create: XOR<SessionProgressCreateWithoutStudentInput, SessionProgressUncheckedCreateWithoutStudentInput>
  }

  export type SessionProgressUpdateWithWhereUniqueWithoutStudentInput = {
    where: SessionProgressWhereUniqueInput
    data: XOR<SessionProgressUpdateWithoutStudentInput, SessionProgressUncheckedUpdateWithoutStudentInput>
  }

  export type SessionProgressUpdateManyWithWhereWithoutStudentInput = {
    where: SessionProgressScalarWhereInput
    data: XOR<SessionProgressUpdateManyMutationInput, SessionProgressUncheckedUpdateManyWithoutStudentInput>
  }

  export type SessionProgressScalarWhereInput = {
    AND?: SessionProgressScalarWhereInput | SessionProgressScalarWhereInput[]
    OR?: SessionProgressScalarWhereInput[]
    NOT?: SessionProgressScalarWhereInput | SessionProgressScalarWhereInput[]
    id?: StringFilter<"SessionProgress"> | string
    sessionId?: StringFilter<"SessionProgress"> | string
    studentId?: StringFilter<"SessionProgress"> | string
    exerciseInstanceId?: StringNullableFilter<"SessionProgress"> | string | null
    progress?: JsonNullableFilter<"SessionProgress">
    notes?: StringNullableFilter<"SessionProgress"> | string | null
    videos?: StringNullableListFilter<"SessionProgress">
    savedAt?: DateTimeFilter<"SessionProgress"> | Date | string
  }

  export type UserBadgeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    update: XOR<UserBadgeUpdateWithoutUserInput, UserBadgeUncheckedUpdateWithoutUserInput>
    create: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput>
  }

  export type UserBadgeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    data: XOR<UserBadgeUpdateWithoutUserInput, UserBadgeUncheckedUpdateWithoutUserInput>
  }

  export type UserBadgeUpdateManyWithWhereWithoutUserInput = {
    where: UserBadgeScalarWhereInput
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyWithoutUserInput>
  }

  export type UserBadgeScalarWhereInput = {
    AND?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
    OR?: UserBadgeScalarWhereInput[]
    NOT?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
    id?: StringFilter<"UserBadge"> | string
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: StringFilter<"UserBadge"> | string
    awardedAt?: DateTimeFilter<"UserBadge"> | Date | string
  }

  export type ExerciseRatingUpsertWithWhereUniqueWithoutUserInput = {
    where: ExerciseRatingWhereUniqueInput
    update: XOR<ExerciseRatingUpdateWithoutUserInput, ExerciseRatingUncheckedUpdateWithoutUserInput>
    create: XOR<ExerciseRatingCreateWithoutUserInput, ExerciseRatingUncheckedCreateWithoutUserInput>
  }

  export type ExerciseRatingUpdateWithWhereUniqueWithoutUserInput = {
    where: ExerciseRatingWhereUniqueInput
    data: XOR<ExerciseRatingUpdateWithoutUserInput, ExerciseRatingUncheckedUpdateWithoutUserInput>
  }

  export type ExerciseRatingUpdateManyWithWhereWithoutUserInput = {
    where: ExerciseRatingScalarWhereInput
    data: XOR<ExerciseRatingUpdateManyMutationInput, ExerciseRatingUncheckedUpdateManyWithoutUserInput>
  }

  export type ExerciseRatingScalarWhereInput = {
    AND?: ExerciseRatingScalarWhereInput | ExerciseRatingScalarWhereInput[]
    OR?: ExerciseRatingScalarWhereInput[]
    NOT?: ExerciseRatingScalarWhereInput | ExerciseRatingScalarWhereInput[]
    id?: StringFilter<"ExerciseRating"> | string
    exerciseId?: StringFilter<"ExerciseRating"> | string
    userId?: StringFilter<"ExerciseRating"> | string
    rating?: IntFilter<"ExerciseRating"> | number
    comment?: StringNullableFilter<"ExerciseRating"> | string | null
    createdAt?: DateTimeFilter<"ExerciseRating"> | Date | string
    updatedAt?: DateTimeFilter<"ExerciseRating"> | Date | string
  }

  export type ExerciseHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: ExerciseHistoryWhereUniqueInput
    update: XOR<ExerciseHistoryUpdateWithoutUserInput, ExerciseHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<ExerciseHistoryCreateWithoutUserInput, ExerciseHistoryUncheckedCreateWithoutUserInput>
  }

  export type ExerciseHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: ExerciseHistoryWhereUniqueInput
    data: XOR<ExerciseHistoryUpdateWithoutUserInput, ExerciseHistoryUncheckedUpdateWithoutUserInput>
  }

  export type ExerciseHistoryUpdateManyWithWhereWithoutUserInput = {
    where: ExerciseHistoryScalarWhereInput
    data: XOR<ExerciseHistoryUpdateManyMutationInput, ExerciseHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type ExerciseHistoryScalarWhereInput = {
    AND?: ExerciseHistoryScalarWhereInput | ExerciseHistoryScalarWhereInput[]
    OR?: ExerciseHistoryScalarWhereInput[]
    NOT?: ExerciseHistoryScalarWhereInput | ExerciseHistoryScalarWhereInput[]
    id?: StringFilter<"ExerciseHistory"> | string
    userId?: StringFilter<"ExerciseHistory"> | string
    exerciseId?: StringFilter<"ExerciseHistory"> | string
    viewedAt?: DateTimeFilter<"ExerciseHistory"> | Date | string
  }

  export type FavoriteExerciseUpsertWithWhereUniqueWithoutUserInput = {
    where: FavoriteExerciseWhereUniqueInput
    update: XOR<FavoriteExerciseUpdateWithoutUserInput, FavoriteExerciseUncheckedUpdateWithoutUserInput>
    create: XOR<FavoriteExerciseCreateWithoutUserInput, FavoriteExerciseUncheckedCreateWithoutUserInput>
  }

  export type FavoriteExerciseUpdateWithWhereUniqueWithoutUserInput = {
    where: FavoriteExerciseWhereUniqueInput
    data: XOR<FavoriteExerciseUpdateWithoutUserInput, FavoriteExerciseUncheckedUpdateWithoutUserInput>
  }

  export type FavoriteExerciseUpdateManyWithWhereWithoutUserInput = {
    where: FavoriteExerciseScalarWhereInput
    data: XOR<FavoriteExerciseUpdateManyMutationInput, FavoriteExerciseUncheckedUpdateManyWithoutUserInput>
  }

  export type FavoriteExerciseScalarWhereInput = {
    AND?: FavoriteExerciseScalarWhereInput | FavoriteExerciseScalarWhereInput[]
    OR?: FavoriteExerciseScalarWhereInput[]
    NOT?: FavoriteExerciseScalarWhereInput | FavoriteExerciseScalarWhereInput[]
    id?: StringFilter<"FavoriteExercise"> | string
    userId?: StringFilter<"FavoriteExercise"> | string
    exerciseId?: StringFilter<"FavoriteExercise"> | string
    addedAt?: DateTimeFilter<"FavoriteExercise"> | Date | string
  }

  export type WorkoutSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkoutSessionWhereUniqueInput
    update: XOR<WorkoutSessionUpdateWithoutUserInput, WorkoutSessionUncheckedUpdateWithoutUserInput>
    create: XOR<WorkoutSessionCreateWithoutUserInput, WorkoutSessionUncheckedCreateWithoutUserInput>
  }

  export type WorkoutSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkoutSessionWhereUniqueInput
    data: XOR<WorkoutSessionUpdateWithoutUserInput, WorkoutSessionUncheckedUpdateWithoutUserInput>
  }

  export type WorkoutSessionUpdateManyWithWhereWithoutUserInput = {
    where: WorkoutSessionScalarWhereInput
    data: XOR<WorkoutSessionUpdateManyMutationInput, WorkoutSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkoutSessionScalarWhereInput = {
    AND?: WorkoutSessionScalarWhereInput | WorkoutSessionScalarWhereInput[]
    OR?: WorkoutSessionScalarWhereInput[]
    NOT?: WorkoutSessionScalarWhereInput | WorkoutSessionScalarWhereInput[]
    id?: StringFilter<"WorkoutSession"> | string
    userId?: StringFilter<"WorkoutSession"> | string
    title?: StringNullableFilter<"WorkoutSession"> | string | null
    startedAt?: DateTimeFilter<"WorkoutSession"> | Date | string
    startTime?: DateTimeNullableFilter<"WorkoutSession"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"WorkoutSession"> | Date | string | null
    endTime?: DateTimeNullableFilter<"WorkoutSession"> | Date | string | null
    duration?: IntNullableFilter<"WorkoutSession"> | number | null
    notes?: StringNullableFilter<"WorkoutSession"> | string | null
    restPeriodSeconds?: IntNullableFilter<"WorkoutSession"> | number | null
    formGuidanceEnabled?: BoolNullableFilter<"WorkoutSession"> | boolean | null
    exercisesCompleted?: IntNullableFilter<"WorkoutSession"> | number | null
    totalExercises?: IntNullableFilter<"WorkoutSession"> | number | null
  }

  export type UserUpsertWithoutStudentsInput = {
    update: XOR<UserUpdateWithoutStudentsInput, UserUncheckedUpdateWithoutStudentsInput>
    create: XOR<UserCreateWithoutStudentsInput, UserUncheckedCreateWithoutStudentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentsInput, UserUncheckedUpdateWithoutStudentsInput>
  }

  export type UserUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutUserNestedInput
    coach?: UserUpdateOneWithoutStudentsNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUncheckedUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUncheckedUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUncheckedUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUncheckedUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUncheckedUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUncheckedUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutCoachInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCoachInput, UserUncheckedUpdateWithoutCoachInput>
    create: XOR<UserCreateWithoutCoachInput, UserUncheckedCreateWithoutCoachInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCoachInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCoachInput, UserUncheckedUpdateWithoutCoachInput>
  }

  export type UserUpdateManyWithWhereWithoutCoachInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCoachInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    pseudo?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    profileUrl?: StringNullableFilter<"User"> | string | null
    coachId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type GroupMemberCreateWithoutGroupInput = {
    id?: string
    roleInGroup?: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutGroupMembershipsInput
  }

  export type GroupMemberUncheckedCreateWithoutGroupInput = {
    id?: string
    userId: string
    roleInGroup?: string
    joinedAt?: Date | string
  }

  export type GroupMemberCreateOrConnectWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    create: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type GroupMemberCreateManyGroupInputEnvelope = {
    data: GroupMemberCreateManyGroupInput | GroupMemberCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutOwnedGroupsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentInvitations?: InvitationCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressCreateNestedManyWithoutStudentInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutUserInput
    coach?: UserCreateNestedOneWithoutStudentsInput
    students?: UserCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutOwnedGroupsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    coachId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentUncheckedCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentUncheckedCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressUncheckedCreateNestedManyWithoutStudentInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingUncheckedCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryUncheckedCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseUncheckedCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutUserInput
    students?: UserUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutOwnedGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedGroupsInput, UserUncheckedCreateWithoutOwnedGroupsInput>
  }

  export type InvitationCreateWithoutGroupInput = {
    id?: string
    status: $Enums.InvitationStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
    fromCoach: UserCreateNestedOneWithoutSentInvitationsInput
    toUser: UserCreateNestedOneWithoutReceivedInvitationsInput
  }

  export type InvitationUncheckedCreateWithoutGroupInput = {
    id?: string
    fromCoachId: string
    toUserId: string
    status: $Enums.InvitationStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type InvitationCreateOrConnectWithoutGroupInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutGroupInput, InvitationUncheckedCreateWithoutGroupInput>
  }

  export type InvitationCreateManyGroupInputEnvelope = {
    data: InvitationCreateManyGroupInput | InvitationCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type GroupMemberUpsertWithWhereUniqueWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    update: XOR<GroupMemberUpdateWithoutGroupInput, GroupMemberUncheckedUpdateWithoutGroupInput>
    create: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type GroupMemberUpdateWithWhereUniqueWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    data: XOR<GroupMemberUpdateWithoutGroupInput, GroupMemberUncheckedUpdateWithoutGroupInput>
  }

  export type GroupMemberUpdateManyWithWhereWithoutGroupInput = {
    where: GroupMemberScalarWhereInput
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyWithoutGroupInput>
  }

  export type UserUpsertWithoutOwnedGroupsInput = {
    update: XOR<UserUpdateWithoutOwnedGroupsInput, UserUncheckedUpdateWithoutOwnedGroupsInput>
    create: XOR<UserCreateWithoutOwnedGroupsInput, UserUncheckedCreateWithoutOwnedGroupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedGroupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedGroupsInput, UserUncheckedUpdateWithoutOwnedGroupsInput>
  }

  export type UserUpdateWithoutOwnedGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: InvitationUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutUserNestedInput
    coach?: UserUpdateOneWithoutStudentsNestedInput
    students?: UserUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUncheckedUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUncheckedUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUncheckedUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUncheckedUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUncheckedUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUncheckedUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutUserNestedInput
    students?: UserUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type InvitationUpsertWithWhereUniqueWithoutGroupInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutGroupInput, InvitationUncheckedUpdateWithoutGroupInput>
    create: XOR<InvitationCreateWithoutGroupInput, InvitationUncheckedCreateWithoutGroupInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutGroupInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutGroupInput, InvitationUncheckedUpdateWithoutGroupInput>
  }

  export type InvitationUpdateManyWithWhereWithoutGroupInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutGroupInput>
  }

  export type GroupCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedGroupsInput
    invitations?: InvitationCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutMembersInput = {
    id?: string
    ownerId: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitations?: InvitationUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutMembersInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutGroupMembershipsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressCreateNestedManyWithoutStudentInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutUserInput
    coach?: UserCreateNestedOneWithoutStudentsInput
    students?: UserCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutGroupMembershipsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    coachId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentUncheckedCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentUncheckedCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressUncheckedCreateNestedManyWithoutStudentInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingUncheckedCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryUncheckedCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseUncheckedCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutUserInput
    students?: UserUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutGroupMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
  }

  export type GroupUpsertWithoutMembersInput = {
    update: XOR<GroupUpdateWithoutMembersInput, GroupUncheckedUpdateWithoutMembersInput>
    create: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutMembersInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutMembersInput, GroupUncheckedUpdateWithoutMembersInput>
  }

  export type GroupUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedGroupsNestedInput
    invitations?: InvitationUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitations?: InvitationUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UserUpsertWithoutGroupMembershipsInput = {
    update: XOR<UserUpdateWithoutGroupMembershipsInput, UserUncheckedUpdateWithoutGroupMembershipsInput>
    create: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGroupMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGroupMembershipsInput, UserUncheckedUpdateWithoutGroupMembershipsInput>
  }

  export type UserUpdateWithoutGroupMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutUserNestedInput
    coach?: UserUpdateOneWithoutStudentsNestedInput
    students?: UserUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUncheckedUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUncheckedUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUncheckedUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUncheckedUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUncheckedUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUncheckedUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutUserNestedInput
    students?: UserUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type UserCreateWithoutSentInvitationsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    receivedInvitations?: InvitationCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressCreateNestedManyWithoutStudentInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutUserInput
    coach?: UserCreateNestedOneWithoutStudentsInput
    students?: UserCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutSentInvitationsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    coachId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    receivedInvitations?: InvitationUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentUncheckedCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentUncheckedCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressUncheckedCreateNestedManyWithoutStudentInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingUncheckedCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryUncheckedCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseUncheckedCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutUserInput
    students?: UserUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutSentInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
  }

  export type GroupCreateWithoutInvitationsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    owner: UserCreateNestedOneWithoutOwnedGroupsInput
  }

  export type GroupUncheckedCreateWithoutInvitationsInput = {
    id?: string
    ownerId: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutInvitationsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutInvitationsInput, GroupUncheckedCreateWithoutInvitationsInput>
  }

  export type UserCreateWithoutReceivedInvitationsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationCreateNestedManyWithoutFromCoachInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressCreateNestedManyWithoutStudentInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutUserInput
    coach?: UserCreateNestedOneWithoutStudentsInput
    students?: UserCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutReceivedInvitationsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    coachId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutFromCoachInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentUncheckedCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentUncheckedCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressUncheckedCreateNestedManyWithoutStudentInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingUncheckedCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryUncheckedCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseUncheckedCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutUserInput
    students?: UserUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutReceivedInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedInvitationsInput, UserUncheckedCreateWithoutReceivedInvitationsInput>
  }

  export type UserUpsertWithoutSentInvitationsInput = {
    update: XOR<UserUpdateWithoutSentInvitationsInput, UserUncheckedUpdateWithoutSentInvitationsInput>
    create: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentInvitationsInput, UserUncheckedUpdateWithoutSentInvitationsInput>
  }

  export type UserUpdateWithoutSentInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    receivedInvitations?: InvitationUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutUserNestedInput
    coach?: UserUpdateOneWithoutStudentsNestedInput
    students?: UserUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutSentInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    receivedInvitations?: InvitationUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUncheckedUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUncheckedUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUncheckedUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUncheckedUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUncheckedUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUncheckedUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutUserNestedInput
    students?: UserUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type GroupUpsertWithoutInvitationsInput = {
    update: XOR<GroupUpdateWithoutInvitationsInput, GroupUncheckedUpdateWithoutInvitationsInput>
    create: XOR<GroupCreateWithoutInvitationsInput, GroupUncheckedCreateWithoutInvitationsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutInvitationsInput, GroupUncheckedUpdateWithoutInvitationsInput>
  }

  export type GroupUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedGroupsNestedInput
  }

  export type GroupUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UserUpsertWithoutReceivedInvitationsInput = {
    update: XOR<UserUpdateWithoutReceivedInvitationsInput, UserUncheckedUpdateWithoutReceivedInvitationsInput>
    create: XOR<UserCreateWithoutReceivedInvitationsInput, UserUncheckedCreateWithoutReceivedInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedInvitationsInput, UserUncheckedUpdateWithoutReceivedInvitationsInput>
  }

  export type UserUpdateWithoutReceivedInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUpdateManyWithoutFromCoachNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutUserNestedInput
    coach?: UserUpdateOneWithoutStudentsNestedInput
    students?: UserUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutFromCoachNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUncheckedUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUncheckedUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUncheckedUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUncheckedUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUncheckedUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUncheckedUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutUserNestedInput
    students?: UserUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type UserCreateWithoutCreatedExercisesInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressCreateNestedManyWithoutStudentInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutUserInput
    coach?: UserCreateNestedOneWithoutStudentsInput
    students?: UserCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutCreatedExercisesInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    coachId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentUncheckedCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentUncheckedCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressUncheckedCreateNestedManyWithoutStudentInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingUncheckedCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryUncheckedCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseUncheckedCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutUserInput
    students?: UserUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutCreatedExercisesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedExercisesInput, UserUncheckedCreateWithoutCreatedExercisesInput>
  }

  export type SessionExerciseCreateWithoutExerciseInput = {
    id?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    position: number
    session: SessionCreateNestedOneWithoutExercisesInput
    progressInstances?: SessionProgressCreateNestedManyWithoutExerciseInstanceInput
  }

  export type SessionExerciseUncheckedCreateWithoutExerciseInput = {
    id?: string
    sessionId: string
    config?: NullableJsonNullValueInput | InputJsonValue
    position: number
    progressInstances?: SessionProgressUncheckedCreateNestedManyWithoutExerciseInstanceInput
  }

  export type SessionExerciseCreateOrConnectWithoutExerciseInput = {
    where: SessionExerciseWhereUniqueInput
    create: XOR<SessionExerciseCreateWithoutExerciseInput, SessionExerciseUncheckedCreateWithoutExerciseInput>
  }

  export type SessionExerciseCreateManyExerciseInputEnvelope = {
    data: SessionExerciseCreateManyExerciseInput | SessionExerciseCreateManyExerciseInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseRatingCreateWithoutExerciseInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExerciseRatingsInput
  }

  export type ExerciseRatingUncheckedCreateWithoutExerciseInput = {
    id?: string
    userId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseRatingCreateOrConnectWithoutExerciseInput = {
    where: ExerciseRatingWhereUniqueInput
    create: XOR<ExerciseRatingCreateWithoutExerciseInput, ExerciseRatingUncheckedCreateWithoutExerciseInput>
  }

  export type ExerciseRatingCreateManyExerciseInputEnvelope = {
    data: ExerciseRatingCreateManyExerciseInput | ExerciseRatingCreateManyExerciseInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseHistoryCreateWithoutExerciseInput = {
    id?: string
    viewedAt?: Date | string
    user: UserCreateNestedOneWithoutExerciseHistoryInput
  }

  export type ExerciseHistoryUncheckedCreateWithoutExerciseInput = {
    id?: string
    userId: string
    viewedAt?: Date | string
  }

  export type ExerciseHistoryCreateOrConnectWithoutExerciseInput = {
    where: ExerciseHistoryWhereUniqueInput
    create: XOR<ExerciseHistoryCreateWithoutExerciseInput, ExerciseHistoryUncheckedCreateWithoutExerciseInput>
  }

  export type ExerciseHistoryCreateManyExerciseInputEnvelope = {
    data: ExerciseHistoryCreateManyExerciseInput | ExerciseHistoryCreateManyExerciseInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteExerciseCreateWithoutExerciseInput = {
    id?: string
    addedAt?: Date | string
    user: UserCreateNestedOneWithoutFavoriteExercisesInput
  }

  export type FavoriteExerciseUncheckedCreateWithoutExerciseInput = {
    id?: string
    userId: string
    addedAt?: Date | string
  }

  export type FavoriteExerciseCreateOrConnectWithoutExerciseInput = {
    where: FavoriteExerciseWhereUniqueInput
    create: XOR<FavoriteExerciseCreateWithoutExerciseInput, FavoriteExerciseUncheckedCreateWithoutExerciseInput>
  }

  export type FavoriteExerciseCreateManyExerciseInputEnvelope = {
    data: FavoriteExerciseCreateManyExerciseInput | FavoriteExerciseCreateManyExerciseInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseLogCreateWithoutExerciseInput = {
    id?: string
    userId?: string | null
    reps?: number | null
    sets?: number | null
    setsCompleted?: number | null
    weight?: number | null
    duration?: number | null
    formRating?: number | null
    skipped?: boolean | null
    notes?: string | null
    loggedAt?: Date | string
    completedAt?: Date | string | null
    session: WorkoutSessionCreateNestedOneWithoutLogsInput
  }

  export type ExerciseLogUncheckedCreateWithoutExerciseInput = {
    id?: string
    sessionId: string
    userId?: string | null
    reps?: number | null
    sets?: number | null
    setsCompleted?: number | null
    weight?: number | null
    duration?: number | null
    formRating?: number | null
    skipped?: boolean | null
    notes?: string | null
    loggedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ExerciseLogCreateOrConnectWithoutExerciseInput = {
    where: ExerciseLogWhereUniqueInput
    create: XOR<ExerciseLogCreateWithoutExerciseInput, ExerciseLogUncheckedCreateWithoutExerciseInput>
  }

  export type ExerciseLogCreateManyExerciseInputEnvelope = {
    data: ExerciseLogCreateManyExerciseInput | ExerciseLogCreateManyExerciseInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedExercisesInput = {
    update: XOR<UserUpdateWithoutCreatedExercisesInput, UserUncheckedUpdateWithoutCreatedExercisesInput>
    create: XOR<UserCreateWithoutCreatedExercisesInput, UserUncheckedCreateWithoutCreatedExercisesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedExercisesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedExercisesInput, UserUncheckedUpdateWithoutCreatedExercisesInput>
  }

  export type UserUpdateWithoutCreatedExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutUserNestedInput
    coach?: UserUpdateOneWithoutStudentsNestedInput
    students?: UserUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUncheckedUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUncheckedUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUncheckedUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUncheckedUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUncheckedUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUncheckedUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutUserNestedInput
    students?: UserUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type SessionExerciseUpsertWithWhereUniqueWithoutExerciseInput = {
    where: SessionExerciseWhereUniqueInput
    update: XOR<SessionExerciseUpdateWithoutExerciseInput, SessionExerciseUncheckedUpdateWithoutExerciseInput>
    create: XOR<SessionExerciseCreateWithoutExerciseInput, SessionExerciseUncheckedCreateWithoutExerciseInput>
  }

  export type SessionExerciseUpdateWithWhereUniqueWithoutExerciseInput = {
    where: SessionExerciseWhereUniqueInput
    data: XOR<SessionExerciseUpdateWithoutExerciseInput, SessionExerciseUncheckedUpdateWithoutExerciseInput>
  }

  export type SessionExerciseUpdateManyWithWhereWithoutExerciseInput = {
    where: SessionExerciseScalarWhereInput
    data: XOR<SessionExerciseUpdateManyMutationInput, SessionExerciseUncheckedUpdateManyWithoutExerciseInput>
  }

  export type SessionExerciseScalarWhereInput = {
    AND?: SessionExerciseScalarWhereInput | SessionExerciseScalarWhereInput[]
    OR?: SessionExerciseScalarWhereInput[]
    NOT?: SessionExerciseScalarWhereInput | SessionExerciseScalarWhereInput[]
    id?: StringFilter<"SessionExercise"> | string
    sessionId?: StringFilter<"SessionExercise"> | string
    exerciseId?: StringFilter<"SessionExercise"> | string
    config?: JsonNullableFilter<"SessionExercise">
    position?: IntFilter<"SessionExercise"> | number
  }

  export type ExerciseRatingUpsertWithWhereUniqueWithoutExerciseInput = {
    where: ExerciseRatingWhereUniqueInput
    update: XOR<ExerciseRatingUpdateWithoutExerciseInput, ExerciseRatingUncheckedUpdateWithoutExerciseInput>
    create: XOR<ExerciseRatingCreateWithoutExerciseInput, ExerciseRatingUncheckedCreateWithoutExerciseInput>
  }

  export type ExerciseRatingUpdateWithWhereUniqueWithoutExerciseInput = {
    where: ExerciseRatingWhereUniqueInput
    data: XOR<ExerciseRatingUpdateWithoutExerciseInput, ExerciseRatingUncheckedUpdateWithoutExerciseInput>
  }

  export type ExerciseRatingUpdateManyWithWhereWithoutExerciseInput = {
    where: ExerciseRatingScalarWhereInput
    data: XOR<ExerciseRatingUpdateManyMutationInput, ExerciseRatingUncheckedUpdateManyWithoutExerciseInput>
  }

  export type ExerciseHistoryUpsertWithWhereUniqueWithoutExerciseInput = {
    where: ExerciseHistoryWhereUniqueInput
    update: XOR<ExerciseHistoryUpdateWithoutExerciseInput, ExerciseHistoryUncheckedUpdateWithoutExerciseInput>
    create: XOR<ExerciseHistoryCreateWithoutExerciseInput, ExerciseHistoryUncheckedCreateWithoutExerciseInput>
  }

  export type ExerciseHistoryUpdateWithWhereUniqueWithoutExerciseInput = {
    where: ExerciseHistoryWhereUniqueInput
    data: XOR<ExerciseHistoryUpdateWithoutExerciseInput, ExerciseHistoryUncheckedUpdateWithoutExerciseInput>
  }

  export type ExerciseHistoryUpdateManyWithWhereWithoutExerciseInput = {
    where: ExerciseHistoryScalarWhereInput
    data: XOR<ExerciseHistoryUpdateManyMutationInput, ExerciseHistoryUncheckedUpdateManyWithoutExerciseInput>
  }

  export type FavoriteExerciseUpsertWithWhereUniqueWithoutExerciseInput = {
    where: FavoriteExerciseWhereUniqueInput
    update: XOR<FavoriteExerciseUpdateWithoutExerciseInput, FavoriteExerciseUncheckedUpdateWithoutExerciseInput>
    create: XOR<FavoriteExerciseCreateWithoutExerciseInput, FavoriteExerciseUncheckedCreateWithoutExerciseInput>
  }

  export type FavoriteExerciseUpdateWithWhereUniqueWithoutExerciseInput = {
    where: FavoriteExerciseWhereUniqueInput
    data: XOR<FavoriteExerciseUpdateWithoutExerciseInput, FavoriteExerciseUncheckedUpdateWithoutExerciseInput>
  }

  export type FavoriteExerciseUpdateManyWithWhereWithoutExerciseInput = {
    where: FavoriteExerciseScalarWhereInput
    data: XOR<FavoriteExerciseUpdateManyMutationInput, FavoriteExerciseUncheckedUpdateManyWithoutExerciseInput>
  }

  export type ExerciseLogUpsertWithWhereUniqueWithoutExerciseInput = {
    where: ExerciseLogWhereUniqueInput
    update: XOR<ExerciseLogUpdateWithoutExerciseInput, ExerciseLogUncheckedUpdateWithoutExerciseInput>
    create: XOR<ExerciseLogCreateWithoutExerciseInput, ExerciseLogUncheckedCreateWithoutExerciseInput>
  }

  export type ExerciseLogUpdateWithWhereUniqueWithoutExerciseInput = {
    where: ExerciseLogWhereUniqueInput
    data: XOR<ExerciseLogUpdateWithoutExerciseInput, ExerciseLogUncheckedUpdateWithoutExerciseInput>
  }

  export type ExerciseLogUpdateManyWithWhereWithoutExerciseInput = {
    where: ExerciseLogScalarWhereInput
    data: XOR<ExerciseLogUpdateManyMutationInput, ExerciseLogUncheckedUpdateManyWithoutExerciseInput>
  }

  export type ExerciseLogScalarWhereInput = {
    AND?: ExerciseLogScalarWhereInput | ExerciseLogScalarWhereInput[]
    OR?: ExerciseLogScalarWhereInput[]
    NOT?: ExerciseLogScalarWhereInput | ExerciseLogScalarWhereInput[]
    id?: StringFilter<"ExerciseLog"> | string
    sessionId?: StringFilter<"ExerciseLog"> | string
    exerciseId?: StringFilter<"ExerciseLog"> | string
    userId?: StringNullableFilter<"ExerciseLog"> | string | null
    reps?: IntNullableFilter<"ExerciseLog"> | number | null
    sets?: IntNullableFilter<"ExerciseLog"> | number | null
    setsCompleted?: IntNullableFilter<"ExerciseLog"> | number | null
    weight?: FloatNullableFilter<"ExerciseLog"> | number | null
    duration?: IntNullableFilter<"ExerciseLog"> | number | null
    formRating?: IntNullableFilter<"ExerciseLog"> | number | null
    skipped?: BoolNullableFilter<"ExerciseLog"> | boolean | null
    notes?: StringNullableFilter<"ExerciseLog"> | string | null
    loggedAt?: DateTimeFilter<"ExerciseLog"> | Date | string
    completedAt?: DateTimeNullableFilter<"ExerciseLog"> | Date | string | null
  }

  export type ExerciseCreateWithoutRatingsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope: $Enums.Scope
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutCreatedExercisesInput
    sessionExercises?: SessionExerciseCreateNestedManyWithoutExerciseInput
    history?: ExerciseHistoryCreateNestedManyWithoutExerciseInput
    favorites?: FavoriteExerciseCreateNestedManyWithoutExerciseInput
    logs?: ExerciseLogCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutRatingsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope: $Enums.Scope
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionExercises?: SessionExerciseUncheckedCreateNestedManyWithoutExerciseInput
    history?: ExerciseHistoryUncheckedCreateNestedManyWithoutExerciseInput
    favorites?: FavoriteExerciseUncheckedCreateNestedManyWithoutExerciseInput
    logs?: ExerciseLogUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutRatingsInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutRatingsInput, ExerciseUncheckedCreateWithoutRatingsInput>
  }

  export type UserCreateWithoutExerciseRatingsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressCreateNestedManyWithoutStudentInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutUserInput
    coach?: UserCreateNestedOneWithoutStudentsInput
    students?: UserCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutExerciseRatingsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    coachId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentUncheckedCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentUncheckedCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressUncheckedCreateNestedManyWithoutStudentInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryUncheckedCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseUncheckedCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutUserInput
    students?: UserUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutExerciseRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExerciseRatingsInput, UserUncheckedCreateWithoutExerciseRatingsInput>
  }

  export type ExerciseUpsertWithoutRatingsInput = {
    update: XOR<ExerciseUpdateWithoutRatingsInput, ExerciseUncheckedUpdateWithoutRatingsInput>
    create: XOR<ExerciseCreateWithoutRatingsInput, ExerciseUncheckedCreateWithoutRatingsInput>
    where?: ExerciseWhereInput
  }

  export type ExerciseUpdateToOneWithWhereWithoutRatingsInput = {
    where?: ExerciseWhereInput
    data: XOR<ExerciseUpdateWithoutRatingsInput, ExerciseUncheckedUpdateWithoutRatingsInput>
  }

  export type ExerciseUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope?: EnumScopeFieldUpdateOperationsInput | $Enums.Scope
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutCreatedExercisesNestedInput
    sessionExercises?: SessionExerciseUpdateManyWithoutExerciseNestedInput
    history?: ExerciseHistoryUpdateManyWithoutExerciseNestedInput
    favorites?: FavoriteExerciseUpdateManyWithoutExerciseNestedInput
    logs?: ExerciseLogUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope?: EnumScopeFieldUpdateOperationsInput | $Enums.Scope
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionExercises?: SessionExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    history?: ExerciseHistoryUncheckedUpdateManyWithoutExerciseNestedInput
    favorites?: FavoriteExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    logs?: ExerciseLogUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type UserUpsertWithoutExerciseRatingsInput = {
    update: XOR<UserUpdateWithoutExerciseRatingsInput, UserUncheckedUpdateWithoutExerciseRatingsInput>
    create: XOR<UserCreateWithoutExerciseRatingsInput, UserUncheckedCreateWithoutExerciseRatingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExerciseRatingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExerciseRatingsInput, UserUncheckedUpdateWithoutExerciseRatingsInput>
  }

  export type UserUpdateWithoutExerciseRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutUserNestedInput
    coach?: UserUpdateOneWithoutStudentsNestedInput
    students?: UserUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutExerciseRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUncheckedUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUncheckedUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUncheckedUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUncheckedUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUncheckedUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutUserNestedInput
    students?: UserUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type UserCreateWithoutExerciseHistoryInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressCreateNestedManyWithoutStudentInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutUserInput
    coach?: UserCreateNestedOneWithoutStudentsInput
    students?: UserCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutExerciseHistoryInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    coachId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentUncheckedCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentUncheckedCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressUncheckedCreateNestedManyWithoutStudentInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingUncheckedCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseUncheckedCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutUserInput
    students?: UserUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutExerciseHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExerciseHistoryInput, UserUncheckedCreateWithoutExerciseHistoryInput>
  }

  export type ExerciseCreateWithoutHistoryInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope: $Enums.Scope
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutCreatedExercisesInput
    sessionExercises?: SessionExerciseCreateNestedManyWithoutExerciseInput
    ratings?: ExerciseRatingCreateNestedManyWithoutExerciseInput
    favorites?: FavoriteExerciseCreateNestedManyWithoutExerciseInput
    logs?: ExerciseLogCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutHistoryInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope: $Enums.Scope
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionExercises?: SessionExerciseUncheckedCreateNestedManyWithoutExerciseInput
    ratings?: ExerciseRatingUncheckedCreateNestedManyWithoutExerciseInput
    favorites?: FavoriteExerciseUncheckedCreateNestedManyWithoutExerciseInput
    logs?: ExerciseLogUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutHistoryInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutHistoryInput, ExerciseUncheckedCreateWithoutHistoryInput>
  }

  export type UserUpsertWithoutExerciseHistoryInput = {
    update: XOR<UserUpdateWithoutExerciseHistoryInput, UserUncheckedUpdateWithoutExerciseHistoryInput>
    create: XOR<UserCreateWithoutExerciseHistoryInput, UserUncheckedCreateWithoutExerciseHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExerciseHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExerciseHistoryInput, UserUncheckedUpdateWithoutExerciseHistoryInput>
  }

  export type UserUpdateWithoutExerciseHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutUserNestedInput
    coach?: UserUpdateOneWithoutStudentsNestedInput
    students?: UserUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutExerciseHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUncheckedUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUncheckedUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUncheckedUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUncheckedUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUncheckedUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutUserNestedInput
    students?: UserUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type ExerciseUpsertWithoutHistoryInput = {
    update: XOR<ExerciseUpdateWithoutHistoryInput, ExerciseUncheckedUpdateWithoutHistoryInput>
    create: XOR<ExerciseCreateWithoutHistoryInput, ExerciseUncheckedCreateWithoutHistoryInput>
    where?: ExerciseWhereInput
  }

  export type ExerciseUpdateToOneWithWhereWithoutHistoryInput = {
    where?: ExerciseWhereInput
    data: XOR<ExerciseUpdateWithoutHistoryInput, ExerciseUncheckedUpdateWithoutHistoryInput>
  }

  export type ExerciseUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope?: EnumScopeFieldUpdateOperationsInput | $Enums.Scope
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutCreatedExercisesNestedInput
    sessionExercises?: SessionExerciseUpdateManyWithoutExerciseNestedInput
    ratings?: ExerciseRatingUpdateManyWithoutExerciseNestedInput
    favorites?: FavoriteExerciseUpdateManyWithoutExerciseNestedInput
    logs?: ExerciseLogUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope?: EnumScopeFieldUpdateOperationsInput | $Enums.Scope
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionExercises?: SessionExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    ratings?: ExerciseRatingUncheckedUpdateManyWithoutExerciseNestedInput
    favorites?: FavoriteExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    logs?: ExerciseLogUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type UserCreateWithoutFavoriteExercisesInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressCreateNestedManyWithoutStudentInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutUserInput
    coach?: UserCreateNestedOneWithoutStudentsInput
    students?: UserCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutFavoriteExercisesInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    coachId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentUncheckedCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentUncheckedCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressUncheckedCreateNestedManyWithoutStudentInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingUncheckedCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryUncheckedCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutUserInput
    students?: UserUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutFavoriteExercisesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavoriteExercisesInput, UserUncheckedCreateWithoutFavoriteExercisesInput>
  }

  export type ExerciseCreateWithoutFavoritesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope: $Enums.Scope
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutCreatedExercisesInput
    sessionExercises?: SessionExerciseCreateNestedManyWithoutExerciseInput
    ratings?: ExerciseRatingCreateNestedManyWithoutExerciseInput
    history?: ExerciseHistoryCreateNestedManyWithoutExerciseInput
    logs?: ExerciseLogCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutFavoritesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope: $Enums.Scope
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionExercises?: SessionExerciseUncheckedCreateNestedManyWithoutExerciseInput
    ratings?: ExerciseRatingUncheckedCreateNestedManyWithoutExerciseInput
    history?: ExerciseHistoryUncheckedCreateNestedManyWithoutExerciseInput
    logs?: ExerciseLogUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutFavoritesInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutFavoritesInput, ExerciseUncheckedCreateWithoutFavoritesInput>
  }

  export type UserUpsertWithoutFavoriteExercisesInput = {
    update: XOR<UserUpdateWithoutFavoriteExercisesInput, UserUncheckedUpdateWithoutFavoriteExercisesInput>
    create: XOR<UserCreateWithoutFavoriteExercisesInput, UserUncheckedCreateWithoutFavoriteExercisesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavoriteExercisesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavoriteExercisesInput, UserUncheckedUpdateWithoutFavoriteExercisesInput>
  }

  export type UserUpdateWithoutFavoriteExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutUserNestedInput
    coach?: UserUpdateOneWithoutStudentsNestedInput
    students?: UserUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutFavoriteExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUncheckedUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUncheckedUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUncheckedUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUncheckedUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUncheckedUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutUserNestedInput
    students?: UserUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type ExerciseUpsertWithoutFavoritesInput = {
    update: XOR<ExerciseUpdateWithoutFavoritesInput, ExerciseUncheckedUpdateWithoutFavoritesInput>
    create: XOR<ExerciseCreateWithoutFavoritesInput, ExerciseUncheckedCreateWithoutFavoritesInput>
    where?: ExerciseWhereInput
  }

  export type ExerciseUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: ExerciseWhereInput
    data: XOR<ExerciseUpdateWithoutFavoritesInput, ExerciseUncheckedUpdateWithoutFavoritesInput>
  }

  export type ExerciseUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope?: EnumScopeFieldUpdateOperationsInput | $Enums.Scope
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutCreatedExercisesNestedInput
    sessionExercises?: SessionExerciseUpdateManyWithoutExerciseNestedInput
    ratings?: ExerciseRatingUpdateManyWithoutExerciseNestedInput
    history?: ExerciseHistoryUpdateManyWithoutExerciseNestedInput
    logs?: ExerciseLogUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope?: EnumScopeFieldUpdateOperationsInput | $Enums.Scope
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionExercises?: SessionExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    ratings?: ExerciseRatingUncheckedUpdateManyWithoutExerciseNestedInput
    history?: ExerciseHistoryUncheckedUpdateManyWithoutExerciseNestedInput
    logs?: ExerciseLogUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type UserCreateWithoutWorkoutSessionsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressCreateNestedManyWithoutStudentInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseCreateNestedManyWithoutUserInput
    coach?: UserCreateNestedOneWithoutStudentsInput
    students?: UserCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutWorkoutSessionsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    coachId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentUncheckedCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentUncheckedCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressUncheckedCreateNestedManyWithoutStudentInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingUncheckedCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryUncheckedCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseUncheckedCreateNestedManyWithoutUserInput
    students?: UserUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutWorkoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkoutSessionsInput, UserUncheckedCreateWithoutWorkoutSessionsInput>
  }

  export type ExerciseLogCreateWithoutSessionInput = {
    id?: string
    userId?: string | null
    reps?: number | null
    sets?: number | null
    setsCompleted?: number | null
    weight?: number | null
    duration?: number | null
    formRating?: number | null
    skipped?: boolean | null
    notes?: string | null
    loggedAt?: Date | string
    completedAt?: Date | string | null
    exercise: ExerciseCreateNestedOneWithoutLogsInput
  }

  export type ExerciseLogUncheckedCreateWithoutSessionInput = {
    id?: string
    exerciseId: string
    userId?: string | null
    reps?: number | null
    sets?: number | null
    setsCompleted?: number | null
    weight?: number | null
    duration?: number | null
    formRating?: number | null
    skipped?: boolean | null
    notes?: string | null
    loggedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ExerciseLogCreateOrConnectWithoutSessionInput = {
    where: ExerciseLogWhereUniqueInput
    create: XOR<ExerciseLogCreateWithoutSessionInput, ExerciseLogUncheckedCreateWithoutSessionInput>
  }

  export type ExerciseLogCreateManySessionInputEnvelope = {
    data: ExerciseLogCreateManySessionInput | ExerciseLogCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWorkoutSessionsInput = {
    update: XOR<UserUpdateWithoutWorkoutSessionsInput, UserUncheckedUpdateWithoutWorkoutSessionsInput>
    create: XOR<UserCreateWithoutWorkoutSessionsInput, UserUncheckedCreateWithoutWorkoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkoutSessionsInput, UserUncheckedUpdateWithoutWorkoutSessionsInput>
  }

  export type UserUpdateWithoutWorkoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUpdateManyWithoutUserNestedInput
    coach?: UserUpdateOneWithoutStudentsNestedInput
    students?: UserUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUncheckedUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUncheckedUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUncheckedUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUncheckedUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUncheckedUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUncheckedUpdateManyWithoutUserNestedInput
    students?: UserUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type ExerciseLogUpsertWithWhereUniqueWithoutSessionInput = {
    where: ExerciseLogWhereUniqueInput
    update: XOR<ExerciseLogUpdateWithoutSessionInput, ExerciseLogUncheckedUpdateWithoutSessionInput>
    create: XOR<ExerciseLogCreateWithoutSessionInput, ExerciseLogUncheckedCreateWithoutSessionInput>
  }

  export type ExerciseLogUpdateWithWhereUniqueWithoutSessionInput = {
    where: ExerciseLogWhereUniqueInput
    data: XOR<ExerciseLogUpdateWithoutSessionInput, ExerciseLogUncheckedUpdateWithoutSessionInput>
  }

  export type ExerciseLogUpdateManyWithWhereWithoutSessionInput = {
    where: ExerciseLogScalarWhereInput
    data: XOR<ExerciseLogUpdateManyMutationInput, ExerciseLogUncheckedUpdateManyWithoutSessionInput>
  }

  export type WorkoutSessionCreateWithoutLogsInput = {
    id?: string
    title?: string | null
    startedAt?: Date | string
    startTime?: Date | string | null
    endedAt?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    notes?: string | null
    restPeriodSeconds?: number | null
    formGuidanceEnabled?: boolean | null
    exercisesCompleted?: number | null
    totalExercises?: number | null
    user: UserCreateNestedOneWithoutWorkoutSessionsInput
  }

  export type WorkoutSessionUncheckedCreateWithoutLogsInput = {
    id?: string
    userId: string
    title?: string | null
    startedAt?: Date | string
    startTime?: Date | string | null
    endedAt?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    notes?: string | null
    restPeriodSeconds?: number | null
    formGuidanceEnabled?: boolean | null
    exercisesCompleted?: number | null
    totalExercises?: number | null
  }

  export type WorkoutSessionCreateOrConnectWithoutLogsInput = {
    where: WorkoutSessionWhereUniqueInput
    create: XOR<WorkoutSessionCreateWithoutLogsInput, WorkoutSessionUncheckedCreateWithoutLogsInput>
  }

  export type ExerciseCreateWithoutLogsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope: $Enums.Scope
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutCreatedExercisesInput
    sessionExercises?: SessionExerciseCreateNestedManyWithoutExerciseInput
    ratings?: ExerciseRatingCreateNestedManyWithoutExerciseInput
    history?: ExerciseHistoryCreateNestedManyWithoutExerciseInput
    favorites?: FavoriteExerciseCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutLogsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope: $Enums.Scope
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionExercises?: SessionExerciseUncheckedCreateNestedManyWithoutExerciseInput
    ratings?: ExerciseRatingUncheckedCreateNestedManyWithoutExerciseInput
    history?: ExerciseHistoryUncheckedCreateNestedManyWithoutExerciseInput
    favorites?: FavoriteExerciseUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutLogsInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutLogsInput, ExerciseUncheckedCreateWithoutLogsInput>
  }

  export type WorkoutSessionUpsertWithoutLogsInput = {
    update: XOR<WorkoutSessionUpdateWithoutLogsInput, WorkoutSessionUncheckedUpdateWithoutLogsInput>
    create: XOR<WorkoutSessionCreateWithoutLogsInput, WorkoutSessionUncheckedCreateWithoutLogsInput>
    where?: WorkoutSessionWhereInput
  }

  export type WorkoutSessionUpdateToOneWithWhereWithoutLogsInput = {
    where?: WorkoutSessionWhereInput
    data: XOR<WorkoutSessionUpdateWithoutLogsInput, WorkoutSessionUncheckedUpdateWithoutLogsInput>
  }

  export type WorkoutSessionUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    restPeriodSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    formGuidanceEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exercisesCompleted?: NullableIntFieldUpdateOperationsInput | number | null
    totalExercises?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutWorkoutSessionsNestedInput
  }

  export type WorkoutSessionUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    restPeriodSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    formGuidanceEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exercisesCompleted?: NullableIntFieldUpdateOperationsInput | number | null
    totalExercises?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExerciseUpsertWithoutLogsInput = {
    update: XOR<ExerciseUpdateWithoutLogsInput, ExerciseUncheckedUpdateWithoutLogsInput>
    create: XOR<ExerciseCreateWithoutLogsInput, ExerciseUncheckedCreateWithoutLogsInput>
    where?: ExerciseWhereInput
  }

  export type ExerciseUpdateToOneWithWhereWithoutLogsInput = {
    where?: ExerciseWhereInput
    data: XOR<ExerciseUpdateWithoutLogsInput, ExerciseUncheckedUpdateWithoutLogsInput>
  }

  export type ExerciseUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope?: EnumScopeFieldUpdateOperationsInput | $Enums.Scope
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutCreatedExercisesNestedInput
    sessionExercises?: SessionExerciseUpdateManyWithoutExerciseNestedInput
    ratings?: ExerciseRatingUpdateManyWithoutExerciseNestedInput
    history?: ExerciseHistoryUpdateManyWithoutExerciseNestedInput
    favorites?: FavoriteExerciseUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope?: EnumScopeFieldUpdateOperationsInput | $Enums.Scope
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionExercises?: SessionExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    ratings?: ExerciseRatingUncheckedUpdateManyWithoutExerciseNestedInput
    history?: ExerciseHistoryUncheckedUpdateManyWithoutExerciseNestedInput
    favorites?: FavoriteExerciseUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type ProgramAssignmentCreateWithoutProgramInput = {
    id?: string
    assignedAt?: Date | string
    assigner?: UserCreateNestedOneWithoutAssignedByInput
    student: UserCreateNestedOneWithoutAssignedProgramsInput
  }

  export type ProgramAssignmentUncheckedCreateWithoutProgramInput = {
    id?: string
    studentId: string
    assignedBy?: string | null
    assignedAt?: Date | string
  }

  export type ProgramAssignmentCreateOrConnectWithoutProgramInput = {
    where: ProgramAssignmentWhereUniqueInput
    create: XOR<ProgramAssignmentCreateWithoutProgramInput, ProgramAssignmentUncheckedCreateWithoutProgramInput>
  }

  export type ProgramAssignmentCreateManyProgramInputEnvelope = {
    data: ProgramAssignmentCreateManyProgramInput | ProgramAssignmentCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type ProgramAuditCreateWithoutProgramInput = {
    id?: string
    changeType: string
    diff?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type ProgramAuditUncheckedCreateWithoutProgramInput = {
    id?: string
    changedBy: string
    changeType: string
    diff?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ProgramAuditCreateOrConnectWithoutProgramInput = {
    where: ProgramAuditWhereUniqueInput
    create: XOR<ProgramAuditCreateWithoutProgramInput, ProgramAuditUncheckedCreateWithoutProgramInput>
  }

  export type ProgramAuditCreateManyProgramInputEnvelope = {
    data: ProgramAuditCreateManyProgramInput | ProgramAuditCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type ProgramBlockCreateWithoutProgramInput = {
    id?: string
    title?: string | null
    position: number
    notes?: string | null
    weeks?: WeekCreateNestedManyWithoutBlockInput
  }

  export type ProgramBlockUncheckedCreateWithoutProgramInput = {
    id?: string
    title?: string | null
    position: number
    notes?: string | null
    weeks?: WeekUncheckedCreateNestedManyWithoutBlockInput
  }

  export type ProgramBlockCreateOrConnectWithoutProgramInput = {
    where: ProgramBlockWhereUniqueInput
    create: XOR<ProgramBlockCreateWithoutProgramInput, ProgramBlockUncheckedCreateWithoutProgramInput>
  }

  export type ProgramBlockCreateManyProgramInputEnvelope = {
    data: ProgramBlockCreateManyProgramInput | ProgramBlockCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCreatedProgramsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutUserInput
    sessionProgress?: SessionProgressCreateNestedManyWithoutStudentInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutUserInput
    coach?: UserCreateNestedOneWithoutStudentsInput
    students?: UserCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutCreatedProgramsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    coachId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentUncheckedCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentUncheckedCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutUserInput
    sessionProgress?: SessionProgressUncheckedCreateNestedManyWithoutStudentInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingUncheckedCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryUncheckedCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseUncheckedCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutUserInput
    students?: UserUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutCreatedProgramsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedProgramsInput, UserUncheckedCreateWithoutCreatedProgramsInput>
  }

  export type ProgramAssignmentUpsertWithWhereUniqueWithoutProgramInput = {
    where: ProgramAssignmentWhereUniqueInput
    update: XOR<ProgramAssignmentUpdateWithoutProgramInput, ProgramAssignmentUncheckedUpdateWithoutProgramInput>
    create: XOR<ProgramAssignmentCreateWithoutProgramInput, ProgramAssignmentUncheckedCreateWithoutProgramInput>
  }

  export type ProgramAssignmentUpdateWithWhereUniqueWithoutProgramInput = {
    where: ProgramAssignmentWhereUniqueInput
    data: XOR<ProgramAssignmentUpdateWithoutProgramInput, ProgramAssignmentUncheckedUpdateWithoutProgramInput>
  }

  export type ProgramAssignmentUpdateManyWithWhereWithoutProgramInput = {
    where: ProgramAssignmentScalarWhereInput
    data: XOR<ProgramAssignmentUpdateManyMutationInput, ProgramAssignmentUncheckedUpdateManyWithoutProgramInput>
  }

  export type ProgramAuditUpsertWithWhereUniqueWithoutProgramInput = {
    where: ProgramAuditWhereUniqueInput
    update: XOR<ProgramAuditUpdateWithoutProgramInput, ProgramAuditUncheckedUpdateWithoutProgramInput>
    create: XOR<ProgramAuditCreateWithoutProgramInput, ProgramAuditUncheckedCreateWithoutProgramInput>
  }

  export type ProgramAuditUpdateWithWhereUniqueWithoutProgramInput = {
    where: ProgramAuditWhereUniqueInput
    data: XOR<ProgramAuditUpdateWithoutProgramInput, ProgramAuditUncheckedUpdateWithoutProgramInput>
  }

  export type ProgramAuditUpdateManyWithWhereWithoutProgramInput = {
    where: ProgramAuditScalarWhereInput
    data: XOR<ProgramAuditUpdateManyMutationInput, ProgramAuditUncheckedUpdateManyWithoutProgramInput>
  }

  export type ProgramBlockUpsertWithWhereUniqueWithoutProgramInput = {
    where: ProgramBlockWhereUniqueInput
    update: XOR<ProgramBlockUpdateWithoutProgramInput, ProgramBlockUncheckedUpdateWithoutProgramInput>
    create: XOR<ProgramBlockCreateWithoutProgramInput, ProgramBlockUncheckedCreateWithoutProgramInput>
  }

  export type ProgramBlockUpdateWithWhereUniqueWithoutProgramInput = {
    where: ProgramBlockWhereUniqueInput
    data: XOR<ProgramBlockUpdateWithoutProgramInput, ProgramBlockUncheckedUpdateWithoutProgramInput>
  }

  export type ProgramBlockUpdateManyWithWhereWithoutProgramInput = {
    where: ProgramBlockScalarWhereInput
    data: XOR<ProgramBlockUpdateManyMutationInput, ProgramBlockUncheckedUpdateManyWithoutProgramInput>
  }

  export type ProgramBlockScalarWhereInput = {
    AND?: ProgramBlockScalarWhereInput | ProgramBlockScalarWhereInput[]
    OR?: ProgramBlockScalarWhereInput[]
    NOT?: ProgramBlockScalarWhereInput | ProgramBlockScalarWhereInput[]
    id?: StringFilter<"ProgramBlock"> | string
    programId?: StringFilter<"ProgramBlock"> | string
    title?: StringNullableFilter<"ProgramBlock"> | string | null
    position?: IntFilter<"ProgramBlock"> | number
    notes?: StringNullableFilter<"ProgramBlock"> | string | null
  }

  export type UserUpsertWithoutCreatedProgramsInput = {
    update: XOR<UserUpdateWithoutCreatedProgramsInput, UserUncheckedUpdateWithoutCreatedProgramsInput>
    create: XOR<UserCreateWithoutCreatedProgramsInput, UserUncheckedCreateWithoutCreatedProgramsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedProgramsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedProgramsInput, UserUncheckedUpdateWithoutCreatedProgramsInput>
  }

  export type UserUpdateWithoutCreatedProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutUserNestedInput
    sessionProgress?: SessionProgressUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutUserNestedInput
    coach?: UserUpdateOneWithoutStudentsNestedInput
    students?: UserUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUncheckedUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUncheckedUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutUserNestedInput
    sessionProgress?: SessionProgressUncheckedUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUncheckedUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUncheckedUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUncheckedUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutUserNestedInput
    students?: UserUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type ProgramCreateWithoutBlocksInput = {
    id?: string
    title: string
    description?: string | null
    ownerId?: string | null
    isDraft?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: ProgramAssignmentCreateNestedManyWithoutProgramInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutProgramInput
    coach: UserCreateNestedOneWithoutCreatedProgramsInput
  }

  export type ProgramUncheckedCreateWithoutBlocksInput = {
    id?: string
    title: string
    description?: string | null
    coachId: string
    ownerId?: string | null
    isDraft?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: ProgramAssignmentUncheckedCreateNestedManyWithoutProgramInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutBlocksInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutBlocksInput, ProgramUncheckedCreateWithoutBlocksInput>
  }

  export type WeekCreateWithoutBlockInput = {
    id?: string
    weekNumber: number
    position: number
    sessions?: SessionCreateNestedManyWithoutWeekInput
  }

  export type WeekUncheckedCreateWithoutBlockInput = {
    id?: string
    weekNumber: number
    position: number
    sessions?: SessionUncheckedCreateNestedManyWithoutWeekInput
  }

  export type WeekCreateOrConnectWithoutBlockInput = {
    where: WeekWhereUniqueInput
    create: XOR<WeekCreateWithoutBlockInput, WeekUncheckedCreateWithoutBlockInput>
  }

  export type WeekCreateManyBlockInputEnvelope = {
    data: WeekCreateManyBlockInput | WeekCreateManyBlockInput[]
    skipDuplicates?: boolean
  }

  export type ProgramUpsertWithoutBlocksInput = {
    update: XOR<ProgramUpdateWithoutBlocksInput, ProgramUncheckedUpdateWithoutBlocksInput>
    create: XOR<ProgramCreateWithoutBlocksInput, ProgramUncheckedCreateWithoutBlocksInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutBlocksInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutBlocksInput, ProgramUncheckedUpdateWithoutBlocksInput>
  }

  export type ProgramUpdateWithoutBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: ProgramAssignmentUpdateManyWithoutProgramNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutProgramNestedInput
    coach?: UserUpdateOneRequiredWithoutCreatedProgramsNestedInput
  }

  export type ProgramUncheckedUpdateWithoutBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: ProgramAssignmentUncheckedUpdateManyWithoutProgramNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type WeekUpsertWithWhereUniqueWithoutBlockInput = {
    where: WeekWhereUniqueInput
    update: XOR<WeekUpdateWithoutBlockInput, WeekUncheckedUpdateWithoutBlockInput>
    create: XOR<WeekCreateWithoutBlockInput, WeekUncheckedCreateWithoutBlockInput>
  }

  export type WeekUpdateWithWhereUniqueWithoutBlockInput = {
    where: WeekWhereUniqueInput
    data: XOR<WeekUpdateWithoutBlockInput, WeekUncheckedUpdateWithoutBlockInput>
  }

  export type WeekUpdateManyWithWhereWithoutBlockInput = {
    where: WeekScalarWhereInput
    data: XOR<WeekUpdateManyMutationInput, WeekUncheckedUpdateManyWithoutBlockInput>
  }

  export type WeekScalarWhereInput = {
    AND?: WeekScalarWhereInput | WeekScalarWhereInput[]
    OR?: WeekScalarWhereInput[]
    NOT?: WeekScalarWhereInput | WeekScalarWhereInput[]
    id?: StringFilter<"Week"> | string
    blockId?: StringFilter<"Week"> | string
    weekNumber?: IntFilter<"Week"> | number
    position?: IntFilter<"Week"> | number
  }

  export type SessionCreateWithoutWeekInput = {
    id?: string
    title?: string | null
    notes?: string | null
    date?: Date | string | null
    position: number
    data?: NullableJsonNullValueInput | InputJsonValue
    exercises?: SessionExerciseCreateNestedManyWithoutSessionInput
    progress?: SessionProgressCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutWeekInput = {
    id?: string
    title?: string | null
    notes?: string | null
    date?: Date | string | null
    position: number
    data?: NullableJsonNullValueInput | InputJsonValue
    exercises?: SessionExerciseUncheckedCreateNestedManyWithoutSessionInput
    progress?: SessionProgressUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutWeekInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutWeekInput, SessionUncheckedCreateWithoutWeekInput>
  }

  export type SessionCreateManyWeekInputEnvelope = {
    data: SessionCreateManyWeekInput | SessionCreateManyWeekInput[]
    skipDuplicates?: boolean
  }

  export type ProgramBlockCreateWithoutWeeksInput = {
    id?: string
    title?: string | null
    position: number
    notes?: string | null
    program: ProgramCreateNestedOneWithoutBlocksInput
  }

  export type ProgramBlockUncheckedCreateWithoutWeeksInput = {
    id?: string
    programId: string
    title?: string | null
    position: number
    notes?: string | null
  }

  export type ProgramBlockCreateOrConnectWithoutWeeksInput = {
    where: ProgramBlockWhereUniqueInput
    create: XOR<ProgramBlockCreateWithoutWeeksInput, ProgramBlockUncheckedCreateWithoutWeeksInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutWeekInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutWeekInput, SessionUncheckedUpdateWithoutWeekInput>
    create: XOR<SessionCreateWithoutWeekInput, SessionUncheckedCreateWithoutWeekInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutWeekInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutWeekInput, SessionUncheckedUpdateWithoutWeekInput>
  }

  export type SessionUpdateManyWithWhereWithoutWeekInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutWeekInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    weekId?: StringFilter<"Session"> | string
    title?: StringNullableFilter<"Session"> | string | null
    notes?: StringNullableFilter<"Session"> | string | null
    date?: DateTimeNullableFilter<"Session"> | Date | string | null
    position?: IntFilter<"Session"> | number
    data?: JsonNullableFilter<"Session">
  }

  export type ProgramBlockUpsertWithoutWeeksInput = {
    update: XOR<ProgramBlockUpdateWithoutWeeksInput, ProgramBlockUncheckedUpdateWithoutWeeksInput>
    create: XOR<ProgramBlockCreateWithoutWeeksInput, ProgramBlockUncheckedCreateWithoutWeeksInput>
    where?: ProgramBlockWhereInput
  }

  export type ProgramBlockUpdateToOneWithWhereWithoutWeeksInput = {
    where?: ProgramBlockWhereInput
    data: XOR<ProgramBlockUpdateWithoutWeeksInput, ProgramBlockUncheckedUpdateWithoutWeeksInput>
  }

  export type ProgramBlockUpdateWithoutWeeksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    program?: ProgramUpdateOneRequiredWithoutBlocksNestedInput
  }

  export type ProgramBlockUncheckedUpdateWithoutWeeksInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionExerciseCreateWithoutSessionInput = {
    id?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    position: number
    exercise: ExerciseCreateNestedOneWithoutSessionExercisesInput
    progressInstances?: SessionProgressCreateNestedManyWithoutExerciseInstanceInput
  }

  export type SessionExerciseUncheckedCreateWithoutSessionInput = {
    id?: string
    exerciseId: string
    config?: NullableJsonNullValueInput | InputJsonValue
    position: number
    progressInstances?: SessionProgressUncheckedCreateNestedManyWithoutExerciseInstanceInput
  }

  export type SessionExerciseCreateOrConnectWithoutSessionInput = {
    where: SessionExerciseWhereUniqueInput
    create: XOR<SessionExerciseCreateWithoutSessionInput, SessionExerciseUncheckedCreateWithoutSessionInput>
  }

  export type SessionExerciseCreateManySessionInputEnvelope = {
    data: SessionExerciseCreateManySessionInput | SessionExerciseCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type SessionProgressCreateWithoutSessionInput = {
    id?: string
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    videos?: SessionProgressCreatevideosInput | string[]
    savedAt?: Date | string
    exerciseInstance?: SessionExerciseCreateNestedOneWithoutProgressInstancesInput
    student: UserCreateNestedOneWithoutSessionProgressInput
  }

  export type SessionProgressUncheckedCreateWithoutSessionInput = {
    id?: string
    studentId: string
    exerciseInstanceId?: string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    videos?: SessionProgressCreatevideosInput | string[]
    savedAt?: Date | string
  }

  export type SessionProgressCreateOrConnectWithoutSessionInput = {
    where: SessionProgressWhereUniqueInput
    create: XOR<SessionProgressCreateWithoutSessionInput, SessionProgressUncheckedCreateWithoutSessionInput>
  }

  export type SessionProgressCreateManySessionInputEnvelope = {
    data: SessionProgressCreateManySessionInput | SessionProgressCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type WeekCreateWithoutSessionsInput = {
    id?: string
    weekNumber: number
    position: number
    block: ProgramBlockCreateNestedOneWithoutWeeksInput
  }

  export type WeekUncheckedCreateWithoutSessionsInput = {
    id?: string
    blockId: string
    weekNumber: number
    position: number
  }

  export type WeekCreateOrConnectWithoutSessionsInput = {
    where: WeekWhereUniqueInput
    create: XOR<WeekCreateWithoutSessionsInput, WeekUncheckedCreateWithoutSessionsInput>
  }

  export type SessionExerciseUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionExerciseWhereUniqueInput
    update: XOR<SessionExerciseUpdateWithoutSessionInput, SessionExerciseUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionExerciseCreateWithoutSessionInput, SessionExerciseUncheckedCreateWithoutSessionInput>
  }

  export type SessionExerciseUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionExerciseWhereUniqueInput
    data: XOR<SessionExerciseUpdateWithoutSessionInput, SessionExerciseUncheckedUpdateWithoutSessionInput>
  }

  export type SessionExerciseUpdateManyWithWhereWithoutSessionInput = {
    where: SessionExerciseScalarWhereInput
    data: XOR<SessionExerciseUpdateManyMutationInput, SessionExerciseUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionProgressUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionProgressWhereUniqueInput
    update: XOR<SessionProgressUpdateWithoutSessionInput, SessionProgressUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionProgressCreateWithoutSessionInput, SessionProgressUncheckedCreateWithoutSessionInput>
  }

  export type SessionProgressUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionProgressWhereUniqueInput
    data: XOR<SessionProgressUpdateWithoutSessionInput, SessionProgressUncheckedUpdateWithoutSessionInput>
  }

  export type SessionProgressUpdateManyWithWhereWithoutSessionInput = {
    where: SessionProgressScalarWhereInput
    data: XOR<SessionProgressUpdateManyMutationInput, SessionProgressUncheckedUpdateManyWithoutSessionInput>
  }

  export type WeekUpsertWithoutSessionsInput = {
    update: XOR<WeekUpdateWithoutSessionsInput, WeekUncheckedUpdateWithoutSessionsInput>
    create: XOR<WeekCreateWithoutSessionsInput, WeekUncheckedCreateWithoutSessionsInput>
    where?: WeekWhereInput
  }

  export type WeekUpdateToOneWithWhereWithoutSessionsInput = {
    where?: WeekWhereInput
    data: XOR<WeekUpdateWithoutSessionsInput, WeekUncheckedUpdateWithoutSessionsInput>
  }

  export type WeekUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    block?: ProgramBlockUpdateOneRequiredWithoutWeeksNestedInput
  }

  export type WeekUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockId?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ExerciseCreateWithoutSessionExercisesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope: $Enums.Scope
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutCreatedExercisesInput
    ratings?: ExerciseRatingCreateNestedManyWithoutExerciseInput
    history?: ExerciseHistoryCreateNestedManyWithoutExerciseInput
    favorites?: FavoriteExerciseCreateNestedManyWithoutExerciseInput
    logs?: ExerciseLogCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutSessionExercisesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope: $Enums.Scope
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ratings?: ExerciseRatingUncheckedCreateNestedManyWithoutExerciseInput
    history?: ExerciseHistoryUncheckedCreateNestedManyWithoutExerciseInput
    favorites?: FavoriteExerciseUncheckedCreateNestedManyWithoutExerciseInput
    logs?: ExerciseLogUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutSessionExercisesInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutSessionExercisesInput, ExerciseUncheckedCreateWithoutSessionExercisesInput>
  }

  export type SessionCreateWithoutExercisesInput = {
    id?: string
    title?: string | null
    notes?: string | null
    date?: Date | string | null
    position: number
    data?: NullableJsonNullValueInput | InputJsonValue
    progress?: SessionProgressCreateNestedManyWithoutSessionInput
    week: WeekCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateWithoutExercisesInput = {
    id?: string
    weekId: string
    title?: string | null
    notes?: string | null
    date?: Date | string | null
    position: number
    data?: NullableJsonNullValueInput | InputJsonValue
    progress?: SessionProgressUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutExercisesInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutExercisesInput, SessionUncheckedCreateWithoutExercisesInput>
  }

  export type SessionProgressCreateWithoutExerciseInstanceInput = {
    id?: string
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    videos?: SessionProgressCreatevideosInput | string[]
    savedAt?: Date | string
    session: SessionCreateNestedOneWithoutProgressInput
    student: UserCreateNestedOneWithoutSessionProgressInput
  }

  export type SessionProgressUncheckedCreateWithoutExerciseInstanceInput = {
    id?: string
    sessionId: string
    studentId: string
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    videos?: SessionProgressCreatevideosInput | string[]
    savedAt?: Date | string
  }

  export type SessionProgressCreateOrConnectWithoutExerciseInstanceInput = {
    where: SessionProgressWhereUniqueInput
    create: XOR<SessionProgressCreateWithoutExerciseInstanceInput, SessionProgressUncheckedCreateWithoutExerciseInstanceInput>
  }

  export type SessionProgressCreateManyExerciseInstanceInputEnvelope = {
    data: SessionProgressCreateManyExerciseInstanceInput | SessionProgressCreateManyExerciseInstanceInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseUpsertWithoutSessionExercisesInput = {
    update: XOR<ExerciseUpdateWithoutSessionExercisesInput, ExerciseUncheckedUpdateWithoutSessionExercisesInput>
    create: XOR<ExerciseCreateWithoutSessionExercisesInput, ExerciseUncheckedCreateWithoutSessionExercisesInput>
    where?: ExerciseWhereInput
  }

  export type ExerciseUpdateToOneWithWhereWithoutSessionExercisesInput = {
    where?: ExerciseWhereInput
    data: XOR<ExerciseUpdateWithoutSessionExercisesInput, ExerciseUncheckedUpdateWithoutSessionExercisesInput>
  }

  export type ExerciseUpdateWithoutSessionExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope?: EnumScopeFieldUpdateOperationsInput | $Enums.Scope
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutCreatedExercisesNestedInput
    ratings?: ExerciseRatingUpdateManyWithoutExerciseNestedInput
    history?: ExerciseHistoryUpdateManyWithoutExerciseNestedInput
    favorites?: FavoriteExerciseUpdateManyWithoutExerciseNestedInput
    logs?: ExerciseLogUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutSessionExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope?: EnumScopeFieldUpdateOperationsInput | $Enums.Scope
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ratings?: ExerciseRatingUncheckedUpdateManyWithoutExerciseNestedInput
    history?: ExerciseHistoryUncheckedUpdateManyWithoutExerciseNestedInput
    favorites?: FavoriteExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    logs?: ExerciseLogUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type SessionUpsertWithoutExercisesInput = {
    update: XOR<SessionUpdateWithoutExercisesInput, SessionUncheckedUpdateWithoutExercisesInput>
    create: XOR<SessionCreateWithoutExercisesInput, SessionUncheckedCreateWithoutExercisesInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutExercisesInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutExercisesInput, SessionUncheckedUpdateWithoutExercisesInput>
  }

  export type SessionUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: IntFieldUpdateOperationsInput | number
    data?: NullableJsonNullValueInput | InputJsonValue
    progress?: SessionProgressUpdateManyWithoutSessionNestedInput
    week?: WeekUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: IntFieldUpdateOperationsInput | number
    data?: NullableJsonNullValueInput | InputJsonValue
    progress?: SessionProgressUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionProgressUpsertWithWhereUniqueWithoutExerciseInstanceInput = {
    where: SessionProgressWhereUniqueInput
    update: XOR<SessionProgressUpdateWithoutExerciseInstanceInput, SessionProgressUncheckedUpdateWithoutExerciseInstanceInput>
    create: XOR<SessionProgressCreateWithoutExerciseInstanceInput, SessionProgressUncheckedCreateWithoutExerciseInstanceInput>
  }

  export type SessionProgressUpdateWithWhereUniqueWithoutExerciseInstanceInput = {
    where: SessionProgressWhereUniqueInput
    data: XOR<SessionProgressUpdateWithoutExerciseInstanceInput, SessionProgressUncheckedUpdateWithoutExerciseInstanceInput>
  }

  export type SessionProgressUpdateManyWithWhereWithoutExerciseInstanceInput = {
    where: SessionProgressScalarWhereInput
    data: XOR<SessionProgressUpdateManyMutationInput, SessionProgressUncheckedUpdateManyWithoutExerciseInstanceInput>
  }

  export type SessionExerciseCreateWithoutProgressInstancesInput = {
    id?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    position: number
    exercise: ExerciseCreateNestedOneWithoutSessionExercisesInput
    session: SessionCreateNestedOneWithoutExercisesInput
  }

  export type SessionExerciseUncheckedCreateWithoutProgressInstancesInput = {
    id?: string
    sessionId: string
    exerciseId: string
    config?: NullableJsonNullValueInput | InputJsonValue
    position: number
  }

  export type SessionExerciseCreateOrConnectWithoutProgressInstancesInput = {
    where: SessionExerciseWhereUniqueInput
    create: XOR<SessionExerciseCreateWithoutProgressInstancesInput, SessionExerciseUncheckedCreateWithoutProgressInstancesInput>
  }

  export type SessionCreateWithoutProgressInput = {
    id?: string
    title?: string | null
    notes?: string | null
    date?: Date | string | null
    position: number
    data?: NullableJsonNullValueInput | InputJsonValue
    exercises?: SessionExerciseCreateNestedManyWithoutSessionInput
    week: WeekCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateWithoutProgressInput = {
    id?: string
    weekId: string
    title?: string | null
    notes?: string | null
    date?: Date | string | null
    position: number
    data?: NullableJsonNullValueInput | InputJsonValue
    exercises?: SessionExerciseUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutProgressInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutProgressInput, SessionUncheckedCreateWithoutProgressInput>
  }

  export type UserCreateWithoutSessionProgressInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramCreateNestedManyWithoutCoachInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutUserInput
    coach?: UserCreateNestedOneWithoutStudentsInput
    students?: UserCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutSessionProgressInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    coachId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentUncheckedCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentUncheckedCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingUncheckedCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryUncheckedCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseUncheckedCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutUserInput
    students?: UserUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutSessionProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionProgressInput, UserUncheckedCreateWithoutSessionProgressInput>
  }

  export type SessionExerciseUpsertWithoutProgressInstancesInput = {
    update: XOR<SessionExerciseUpdateWithoutProgressInstancesInput, SessionExerciseUncheckedUpdateWithoutProgressInstancesInput>
    create: XOR<SessionExerciseCreateWithoutProgressInstancesInput, SessionExerciseUncheckedCreateWithoutProgressInstancesInput>
    where?: SessionExerciseWhereInput
  }

  export type SessionExerciseUpdateToOneWithWhereWithoutProgressInstancesInput = {
    where?: SessionExerciseWhereInput
    data: XOR<SessionExerciseUpdateWithoutProgressInstancesInput, SessionExerciseUncheckedUpdateWithoutProgressInstancesInput>
  }

  export type SessionExerciseUpdateWithoutProgressInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
    exercise?: ExerciseUpdateOneRequiredWithoutSessionExercisesNestedInput
    session?: SessionUpdateOneRequiredWithoutExercisesNestedInput
  }

  export type SessionExerciseUncheckedUpdateWithoutProgressInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
  }

  export type SessionUpsertWithoutProgressInput = {
    update: XOR<SessionUpdateWithoutProgressInput, SessionUncheckedUpdateWithoutProgressInput>
    create: XOR<SessionCreateWithoutProgressInput, SessionUncheckedCreateWithoutProgressInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutProgressInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutProgressInput, SessionUncheckedUpdateWithoutProgressInput>
  }

  export type SessionUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: IntFieldUpdateOperationsInput | number
    data?: NullableJsonNullValueInput | InputJsonValue
    exercises?: SessionExerciseUpdateManyWithoutSessionNestedInput
    week?: WeekUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: IntFieldUpdateOperationsInput | number
    data?: NullableJsonNullValueInput | InputJsonValue
    exercises?: SessionExerciseUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserUpsertWithoutSessionProgressInput = {
    update: XOR<UserUpdateWithoutSessionProgressInput, UserUncheckedUpdateWithoutSessionProgressInput>
    create: XOR<UserCreateWithoutSessionProgressInput, UserUncheckedCreateWithoutSessionProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionProgressInput, UserUncheckedUpdateWithoutSessionProgressInput>
  }

  export type UserUpdateWithoutSessionProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUpdateManyWithoutCoachNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutUserNestedInput
    coach?: UserUpdateOneWithoutStudentsNestedInput
    students?: UserUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUncheckedUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUncheckedUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUncheckedUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUncheckedUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUncheckedUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutUserNestedInput
    students?: UserUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type UserCreateWithoutAssignedByInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assignedPrograms?: ProgramAssignmentCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressCreateNestedManyWithoutStudentInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutUserInput
    coach?: UserCreateNestedOneWithoutStudentsInput
    students?: UserCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutAssignedByInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    coachId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assignedPrograms?: ProgramAssignmentUncheckedCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressUncheckedCreateNestedManyWithoutStudentInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingUncheckedCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryUncheckedCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseUncheckedCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutUserInput
    students?: UserUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutAssignedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedByInput, UserUncheckedCreateWithoutAssignedByInput>
  }

  export type ProgramCreateWithoutAssignmentsInput = {
    id?: string
    title: string
    description?: string | null
    ownerId?: string | null
    isDraft?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: ProgramAuditCreateNestedManyWithoutProgramInput
    blocks?: ProgramBlockCreateNestedManyWithoutProgramInput
    coach: UserCreateNestedOneWithoutCreatedProgramsInput
  }

  export type ProgramUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    title: string
    description?: string | null
    coachId: string
    ownerId?: string | null
    isDraft?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutProgramInput
    blocks?: ProgramBlockUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutAssignmentsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutAssignmentsInput, ProgramUncheckedCreateWithoutAssignmentsInput>
  }

  export type UserCreateWithoutAssignedProgramsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentCreateNestedManyWithoutAssignerInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressCreateNestedManyWithoutStudentInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutUserInput
    coach?: UserCreateNestedOneWithoutStudentsInput
    students?: UserCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutAssignedProgramsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    coachId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentUncheckedCreateNestedManyWithoutAssignerInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressUncheckedCreateNestedManyWithoutStudentInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingUncheckedCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryUncheckedCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseUncheckedCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutUserInput
    students?: UserUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutAssignedProgramsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedProgramsInput, UserUncheckedCreateWithoutAssignedProgramsInput>
  }

  export type UserUpsertWithoutAssignedByInput = {
    update: XOR<UserUpdateWithoutAssignedByInput, UserUncheckedUpdateWithoutAssignedByInput>
    create: XOR<UserCreateWithoutAssignedByInput, UserUncheckedCreateWithoutAssignedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedByInput, UserUncheckedUpdateWithoutAssignedByInput>
  }

  export type UserUpdateWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assignedPrograms?: ProgramAssignmentUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutUserNestedInput
    coach?: UserUpdateOneWithoutStudentsNestedInput
    students?: UserUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assignedPrograms?: ProgramAssignmentUncheckedUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUncheckedUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUncheckedUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUncheckedUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUncheckedUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutUserNestedInput
    students?: UserUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type ProgramUpsertWithoutAssignmentsInput = {
    update: XOR<ProgramUpdateWithoutAssignmentsInput, ProgramUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<ProgramCreateWithoutAssignmentsInput, ProgramUncheckedCreateWithoutAssignmentsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutAssignmentsInput, ProgramUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ProgramUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: ProgramAuditUpdateManyWithoutProgramNestedInput
    blocks?: ProgramBlockUpdateManyWithoutProgramNestedInput
    coach?: UserUpdateOneRequiredWithoutCreatedProgramsNestedInput
  }

  export type ProgramUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutProgramNestedInput
    blocks?: ProgramBlockUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type UserUpsertWithoutAssignedProgramsInput = {
    update: XOR<UserUpdateWithoutAssignedProgramsInput, UserUncheckedUpdateWithoutAssignedProgramsInput>
    create: XOR<UserCreateWithoutAssignedProgramsInput, UserUncheckedCreateWithoutAssignedProgramsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedProgramsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedProgramsInput, UserUncheckedUpdateWithoutAssignedProgramsInput>
  }

  export type UserUpdateWithoutAssignedProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUpdateManyWithoutAssignerNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutUserNestedInput
    coach?: UserUpdateOneWithoutStudentsNestedInput
    students?: UserUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUncheckedUpdateManyWithoutAssignerNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUncheckedUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUncheckedUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUncheckedUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUncheckedUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutUserNestedInput
    students?: UserUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentCreateNestedManyWithoutStudentInput
    createdPrograms?: ProgramCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressCreateNestedManyWithoutStudentInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutUserInput
    coach?: UserCreateNestedOneWithoutStudentsInput
    students?: UserCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    coachId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentUncheckedCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentUncheckedCreateNestedManyWithoutStudentInput
    createdPrograms?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressUncheckedCreateNestedManyWithoutStudentInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingUncheckedCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryUncheckedCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseUncheckedCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutUserInput
    students?: UserUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type ProgramCreateWithoutAuditLogsInput = {
    id?: string
    title: string
    description?: string | null
    ownerId?: string | null
    isDraft?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: ProgramAssignmentCreateNestedManyWithoutProgramInput
    blocks?: ProgramBlockCreateNestedManyWithoutProgramInput
    coach: UserCreateNestedOneWithoutCreatedProgramsInput
  }

  export type ProgramUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    title: string
    description?: string | null
    coachId: string
    ownerId?: string | null
    isDraft?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: ProgramAssignmentUncheckedCreateNestedManyWithoutProgramInput
    blocks?: ProgramBlockUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutAuditLogsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutAuditLogsInput, ProgramUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUpdateManyWithoutStudentNestedInput
    createdPrograms?: ProgramUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutUserNestedInput
    coach?: UserUpdateOneWithoutStudentsNestedInput
    students?: UserUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUncheckedUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUncheckedUpdateManyWithoutStudentNestedInput
    createdPrograms?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUncheckedUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUncheckedUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUncheckedUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUncheckedUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutUserNestedInput
    students?: UserUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type ProgramUpsertWithoutAuditLogsInput = {
    update: XOR<ProgramUpdateWithoutAuditLogsInput, ProgramUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<ProgramCreateWithoutAuditLogsInput, ProgramUncheckedCreateWithoutAuditLogsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutAuditLogsInput, ProgramUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ProgramUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: ProgramAssignmentUpdateManyWithoutProgramNestedInput
    blocks?: ProgramBlockUpdateManyWithoutProgramNestedInput
    coach?: UserUpdateOneRequiredWithoutCreatedProgramsNestedInput
  }

  export type ProgramUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: ProgramAssignmentUncheckedUpdateManyWithoutProgramNestedInput
    blocks?: ProgramBlockUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type UserBadgeCreateWithoutBadgeInput = {
    id?: string
    awardedAt?: Date | string
    user: UserCreateNestedOneWithoutBadgesInput
  }

  export type UserBadgeUncheckedCreateWithoutBadgeInput = {
    id?: string
    userId: string
    awardedAt?: Date | string
  }

  export type UserBadgeCreateOrConnectWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    create: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type UserBadgeCreateManyBadgeInputEnvelope = {
    data: UserBadgeCreateManyBadgeInput | UserBadgeCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type UserBadgeUpsertWithWhereUniqueWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    update: XOR<UserBadgeUpdateWithoutBadgeInput, UserBadgeUncheckedUpdateWithoutBadgeInput>
    create: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type UserBadgeUpdateWithWhereUniqueWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    data: XOR<UserBadgeUpdateWithoutBadgeInput, UserBadgeUncheckedUpdateWithoutBadgeInput>
  }

  export type UserBadgeUpdateManyWithWhereWithoutBadgeInput = {
    where: UserBadgeScalarWhereInput
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyWithoutBadgeInput>
  }

  export type BadgeCreateWithoutUserBadgesInput = {
    id?: string
    key: string
    title: JsonNullValueInput | InputJsonValue
    description: JsonNullValueInput | InputJsonValue
    criteria: JsonNullValueInput | InputJsonValue
  }

  export type BadgeUncheckedCreateWithoutUserBadgesInput = {
    id?: string
    key: string
    title: JsonNullValueInput | InputJsonValue
    description: JsonNullValueInput | InputJsonValue
    criteria: JsonNullValueInput | InputJsonValue
  }

  export type BadgeCreateOrConnectWithoutUserBadgesInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutUserBadgesInput, BadgeUncheckedCreateWithoutUserBadgesInput>
  }

  export type UserCreateWithoutBadgesInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressCreateNestedManyWithoutStudentInput
    exerciseRatings?: ExerciseRatingCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutUserInput
    coach?: UserCreateNestedOneWithoutStudentsInput
    students?: UserCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutBadgesInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    coachId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assignedBy?: ProgramAssignmentUncheckedCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentUncheckedCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressUncheckedCreateNestedManyWithoutStudentInput
    exerciseRatings?: ExerciseRatingUncheckedCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryUncheckedCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseUncheckedCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutUserInput
    students?: UserUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutBadgesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
  }

  export type BadgeUpsertWithoutUserBadgesInput = {
    update: XOR<BadgeUpdateWithoutUserBadgesInput, BadgeUncheckedUpdateWithoutUserBadgesInput>
    create: XOR<BadgeCreateWithoutUserBadgesInput, BadgeUncheckedCreateWithoutUserBadgesInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutUserBadgesInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutUserBadgesInput, BadgeUncheckedUpdateWithoutUserBadgesInput>
  }

  export type BadgeUpdateWithoutUserBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    description?: JsonNullValueInput | InputJsonValue
    criteria?: JsonNullValueInput | InputJsonValue
  }

  export type BadgeUncheckedUpdateWithoutUserBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: JsonNullValueInput | InputJsonValue
    description?: JsonNullValueInput | InputJsonValue
    criteria?: JsonNullValueInput | InputJsonValue
  }

  export type UserUpsertWithoutBadgesInput = {
    update: XOR<UserUpdateWithoutBadgesInput, UserUncheckedUpdateWithoutBadgesInput>
    create: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBadgesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBadgesInput, UserUncheckedUpdateWithoutBadgesInput>
  }

  export type UserUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUpdateManyWithoutStudentNestedInput
    exerciseRatings?: ExerciseRatingUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutUserNestedInput
    coach?: UserUpdateOneWithoutStudentsNestedInput
    students?: UserUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUncheckedUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUncheckedUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUncheckedUpdateManyWithoutStudentNestedInput
    exerciseRatings?: ExerciseRatingUncheckedUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUncheckedUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUncheckedUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutUserNestedInput
    students?: UserUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationCreateNestedManyWithoutToUserInput
    assignedBy?: ProgramAssignmentCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressCreateNestedManyWithoutStudentInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutUserInput
    coach?: UserCreateNestedOneWithoutStudentsInput
    students?: UserCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    coachId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutFromCoachInput
    receivedInvitations?: InvitationUncheckedCreateNestedManyWithoutToUserInput
    assignedBy?: ProgramAssignmentUncheckedCreateNestedManyWithoutAssignerInput
    assignedPrograms?: ProgramAssignmentUncheckedCreateNestedManyWithoutStudentInput
    auditLogs?: ProgramAuditUncheckedCreateNestedManyWithoutUserInput
    createdPrograms?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    sessionProgress?: SessionProgressUncheckedCreateNestedManyWithoutStudentInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    exerciseRatings?: ExerciseRatingUncheckedCreateNestedManyWithoutUserInput
    exerciseHistory?: ExerciseHistoryUncheckedCreateNestedManyWithoutUserInput
    favoriteExercises?: FavoriteExerciseUncheckedCreateNestedManyWithoutUserInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutUserInput
    students?: UserUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUpdateManyWithoutToUserNestedInput
    assignedBy?: ProgramAssignmentUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutUserNestedInput
    coach?: UserUpdateOneWithoutStudentsNestedInput
    students?: UserUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUncheckedUpdateManyWithoutToUserNestedInput
    assignedBy?: ProgramAssignmentUncheckedUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUncheckedUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUncheckedUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUncheckedUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUncheckedUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUncheckedUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutUserNestedInput
    students?: UserUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type ExerciseCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope: $Enums.Scope
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupMemberCreateManyUserInput = {
    id?: string
    groupId: string
    roleInGroup?: string
    joinedAt?: Date | string
  }

  export type GroupCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvitationCreateManyFromCoachInput = {
    id?: string
    groupId: string
    toUserId: string
    status: $Enums.InvitationStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type InvitationCreateManyToUserInput = {
    id?: string
    groupId: string
    fromCoachId: string
    status: $Enums.InvitationStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type ProgramAssignmentCreateManyAssignerInput = {
    id?: string
    programId: string
    studentId: string
    assignedAt?: Date | string
  }

  export type ProgramAssignmentCreateManyStudentInput = {
    id?: string
    programId: string
    assignedBy?: string | null
    assignedAt?: Date | string
  }

  export type ProgramAuditCreateManyUserInput = {
    id?: string
    programId: string
    changeType: string
    diff?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ProgramCreateManyCoachInput = {
    id?: string
    title: string
    description?: string | null
    ownerId?: string | null
    isDraft?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionProgressCreateManyStudentInput = {
    id?: string
    sessionId: string
    exerciseInstanceId?: string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    videos?: SessionProgressCreatevideosInput | string[]
    savedAt?: Date | string
  }

  export type UserBadgeCreateManyUserInput = {
    id?: string
    badgeId: string
    awardedAt?: Date | string
  }

  export type ExerciseRatingCreateManyUserInput = {
    id?: string
    exerciseId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseHistoryCreateManyUserInput = {
    id?: string
    exerciseId: string
    viewedAt?: Date | string
  }

  export type FavoriteExerciseCreateManyUserInput = {
    id?: string
    exerciseId: string
    addedAt?: Date | string
  }

  export type WorkoutSessionCreateManyUserInput = {
    id?: string
    title?: string | null
    startedAt?: Date | string
    startTime?: Date | string | null
    endedAt?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    notes?: string | null
    restPeriodSeconds?: number | null
    formGuidanceEnabled?: boolean | null
    exercisesCompleted?: number | null
    totalExercises?: number | null
  }

  export type UserCreateManyCoachInput = {
    id?: string
    email: string
    pseudo: string
    password: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.Role
    profileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope?: EnumScopeFieldUpdateOperationsInput | $Enums.Scope
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionExercises?: SessionExerciseUpdateManyWithoutExerciseNestedInput
    ratings?: ExerciseRatingUpdateManyWithoutExerciseNestedInput
    history?: ExerciseHistoryUpdateManyWithoutExerciseNestedInput
    favorites?: FavoriteExerciseUpdateManyWithoutExerciseNestedInput
    logs?: ExerciseLogUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope?: EnumScopeFieldUpdateOperationsInput | $Enums.Scope
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionExercises?: SessionExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    ratings?: ExerciseRatingUncheckedUpdateManyWithoutExerciseNestedInput
    history?: ExerciseHistoryUncheckedUpdateManyWithoutExerciseNestedInput
    favorites?: FavoriteExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    logs?: ExerciseLogUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    meta?: NullableJsonNullValueInput | InputJsonValue
    scope?: EnumScopeFieldUpdateOperationsInput | $Enums.Scope
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleInGroup?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type GroupMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    roleInGroup?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    roleInGroup?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    invitations?: InvitationUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUpdateWithoutFromCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group?: GroupUpdateOneRequiredWithoutInvitationsNestedInput
    toUser?: UserUpdateOneRequiredWithoutReceivedInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateWithoutFromCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvitationUncheckedUpdateManyWithoutFromCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvitationUpdateWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fromCoach?: UserUpdateOneRequiredWithoutSentInvitationsNestedInput
    group?: GroupUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    fromCoachId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvitationUncheckedUpdateManyWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    fromCoachId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramAssignmentUpdateWithoutAssignerInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutAssignmentsNestedInput
    student?: UserUpdateOneRequiredWithoutAssignedProgramsNestedInput
  }

  export type ProgramAssignmentUncheckedUpdateWithoutAssignerInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramAssignmentUncheckedUpdateManyWithoutAssignerInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramAssignmentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assigner?: UserUpdateOneWithoutAssignedByNestedInput
    program?: ProgramUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type ProgramAssignmentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramAssignmentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramAuditUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    diff?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type ProgramAuditUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    diff?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramAuditUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    diff?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: ProgramAssignmentUpdateManyWithoutProgramNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutProgramNestedInput
    blocks?: ProgramBlockUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: ProgramAssignmentUncheckedUpdateManyWithoutProgramNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutProgramNestedInput
    blocks?: ProgramBlockUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateManyWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionProgressUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: SessionProgressUpdatevideosInput | string[]
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseInstance?: SessionExerciseUpdateOneWithoutProgressInstancesNestedInput
    session?: SessionUpdateOneRequiredWithoutProgressNestedInput
  }

  export type SessionProgressUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    exerciseInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: SessionProgressUpdatevideosInput | string[]
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionProgressUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    exerciseInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: SessionProgressUpdatevideosInput | string[]
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    badge?: BadgeUpdateOneRequiredWithoutUserBadgesNestedInput
  }

  export type UserBadgeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseRatingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercise?: ExerciseUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type ExerciseRatingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseRatingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercise?: ExerciseUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type ExerciseHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteExerciseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercise?: ExerciseUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteExerciseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteExerciseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    restPeriodSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    formGuidanceEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exercisesCompleted?: NullableIntFieldUpdateOperationsInput | number | null
    totalExercises?: NullableIntFieldUpdateOperationsInput | number | null
    logs?: ExerciseLogUpdateManyWithoutSessionNestedInput
  }

  export type WorkoutSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    restPeriodSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    formGuidanceEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exercisesCompleted?: NullableIntFieldUpdateOperationsInput | number | null
    totalExercises?: NullableIntFieldUpdateOperationsInput | number | null
    logs?: ExerciseLogUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type WorkoutSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    restPeriodSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    formGuidanceEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exercisesCompleted?: NullableIntFieldUpdateOperationsInput | number | null
    totalExercises?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutUserNestedInput
    students?: UserUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutFromCoachNestedInput
    receivedInvitations?: InvitationUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assignedBy?: ProgramAssignmentUncheckedUpdateManyWithoutAssignerNestedInput
    assignedPrograms?: ProgramAssignmentUncheckedUpdateManyWithoutStudentNestedInput
    auditLogs?: ProgramAuditUncheckedUpdateManyWithoutUserNestedInput
    createdPrograms?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    sessionProgress?: SessionProgressUncheckedUpdateManyWithoutStudentNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    exerciseRatings?: ExerciseRatingUncheckedUpdateManyWithoutUserNestedInput
    exerciseHistory?: ExerciseHistoryUncheckedUpdateManyWithoutUserNestedInput
    favoriteExercises?: FavoriteExerciseUncheckedUpdateManyWithoutUserNestedInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutUserNestedInput
    students?: UserUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pseudo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateManyGroupInput = {
    id?: string
    userId: string
    roleInGroup?: string
    joinedAt?: Date | string
  }

  export type InvitationCreateManyGroupInput = {
    id?: string
    fromCoachId: string
    toUserId: string
    status: $Enums.InvitationStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type GroupMemberUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleInGroup?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGroupMembershipsNestedInput
  }

  export type GroupMemberUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleInGroup?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleInGroup?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fromCoach?: UserUpdateOneRequiredWithoutSentInvitationsNestedInput
    toUser?: UserUpdateOneRequiredWithoutReceivedInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromCoachId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvitationUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromCoachId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionExerciseCreateManyExerciseInput = {
    id?: string
    sessionId: string
    config?: NullableJsonNullValueInput | InputJsonValue
    position: number
  }

  export type ExerciseRatingCreateManyExerciseInput = {
    id?: string
    userId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseHistoryCreateManyExerciseInput = {
    id?: string
    userId: string
    viewedAt?: Date | string
  }

  export type FavoriteExerciseCreateManyExerciseInput = {
    id?: string
    userId: string
    addedAt?: Date | string
  }

  export type ExerciseLogCreateManyExerciseInput = {
    id?: string
    sessionId: string
    userId?: string | null
    reps?: number | null
    sets?: number | null
    setsCompleted?: number | null
    weight?: number | null
    duration?: number | null
    formRating?: number | null
    skipped?: boolean | null
    notes?: string | null
    loggedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SessionExerciseUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
    session?: SessionUpdateOneRequiredWithoutExercisesNestedInput
    progressInstances?: SessionProgressUpdateManyWithoutExerciseInstanceNestedInput
  }

  export type SessionExerciseUncheckedUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
    progressInstances?: SessionProgressUncheckedUpdateManyWithoutExerciseInstanceNestedInput
  }

  export type SessionExerciseUncheckedUpdateManyWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ExerciseRatingUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExerciseRatingsNestedInput
  }

  export type ExerciseRatingUncheckedUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseRatingUncheckedUpdateManyWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseHistoryUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExerciseHistoryNestedInput
  }

  export type ExerciseHistoryUncheckedUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseHistoryUncheckedUpdateManyWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteExerciseUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoriteExercisesNestedInput
  }

  export type FavoriteExerciseUncheckedUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteExerciseUncheckedUpdateManyWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseLogUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    setsCompleted?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    formRating?: NullableIntFieldUpdateOperationsInput | number | null
    skipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    loggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session?: WorkoutSessionUpdateOneRequiredWithoutLogsNestedInput
  }

  export type ExerciseLogUncheckedUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    setsCompleted?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    formRating?: NullableIntFieldUpdateOperationsInput | number | null
    skipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    loggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExerciseLogUncheckedUpdateManyWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    setsCompleted?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    formRating?: NullableIntFieldUpdateOperationsInput | number | null
    skipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    loggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExerciseLogCreateManySessionInput = {
    id?: string
    exerciseId: string
    userId?: string | null
    reps?: number | null
    sets?: number | null
    setsCompleted?: number | null
    weight?: number | null
    duration?: number | null
    formRating?: number | null
    skipped?: boolean | null
    notes?: string | null
    loggedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ExerciseLogUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    setsCompleted?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    formRating?: NullableIntFieldUpdateOperationsInput | number | null
    skipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    loggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exercise?: ExerciseUpdateOneRequiredWithoutLogsNestedInput
  }

  export type ExerciseLogUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    setsCompleted?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    formRating?: NullableIntFieldUpdateOperationsInput | number | null
    skipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    loggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExerciseLogUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    setsCompleted?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    formRating?: NullableIntFieldUpdateOperationsInput | number | null
    skipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    loggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProgramAssignmentCreateManyProgramInput = {
    id?: string
    studentId: string
    assignedBy?: string | null
    assignedAt?: Date | string
  }

  export type ProgramAuditCreateManyProgramInput = {
    id?: string
    changedBy: string
    changeType: string
    diff?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ProgramBlockCreateManyProgramInput = {
    id?: string
    title?: string | null
    position: number
    notes?: string | null
  }

  export type ProgramAssignmentUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assigner?: UserUpdateOneWithoutAssignedByNestedInput
    student?: UserUpdateOneRequiredWithoutAssignedProgramsNestedInput
  }

  export type ProgramAssignmentUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramAssignmentUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramAuditUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    diff?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type ProgramAuditUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    diff?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramAuditUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    diff?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramBlockUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weeks?: WeekUpdateManyWithoutBlockNestedInput
  }

  export type ProgramBlockUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weeks?: WeekUncheckedUpdateManyWithoutBlockNestedInput
  }

  export type ProgramBlockUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeekCreateManyBlockInput = {
    id?: string
    weekNumber: number
    position: number
  }

  export type WeekUpdateWithoutBlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    sessions?: SessionUpdateManyWithoutWeekNestedInput
  }

  export type WeekUncheckedUpdateWithoutBlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    sessions?: SessionUncheckedUpdateManyWithoutWeekNestedInput
  }

  export type WeekUncheckedUpdateManyWithoutBlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type SessionCreateManyWeekInput = {
    id?: string
    title?: string | null
    notes?: string | null
    date?: Date | string | null
    position: number
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionUpdateWithoutWeekInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: IntFieldUpdateOperationsInput | number
    data?: NullableJsonNullValueInput | InputJsonValue
    exercises?: SessionExerciseUpdateManyWithoutSessionNestedInput
    progress?: SessionProgressUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutWeekInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: IntFieldUpdateOperationsInput | number
    data?: NullableJsonNullValueInput | InputJsonValue
    exercises?: SessionExerciseUncheckedUpdateManyWithoutSessionNestedInput
    progress?: SessionProgressUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateManyWithoutWeekInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: IntFieldUpdateOperationsInput | number
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionExerciseCreateManySessionInput = {
    id?: string
    exerciseId: string
    config?: NullableJsonNullValueInput | InputJsonValue
    position: number
  }

  export type SessionProgressCreateManySessionInput = {
    id?: string
    studentId: string
    exerciseInstanceId?: string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    videos?: SessionProgressCreatevideosInput | string[]
    savedAt?: Date | string
  }

  export type SessionExerciseUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
    exercise?: ExerciseUpdateOneRequiredWithoutSessionExercisesNestedInput
    progressInstances?: SessionProgressUpdateManyWithoutExerciseInstanceNestedInput
  }

  export type SessionExerciseUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
    progressInstances?: SessionProgressUncheckedUpdateManyWithoutExerciseInstanceNestedInput
  }

  export type SessionExerciseUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
  }

  export type SessionProgressUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: SessionProgressUpdatevideosInput | string[]
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseInstance?: SessionExerciseUpdateOneWithoutProgressInstancesNestedInput
    student?: UserUpdateOneRequiredWithoutSessionProgressNestedInput
  }

  export type SessionProgressUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    exerciseInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: SessionProgressUpdatevideosInput | string[]
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionProgressUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    exerciseInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: SessionProgressUpdatevideosInput | string[]
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionProgressCreateManyExerciseInstanceInput = {
    id?: string
    sessionId: string
    studentId: string
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    videos?: SessionProgressCreatevideosInput | string[]
    savedAt?: Date | string
  }

  export type SessionProgressUpdateWithoutExerciseInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: SessionProgressUpdatevideosInput | string[]
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutProgressNestedInput
    student?: UserUpdateOneRequiredWithoutSessionProgressNestedInput
  }

  export type SessionProgressUncheckedUpdateWithoutExerciseInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: SessionProgressUpdatevideosInput | string[]
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionProgressUncheckedUpdateManyWithoutExerciseInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: SessionProgressUpdatevideosInput | string[]
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateManyBadgeInput = {
    id?: string
    userId: string
    awardedAt?: Date | string
  }

  export type UserBadgeUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type UserBadgeUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupCountOutputTypeDefaultArgs instead
     */
    export type GroupCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExerciseCountOutputTypeDefaultArgs instead
     */
    export type ExerciseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExerciseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkoutSessionCountOutputTypeDefaultArgs instead
     */
    export type WorkoutSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkoutSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramCountOutputTypeDefaultArgs instead
     */
    export type ProgramCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramBlockCountOutputTypeDefaultArgs instead
     */
    export type ProgramBlockCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramBlockCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WeekCountOutputTypeDefaultArgs instead
     */
    export type WeekCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WeekCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionCountOutputTypeDefaultArgs instead
     */
    export type SessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionExerciseCountOutputTypeDefaultArgs instead
     */
    export type SessionExerciseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionExerciseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BadgeCountOutputTypeDefaultArgs instead
     */
    export type BadgeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BadgeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupDefaultArgs instead
     */
    export type GroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupMemberDefaultArgs instead
     */
    export type GroupMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvitationDefaultArgs instead
     */
    export type InvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvitationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExerciseDefaultArgs instead
     */
    export type ExerciseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExerciseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExerciseRatingDefaultArgs instead
     */
    export type ExerciseRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExerciseRatingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExerciseHistoryDefaultArgs instead
     */
    export type ExerciseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExerciseHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FavoriteExerciseDefaultArgs instead
     */
    export type FavoriteExerciseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FavoriteExerciseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkoutSessionDefaultArgs instead
     */
    export type WorkoutSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkoutSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExerciseLogDefaultArgs instead
     */
    export type ExerciseLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExerciseLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramDefaultArgs instead
     */
    export type ProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramBlockDefaultArgs instead
     */
    export type ProgramBlockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramBlockDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WeekDefaultArgs instead
     */
    export type WeekArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WeekDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionExerciseDefaultArgs instead
     */
    export type SessionExerciseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionExerciseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionProgressDefaultArgs instead
     */
    export type SessionProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionProgressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramAssignmentDefaultArgs instead
     */
    export type ProgramAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramAssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramAuditDefaultArgs instead
     */
    export type ProgramAuditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramAuditDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BadgeDefaultArgs instead
     */
    export type BadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BadgeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserBadgeDefaultArgs instead
     */
    export type UserBadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserBadgeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}